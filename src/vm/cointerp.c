/* Automatically generated by
	CCodeGeneratorGlobalStructure .oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
   from
	CoInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
 */
static char __buildInfo[] = "CoInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sq.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"
#include "sqCogStackAlignment.h"
#include "cogmethod.h"
#include "cointerp.h"
#include "cogit.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 * Note: on windows 64 via mingw-w64, the 2nd argument NULL to _setjmp prevents stack unwinding
 */
#undef sigsetjmp
#undef siglongjmp
#if _MSC_VER
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN64 && __GNUC__
# define sigsetjmp(jb,ssmf) _setjmp(jb,NULL)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

#define odd(v) ((int)(v)&1)
#define even(v) (!odd(v))

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFU
#define AllButMarkBit 0x7FFFFFFF
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFU
#define AllButTypeMask 0xFFFFFFFCU
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define BytecodeSetHasExtensions 0
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define CheckAllocationFillerAfterPrimCall 32
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 0
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMessageCompactIndex 0
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CMBlock 3
#define CMClosedPIC 4
#define CMMethod 2
#define CMOpenPIC 5
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne 0xFFFFFFFFU
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CSCallbackLeave 4
#define CSEnterCriticalSection 5
#define CSExitCriticalSection 6
#define CSResume 7
#define CSSignal 8
#define CSSuspend 9
#define CSWait 10
#define CSYield 11
#define CtxtTempFrameStart 6
#define DoAssertionChecks (!PRODUCTION)
#define DoExpensiveAssertionChecks 0
#define Done 4
#define DumpStackOnLowSpace 0
#define EncounteredUnknownBytecode -6
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 1
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerSavedIP 4
#define FoxIFReceiver -20
#define FoxIFrameFlags -12
#define FoxIFSavedIP -16
#define FoxMethod -4
#define FoxMFReceiver -12
#define FoxSavedFP 0
#define FoxThisContext -8
#define FullClosureFirstCopiedValueIndex 4
#define GCCheckPrimCall 64
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GCTopMarker 3
#define HasBeenReturnedFromMCPC -1
#define HasBeenReturnedFromMCPCOop 0xFFFFFFFFU
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define IFrameSlots 7
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define ImmutabilityBit 0x20000000
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCU
#define LongSizeNumBits 30
#define LongStoreBytecode 129
#define LookupRuleMNU 259
#define LowcodeVM 0
#define MarkBit 0x80000000U
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxLiteralCountForCompile 60
#define MaxNegativeErrorCode -8
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderFlagBitPosition 29
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MethodTooBig -4
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MFMethodFlagsMask 0x7
#define MFMethodMask -0x8
#define MFrameSlots 5
#define MillisecondClockMask 0x1FFFFFFF
#define MinBackwardJumpCountForCompile 40
#define MULTIPLEBYTECODESETS 0
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define NotFullyInitialized -1
#define NSMethodCacheActualReceiver 7
#define NSMethodCacheCallingMethod 3
#define NSMethodCacheClassTag 2
#define NSMethodCacheDepthOrLookupRule 4
#define NSMethodCacheMask 0xFF8
#define NSMethodCachePrimFunction 6
#define NSMethodCacheSelector 1
#define NSMethodCacheSize 4096
#define NSMethodCacheTargetMethod 5
#define OldBecameNewFlag 4
#if !defined(PharoVM) /* Allow this to be overridden on the compiler command line */
# define PharoVM 0
#endif
#define PrimCallCollectsProfileSamples 16
#define PrimCallMayCallBack 4
#define PrimCallNeedsNewMethod 1
#define PrimCallNeedsPrimitiveFunction 2
#define PrimCallOnSmalltalkStack 8
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimNoErr 0
#define PrimNumberExternalCall 117
#define PrimNumberFFICall 120
#define PrimNumberHashMultiply 159
#define PrimTraceLogSize 256
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define ReturnToInterpreter 1
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorAttemptToAssign 50
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define ShouldNotJIT -8
#define SistaV1BytecodeSet 0
#define SistaVM 0
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSlots 22
#define SPURVM 0
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TraceBlockActivation 5
#define TraceBlockCreation 7
#define TraceBufferSize 768
#define TraceCodeCompaction 13
#define TraceContextSwitch 3
#define TraceFullGC 11
#define TraceIncrementalGC 9
#define TraceIsFromInterpreter 2
#define TraceIsFromMachineCode 1
#define TracePrimitiveFailure 29
#define TracePrimitiveRetry 31
#define TraceStackOverflow 27
#define TraceVMCallback 23
#define TraceVMCallbackReturn 25
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFU
#define XIndex 0
#define YIndex 1

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static CogMethod * NoDbgRegParms cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
static void NoDbgRegParms activateCoggedNewMethod(sqInt inInterpreter);
static void activateNewMethod(void);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
extern usqInt argumentCountAddress(void);
static CogMethod * NoDbgRegParms asCogHomeMethod(CogBlockMethod *aCogMethod);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter, sqInt ln);
extern void assertValidMachineCodeFrame(sqInt instrPtr);
static sqInt NoDbgRegParms assertValidStackedInstructionPointersInline(StackPage *aStackPage, sqInt ln);
static void NoDbgRegParms assertValidStackedInstructionPointers(sqInt ln);
static void NoDbgRegParms attemptToSwitchToMachineCode(sqInt bcpc);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
extern void callForCogCompiledCodeCompaction(void);
static void NoDbgRegParms callRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr);
extern void ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod);
extern sqInt ceActiveContext(void);
extern sqInt ceBaseFrameReturn(sqInt returnValue);
#if IMMUTABILITY
extern sqInt ceCannotAssignTowithIndexvalueToAssign(sqInt immutableObject, sqInt index, sqInt valueToAssign);
#endif /* IMMUTABILITY */
extern sqInt ceCannotResume(void);
extern void ceCheckForInterrupts(void);
extern void ceCheckProfileTick(void);
extern sqInt ceContextinstVar(sqInt maybeContext, sqInt slotIndex);
extern sqInt ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop);
extern sqInt ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr);
extern sqInt ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr);
extern sqInt ceNewArraySlotSize(sqInt slotSize);
extern sqInt ceNonLocalReturn(sqInt returnValue);
extern sqInt ceReturnToInterpreter(sqInt anOop);
extern sqInt ceSendAborttonumArgs(sqInt selector, sqInt rcvr, sqInt numArgs);
extern sqInt ceSendFromInLineCacheMiss(CogMethod *cogMethodOrPIC);
extern void ceSendMustBeBooleanTointerpretingAtDelta(sqInt aNonBooleanObject, sqInt jumpSize);
extern sqInt ceSendMustBeBoolean(sqInt anObject);
extern sqInt ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs);
extern void ceStackOverflow(sqInt contextSwitchIfNotNil);
extern void ceTraceBlockActivation(void);
extern void ceTraceLinkedSend(sqInt theReceiver);
extern void ceTraceStoreOfinto(sqInt aValue, sqInt anObject);
extern void checkAssertsEnabledInCoInterpreter(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt gcModes);
static sqInt checkLogIntegrity(void);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
static sqInt checkStackIntegrity(void);
extern void clearTraceLog(void);
extern CogMethod * cogMethodOf(sqInt aMethodOop);
static void commenceCogCompiledCodeCompaction(void);
extern void compilationBreakpointFor(sqInt selectorOop);
static sqInt NoDbgRegParms contextInstructionPointerframe(sqInt theIP, char *theFP);
extern sqInt createClosureNumArgsnumCopiedstartpc(sqInt numArgs, sqInt numCopied, sqInt initialIP);
extern sqInt defaultNativeStackFrameSize(void);
static sqInt NoDbgRegParms deferStackLimitSmashAroundwith(void (*functionSymbol)(sqInt), sqInt arg);
static sqInt NoDbgRegParms divorceAMachineCodeFrameWithCogMethodin(CogMethod *cogMethod, StackPage *aStackPage);
extern void dumpPrimTraceLog(void);
extern void dumpTraceLog(void);
static void NoDbgRegParms ensureContextHasBytecodePC(sqInt aContext);
static void NoDbgRegParms ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext);
static sqInt enterSmalltalkExecutiveImplementation(void);
extern void executeCogMethodfromLinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr);
static void NoDbgRegParms executeCogMethodfromUnlinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr);
extern void executeCogPICfromLinkedSendWithReceiverandCacheTag(CogMethod *cogPIC, sqInt rcvr, sqInt cacheTag);
static sqInt executeNewMethod(void);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static void NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern void flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static sqInt NoDbgRegParms frameCallerContextput(char *theFP, sqInt aValue);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
extern usqInt framePointerAddress(void);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
extern void (*functionPointerForCompiledMethodprimitiveIndex(sqInt methodObj, sqInt primIndex))(void) ;
extern sqInt getCheckAllocFiller(void);
extern sqInt getCurrentBytecode(void);
static sqInt NoDbgRegParms handleMNUInMachineCodeToclassForMessage(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage);
static sqInt NoDbgRegParms iframeIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms iframeReceiver(char *theFP);
static sqInt NoDbgRegParms iframeSavedIP(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern usqInt instructionPointerAddress(void);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern usqInt interpretAddress(void);
static sqInt NeverInline interpreterAllocationReserveBytes(void);
static sqInt interpretMethodFromMachineCode(void);
extern sqInt isCogMethodReference(sqInt methodHeader);
static sqInt NoDbgRegParms isMachineCodeFrame(char *theFP);
extern sqInt lookupMNUreceiver(sqInt selector, sqInt rcvr);
extern sqInt lookupOrdinaryreceiver(sqInt selector, sqInt rcvr);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
static void mapPrimTraceLog(void);
static void NeverInline mapStackPages(void);
static void mapTraceLog(void);
extern void markActiveMethodsAndReferents(void);
static void markAndTracePrimTraceLog(void);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceTraceLog(void);
static void NoDbgRegParms markCogMethodsAndReferentsOnPage(StackPage *thePage);
extern sqInt marryFrameCopiesTemps(void);
extern sqInt maxLookupNoMNUErrorCode(void);
static void NoDbgRegParms maybeFlagMethodAsInterpreted(sqInt aMethod);
extern sqInt mcprimFunctionForPrimitiveIndex(sqInt primIndex);
extern void * methodCacheAddress(void);
extern sqInt methodHasCogMethod(sqInt aMethodOop);
extern sqInt methodNeedsLargeContext(sqInt methodObj);
extern sqInt methodShouldBeCogged(sqInt aMethodObj);
static sqInt NoDbgRegParms methodWithHeaderShouldBeCogged(sqInt methodHeader);
static CogBlockMethod * NoDbgRegParms mframeCogMethod(char *theFP);
extern CogMethod * mframeHomeMethodExport(void);
extern CogMethod * mframeHomeMethod(char *theFP);
static sqInt NoDbgRegParms mframeIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms mframeReceiver(char *theFP);
static sqInt minimumUnusedHeadroom(void);
extern sqInt mMethodClass(void);
extern void mnuCompilationBreakpointFor(sqInt selectorOop);
static sqInt NoDbgRegParms mnuMethodOrNilFor(sqInt rcvr);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static sqInt NoDbgRegParms mustMapMachineCodePCcontext(sqInt theIP, sqInt aOnceMarriedContext);
extern usqInt newMethodAddress(void);
static sqInt NoDbgRegParms newMethodInLookupCacheAtand(sqInt selector, sqInt classTag);
extern usqInt nextProfileTickAddress(void);
extern sqInt noAssertHeaderOf(sqInt methodPointer);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern unsigned int positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
static void NoDbgRegParms postGCAction(sqInt gcModeArg);
static void NoDbgRegParms preGCAction(sqInt gcModeArg);
extern sqInt primErrTable(void);
extern usqInt primFailCodeAddress(void);
extern usqInt primitiveFailAddress(void);
extern sqInt primitivePropertyFlags(sqInt primIndex);
extern void * primTraceLogAddress(void);
extern usqInt primTraceLogIndexAddress(void);
extern void printCogMethod(CogMethod *cogMethod);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameMethodFor(char *theFP);
static void NoDbgRegParms printFrameThingatextraString(char *name, char *address, char *extraStringOrNil);
static void NoDbgRegParms printFrameThingatextra(char *name, char *address, sqInt extraValue);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
static void NoDbgRegParms printLogEntryAt(sqInt i);
extern void printMethodCacheFor(sqInt thing);
static sqInt NoDbgRegParms printPrimLogEntryAt(sqInt i);
extern sqInt quickPrimitiveConstantFor(sqInt aQuickPrimitiveIndex);
extern sqInt (*quickPrimitiveGeneratorFor(sqInt aQuickPrimitiveIndex))(void) ;
extern sqInt quickPrimitiveInstVarIndexFor(sqInt primIndex);
extern sqInt rawHeaderOf(sqInt methodPointer);
extern void rawHeaderOfput(sqInt methodOop, sqInt cogMethodOrMethodHeader);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
extern void reportMinimumUnusedHeadroom(void);
static sqInt NoDbgRegParms resumepreemptedYieldingIffrom(sqInt aProcess, sqInt yieldImplicitly, sqInt sourceCode);
static sqInt NoDbgRegParms returnToExecutivepostContextSwitch(sqInt inInterpreter, sqInt switchedContext);
static sqInt NoDbgRegParms returntoExecutive(sqInt returnValue, sqInt inInterpreter);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern int signed32BitValueOf(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqLong signed64BitValueOf(sqInt oop);
static sqInt slowPrimitiveResponse(void);
extern sqInt specialSelectorNumArgs(sqInt index);
extern usqInt stackLimitAddress(void);
static sqInt stackLimitOffset(void);
static sqInt stackPageHeadroom(void);
extern usqInt stackPointerAddress(void);
extern sqInt startPCOfMethodHeader(sqInt aCompiledMethodHeader);
extern sqInt startPCOrNilOfLiteralin(sqInt lit, sqInt aMethodObj);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
static void NoDbgRegParms tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(sqInt contextToReturnFrom, sqInt contextToReturnTo, sqInt returnValue);
static void NoDbgRegParms transferTofrom(sqInt newProc, sqInt sourceCode);
extern void updateStackZoneReferencesToCompiledCodePreCompaction(void);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
extern sqInt validInstructionPointerinMethodframePointer(usqInt instrPointer, usqInt aMethod, char *fp);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
extern usqInt varBaseAddress(void);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
extern char * whereIs(sqInt anOop);
static void NoDbgRegParms NeverInline widowOrForceToBytecodePC(sqInt ctxt);
static sqInt NoDbgRegParms frameIsMarked(sqInt theFPInt);
extern sqInt mcprimHashMultiply(sqInt receiverArg);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveCollectCogCodeConstituents(void);
static void primitiveContextXray(void);
static void primitiveEnterCriticalSection(void);
static void primitiveExitCriticalSection(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
extern usqInt primitiveFunctionPointerAddress(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
EXPORT(sqInt) primitiveMethodPCData(void);
static void primitiveMethodXray(void);
EXPORT(void) primitiveMinimumUnusedHeadroom(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
static void primitiveResume(void);
static void primitiveSignal(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSuspend(void);
static void primitiveTerminateTo(void);
static void primitiveVoidVMState(void);
static void primitiveVoidVMStateForMethod(void);
static void primitiveWait(void);
static void primitiveYield(void);
static void unmarkAllFrames(void);
static void NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
static int NoDbgRegParms noInlineSigned32BitValueGutsOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCoarseLocalMicrosecondClock(void);
static void primitiveCoarseUTCMicrosecondClock(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
extern sqInt ceStoreCheck(sqInt anOop);
static sqInt NoDbgRegParms cheapAddressCouldBeInHeap(sqInt address);
static void clearLeakMapAndMapAccessibleObjects(void);
static sqInt NoDbgRegParms copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
extern usqInt freeStartAddress(void);
extern sqInt isReallyYoungObject(sqInt obj);
extern sqInt methodHeaderOf(sqInt methodObj);
extern sqInt noShiftCompactClassIndexOf(sqInt oop);
extern sqInt nullHeaderForMachineCodeMethod(void);
extern sqInt receiverTagBitsForMethod(sqInt aMethodObj);
extern usqInt scavengeThresholdAddress(void);
extern sqInt smallIntegerTag(void);
extern sqInt withoutForwardingOnandwithsendToCogit(sqInt obj1, sqInt obj2, sqInt aBool, sqInt (*selector)(sqInt,sqInt,sqInt));
extern usqInt youngStartAddress(void);
static sqInt NoDbgRegParms addressCouldBeObjWhileForwarding(sqInt address);
extern sqInt addressCouldBeObj(sqInt address);
static sqInt NoDbgRegParms adjustAllOopsBy(sqInt bytesToShift);
static sqInt NoDbgRegParms allInstancesOf(sqInt aBehavior);
static sqInt allObjectsUnmarked(void);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern sqInt characterValueOf(sqInt oop);
static sqInt checkHeapIntegrity(void);
extern sqInt checkOkayOop(usqInt oop);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
extern sqInt clone(sqInt obj);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
static sqInt NoDbgRegParms eeInstantiateAndInitializeClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
extern sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms eeInstantiateMethodContextSlots(sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt oop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern void fullGC(void);
static sqInt NoDbgRegParms fwdTableInit(sqInt blkSize);
static sqInt NoDbgRegParms fwdTableSize(sqInt blkSize);
static usqInt imageSegmentVersion(void);
static sqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static sqInt NoDbgRegParms incCompMove(sqInt bytesFreed);
extern void incrementalGC(void);
static void NoDbgRegParms initializeMemoryFirstFree(sqInt firstFree);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
extern sqInt isYoungObject(sqInt obj);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckNewSpaceGC(void);
extern sqInt literalCountOfMethodHeader(sqInt methodHeader);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintReferencesTo(sqInt anOop);
static void NoDbgRegParms mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms markPhase(sqInt fullGCFlag);
extern sqInt objectAfter(sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
static sqInt NoDbgRegParms oopHasAcceptableClass(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
extern void printActivationsOf(sqInt aMethodObj);
extern void printContextReferencesTo(sqInt anOop);
extern void printMemory(void);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printWronglySizedContexts(sqInt printContexts);
static void NoDbgRegParms restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static sqInt NoDbgRegParms safeObjectAfter(sqInt oop);
static sqInt NoDbgRegParms safePrintStringOf(sqInt oop);
extern sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots);
static sqInt NoDbgRegParms sizeBitsOfSafe(sqInt oop);
static sqInt NoDbgRegParms sizeBitsOf(sqInt oop);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt minFree);
static sqInt NoDbgRegParms sufficientSpaceToAllocate(sqInt bytes);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
extern void unpinObject(sqInt objOop);
static void verifyCleanHeaders(void);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt allObjects(void);
static sqInt NoDbgRegParms allYoungand(sqInt array1, sqInt array2);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms badContextSize(sqInt oop);
extern sqInt becomewith(sqInt array1, sqInt array2);
extern void beRootIfOld(sqInt oop);
static void NoDbgRegParms beRootWhileForwarding(sqInt oop);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned int byteSwapped32IfBigEndian(unsigned int w);
extern unsigned long long byteSwapped64IfBigEndian(unsigned long long w);
extern sqInt byteSwapped(sqInt w);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern sqInt characterTable(void);
extern sqInt checkedLongAt(sqInt byteAddress);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classHeader(sqInt oop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classUnsafeAlien(void);
static void clearRootsTable(void);
extern sqInt compactClassAt(sqInt ccIndex);
extern sqInt compactClassIndexOfClass(sqInt classObj);
extern sqInt compactClassIndexOfHeader(sqInt header);
extern sqInt compactClassIndexOf(sqInt oop);
static sqInt NoDbgRegParms compactIndexOfClass(sqInt aClassOop);
static sqInt NoDbgRegParms containOnlyOops(sqInt array);
static sqInt NoDbgRegParms containOnlyOopsand(sqInt array1, sqInt array2);
extern sqInt displayObject(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqLong NoDbgRegParms fetchLong64ofObject(sqInt longIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static void NoDbgRegParms finalizeReference(usqInt oop);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt oop);
extern void * firstIndexableField(sqInt oop);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms followForwarded(sqInt objOop);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOfHeader(sqInt header);
static sqInt NoDbgRegParms fwdBlockValid(sqInt addr);
#if PharoVM
static float getHeapGrowthToSizeGCRatio(void);
#endif /* PharoVM */
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms hasForwardingBlock(sqInt objOop);
static sqInt hasSixtyFourBitImmediates(void);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
static sqInt NoDbgRegParms headerWhileForwardingOf(sqInt oop);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt objectPointer);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
static sqInt NoDbgRegParms isCompiledMethodHeader(sqInt objHeader);
extern sqInt isCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
extern sqInt isImmediate(sqInt anOop);
extern sqInt isIndexable(sqInt oop);
extern sqInt isInMemory(sqInt address);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt oop);
extern sqInt isNonImmediate(sqInt anOop);
extern sqInt isNonIntegerObject(sqInt objectPointer);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop);
extern sqInt isOopCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt anOop);
extern sqInt isOopMutable(sqInt anOop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
static sqInt NoDbgRegParms isSemaphoreOop(sqInt anOop);
static sqInt NoDbgRegParms isWeakNonImm(sqInt oop);
extern sqInt isWeak(sqInt oop);
static sqInt NoDbgRegParms isWordsOrBytesNonImm(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
static sqInt NoDbgRegParms isYoungRoot(sqInt oop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt oop);
static sqInt NoDbgRegParms lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
extern sqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
static sqInt NoDbgRegParms lowestFreeAfter(sqInt chunk);
extern sqInt markAndTrace(sqInt oop);
extern sqInt maybeSplObj(sqInt index);
extern sqInt minSlotsForShortening(void);
extern sqInt nilObject(void);
static sqInt NoDbgRegParms noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt noShiftCompactClassIndexOfHeader(sqInt header);
extern sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
extern sqInt numSlotsOf(sqInt obj);
extern sqInt objectBefore(sqInt address);
extern sqInt objectExactlyBefore(sqInt oop);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms oopFromChunk(sqInt chunk);
static sqInt NoDbgRegParms oopHasOkayClass(sqInt signedOop);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
extern sqInt primitiveErrorTable(void);
extern void printInstancesOf(sqInt aClassOop);
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms remapObj(sqInt obj);
extern sqInt remap(sqInt oop);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static sqInt NoDbgRegParms removeYoungRoot(sqInt obj);
extern sqInt shouldRemapObj(sqInt oop);
extern sqInt shouldRemapOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
EXPORT(sqInt) statNumGCs(void);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
extern void tenuringIncrementalGC(void);
extern sqInt topRemappableOop(void);
extern sqInt trueObject(void);
static void NoDbgRegParms updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
extern sqInt vmEndianness(void);
extern sqInt activeProcess(void);
extern void addIdleUsecs(sqInt idleUsecs);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidStackLimits(sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt NoDbgRegParms checkStackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms checkStackPointerIndexForFrame(char *theFP);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copiedValueCountOfFullClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
extern sqInt disownVM(sqInt flags);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
static sqInt NoDbgRegParms encodeFrameFieldHasContextisBlocknumArgs(sqInt hasContext, sqInt isBlock, sqInt numArgs);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static char * NoDbgRegParms establishFrameForContextToReturnTo(sqInt contextToReturnTo);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
extern sqInt findSelectorOfMethod(sqInt meth);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findUnwindThroughContext(sqInt homeContext);
extern double floatArg(sqInt index);
static void NoDbgRegParms flushMethodCacheForMethod(sqInt oldMethod);
extern sqInt forceInterruptCheck(void);
static sqInt NoDbgRegParms frameContext(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms frameStackedReceiverOffsetNumArgs(sqInt numArgs);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP);
static sqInt NoDbgRegParms frameStackedReceivernumArgs(char *theFP, sqInt numArgs);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
static sqInt NoDbgRegParms getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static void NeverInline handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern usqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
extern sqInt integerArg(sqInt index);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt NoDbgRegParms isNullExternalPrimitiveCall(sqInt aMethodObj);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isStillMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms isVanillaBlockClosure(sqInt aClosure);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt NoDbgRegParms lookupMNUInClass(sqInt class);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static void NoDbgRegParms makeContextSnapshotSafe(sqInt ctxt);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static sqInt NoDbgRegParms markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceInterpreterOops(sqInt fullGCFlag);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms methodHeaderHasPrimitive(sqInt methodHeader);
static sqInt NoDbgRegParms methodHeaderIndicatesLargeFrame(sqInt methodHeader);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms NeverInline noInlineSigned32BitIntegerGutsFor(sqInt integerValue);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt ownVM(sqInt threadIndexAndFlags);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
static sqInt NoDbgRegParms positiveMachineIntegerFor(usqIntptr_t value);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
static void NoDbgRegParms printDecodeMethodHeaderOop(sqInt methodHeaderOop);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
static void NoDbgRegParms printFrameOopindexat(char *name, sqInt idx, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern void printHexnp(sqInt n);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern sqInt printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(sqInt aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static sqInt NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static sqInt NoDbgRegParms updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt NoDbgRegParms validBCPCinMethod(sqInt thePC, usqInt aMethod);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
static sqInt validStackPageBaseFrames(void);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt wakeHighestPriority(void);
static usqLong NoDbgRegParms wordSwapped(sqInt w);
static sqInt NeverInline writeImageFileIO(void);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static double NoDbgRegParms NeverInline noInlineLoadFloatOrIntFrom(sqInt floatOrInt);
static void primitiveClone(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss char * framePointer;
_iss StackPage * stackPage;
_iss usqInt freeStart;
_iss usqInt method;
_iss sqInt argumentCount;
_iss sqInt nilObj;
_iss usqInt instructionPointer;
_iss usqInt newMethod;
_iss StackPage * pages;
_iss char * stackBasePlus1;
_iss usqInt youngStart;
_iss sqInt messageSelector;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss sqInt bytesPerPage;
_iss sqInt traceLogIndex;
_iss sqInt remapBufferCount;
_iss usqInt reserveStart;
_iss char * stackLimit;
_iss usqInt memoryLimit;
_iss sqInt rootTableCount;
_iss usqInt endOfMemory;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt scavengeThreshold;
_iss unsigned char primTraceLogIndex;
_iss sqInt numStackPages;
_iss sqInt tempOop;
_iss sqInt needGCFlag;
_iss sqLong nextProfileTick;
_iss sqInt jmpDepth;
_iss sqInt lkupClass;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss usqInt fwdTableNext;
_iss sqInt profileProcess;
_iss sqInt profileSemaphore;
_iss sqInt profileMethod;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt tempOop2;
_iss sqInt statGrowMemory;
_iss sqInt weakRootCount;
_iss sqInt classNameIndex;
_iss sqInt cogCodeSize;
_iss sqInt preemptionYields;
_iss sqInt tempOop3;
_iss sqInt cogCompiledCodeCompactionCalledFor;
_iss sqInt lastCoggableInterpretedBlockMethod;
_iss sqInt lastUncoggableInterpretedBlockMethod;
_iss usqLong nextWakeupUsecs;
_iss sqInt statMarkCount;
_iss sqInt gcMode;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss sqInt metaclassNumSlots;
_iss sqInt rootTableOverflowed;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt edenBytes;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt flagInterpretedMethods;
_iss sqInt lowSpaceThreshold;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt statTenures;
_iss sqInt thisClassIndex;
_iss usqInt fwdTableLast;
_iss usqLong gcStartUsecs;
_iss sqInt newFinalization;
_iss sqInt pendingFinalizationSignals;
_iss sqInt statCompMoveCount;
_iss sqInt statFullGCs;
_iss usqLong statIOProcessEvents;
_iss sqInt statIncrGCs;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt forceTenureFlag;
_iss sqInt imageHeaderFlags;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt signalLowSpace;
_iss usqLong statFullGCUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statNumMaps;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt totalObjectCount;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqInt memory;
_iss sqInt methodDictLinearSearchLimit;
_iss usqLong nextPollUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIdleUsecs;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statPendingFinalizationSignals;
_iss usqLong statProcessSwitch;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt deferSmash;
_iss sqInt deferredSmash;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt savedWindowSize;
_iss sqInt statCodeCompactionCount;
_iss usqLong statCodeCompactionUsecs;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt fullGCLock;
_iss sqInt gcSemaphoreIndex;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt the2ndUnknownShort;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt traceLog[TraceBufferSize /* 768 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt primTraceLog[256];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss usqInt byteCount;
_iss sqInt interruptCheckCounter;
_iss sqInt lastHash;
_iss sqInt lowcodeCalloutState;
_iss char * nativeFramePointer;
_iss char * nativeSP;
_iss char * nativeStackPointer;
_iss sqInt nsMethodCache;
_iss sqInt numExtB;
_iss char * shadowCallStack;
_iss sqInt shadowCallStackPointer;
_iss sqInt theUnknownShort;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt maxLiteralCountForCompile = MaxLiteralCountForCompile /* 60 */;
jmp_buf reenterInterpreter; /* private export */;
sqInt debugCallbackPath;
void * displayBits;
sqInt checkAllocFiller;
sqInt breakSelectorLength = MinSmallInteger;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
int displayWidth;
sqInt extraVMMemory;
sqInt checkForLeaks;
int displayDepth;
sqInt desiredCogCodeSize;
int displayHeight;
char * breakSelector;
usqInt heapBase;
sqInt inIOProcessEvents;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
sqInt breakLookupClassTag;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
sqInt suppressHeartbeatFlag;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
static int (*sHEAFn)() = 0;
static const sqInt headerTypeBytes[] = {
		8, 4, 0, 0
	};
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveVoidVMStateForMethod,
	/* 216 */ primitiveMethodXray,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ primitiveCollectCogCodeConstituents,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
sqInt checkedPluginName;
char expensiveAsserts = 0;
const char *interpreterVersion = "Croquet Closure Cog[SqueakV3] VM [CoInterpreterPrimitives VMMaker.oscog-eem.2250]";
sqInt minBackwardJumpCountForCompile = MinBackwardJumpCountForCompile /* 40 */;
volatile int sendTrace;


/*** Macros ***/
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define compilationBreakpointisMNUCase(sel, len, isMNU) do { \
	if ((len) == (isMNU ? -breakSelectorLength : breakSelectorLength) \
	 && !strncmp((char *)((sel) + BaseHeaderSize), breakSelector, (isMNU ? -breakSelectorLength : breakSelectorLength))) { \
		suppressHeartbeatFlag = 1; \
		compilationBreakpointFor(sel); \
	} \
} while (0)
#define enterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define getCodeCompactionCount() integerObjectOf(GIV(statCodeCompactionCount))
#define getCodeCompactionMSecs() integerObjectOf((GIV(statCodeCompactionUsecs) + 500) / 1000)
#define getCogCodeSize() integerObjectOf(GIV(cogCodeSize))
#define getDesiredCogCodeSize() integerObjectOf(desiredCogCodeSize)
#define heapBase() heapBase
#define initialEnterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define mnuCompilationBreakpoint(sel, len) do { \
	if ((len) == -breakSelectorLength \
	 && !strncmp((char *)((sel) + BaseHeaderSize), breakSelector, -breakSelectorLength)) { \
		suppressHeartbeatFlag = 1; \
		compilationBreakpointFor(sel); \
	} \
} while (0)
#define primNumberExternalCall() 117
#define primTraceLogIndex(aValue) (GIV(primTraceLogIndex) = (aValue))
#define pageIndexForstackBasePlus1bytesPerPage(pointer,stkBasePlus1,pageByteSize) (((char *)(pointer) - (stkBasePlus1)) / (pageByteSize))
#define startOfMemory() heapBase
#define classFieldOffset() (0 - BaseHeaderSize)
#define compactClassFieldWidth() 5
#define freeStart() GIV(freeStart)
#define instFormatFieldLSB() 8
#define instFormatFieldWidth() 4
#define youngStart() GIV(youngStart)
#define compactClassFieldLSB() 12
#define firstByteFormat() 8
#define firstCompiledMethodFormat() 12
#define firstLongFormat() 6
#define indexablePointersFormat() 3
#define isForwarded(oop) false
#define memory() GIV(memory)
#define remapBufferCount() GIV(remapBufferCount)
#define shiftForWord() 2
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt lkupClassTag;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    usqIntptr_t stackPagesBytes;
    char *theStackMemory;

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		sqMakeMemoryNotExecutableFromTo(((usqInt)(startOfMemory())), ((usqInt)GIV(memoryLimit)));
		sqMakeMemoryNotExecutableFromTo(((usqInt)theStackMemory), (((usqInt)theStackMemory)) + stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		assert((minimumUnusedHeadroom()) == stackPageBytes);
		loadInitialContext();
		ioInitHeartbeat();
		initialEnterSmalltalkExecutive();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	/* begin fetchByte */
	currentBytecode = byteAtPointer(++localIP);

	/* begin initExtensions */
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 4 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 12 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 20 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 28 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 36 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 44 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 52 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 60 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 1 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 2 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 3 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 4 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 5 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 6 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 7 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 8 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 9 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 10 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 11 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 12 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 13 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 14 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 15 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 16 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 17 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 18 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 19 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 20 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 21 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 22 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 23 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 24 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 25 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 26 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 27 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 28 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 29 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 30 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0x1F /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				/* begin receiver */
				rcvr = longAt(localFP + FoxIFReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord())))), top);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin itemporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
			/* pushReceiverBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAt(localFP + FoxIFReceiver);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(trueObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(falseObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(nilObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxIFReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				sqInt aMethodObj;
				sqInt callerContextOrNil;
				sqInt callerContextOrNil1;
				sqInt callerContextOrNil2;
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt senderOop;
				sqInt senderOop1;
				char *theFP;
				char *theFP1;
				char *theFP2;
				StackPage *thePage;
				StackPage *thePage1;
				StackPage *thePage2;
				StackPage *thePage3;
				sqInt unwindContextOrNilOrZero;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxIFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l305;
				}
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */
				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					closure = longAt((home + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				unwindContextOrNilOrZero = findUnwindThroughContext(home);
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if (((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l308;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l308:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l305;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if (((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l324;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l324:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l305;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);

					if ((longAt(theFP + FoxSavedFP)) == 0) {
						/* begin frameCallerContext: */
						assert(isBaseFrame(theFP));
						/* begin stackPageFor: */
						thePage1 = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
						pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
						callerContextOrNil = longAt((thePage1->baseAddress));
						assert(addressCouldBeObj(callerContextOrNil));
						assert((callerContextOrNil == (nilObject()))
						 || (isContext(callerContextOrNil)));
						contextToReturnTo = callerContextOrNil;
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop1 & 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);

						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if (((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
							? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l319;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l319:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l305;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				newPage = stackPageAtpages((assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
				if (newPage != GIV(stackPage)) {
					/* begin frameCallerContext: */
					theFP2 = (GIV(stackPage)->baseFP);
					assert(isBaseFrame(theFP2));
					/* begin stackPageFor: */
					thePage3 = stackPageAtpages((assert((((((char *) theFP2)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP2)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP2, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
					callerContextOrNil2 = longAt((thePage3->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil2));
					assert((callerContextOrNil2 == (nilObject()))
					 || (isContext(callerContextOrNil2)));
					currentCtx = callerContextOrNil2;
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
							/* begin stackPageFor: */
							thePage = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							assert(isBaseFrame(theFP1));
							/* begin stackPageFor: */
							thePage2 = stackPageAtpages((assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
							callerContextOrNil1 = longAt((thePage2->baseAddress));
							assert(addressCouldBeObj(callerContextOrNil1));
							assert((callerContextOrNil1 == (nilObject()))
							 || (isContext(callerContextOrNil1)));
							currentCtx = callerContextOrNil1;
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer1 = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((assert(!(isBaseFrame(callerFP))),
(callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin maybeReturnToMachineCodeFrame */
				if ((((usqInt)localIP)) < (startOfMemory())) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {

						/* localIP in the cog method zone indicates a return to machine code. */
						/* begin returnToMachineCodeFrame */
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
						longAtPointerput(localSP, localIP);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin externalizeFPandSP */
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						ceEnterCogCodePopReceiverReg();
						goto l312;
					}
					localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
				}
			l312:	/* end maybeReturnToMachineCodeFrame */;
				/* begin setMethod: */
				aMethodObj = longAt(localFP + FoxMethod);
				assert((((usqInt)aMethodObj)) >= (startOfMemory()));
				GIV(method) = aMethodObj;
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l305:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				/* begin trueObject */
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				/* begin falseObject */
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
			/* returnNil */
			{
				VM_LABEL(returnNil);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				sqInt aMethodObj;
				sqInt aMethodObj1;
				sqInt callerContextOrNil;
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnFrom;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				StackPage *lruOrFree;
				StackPage *newPage;
				sqInt retToContext;
				sqInt senderOop;
				char *sp;
				char *sp1;
				char *sp2;
				char *theFP;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				
				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					assert(isBaseFrame(localFP));
					/* begin stackPageFor: */
					thePage1 = stackPageAtpages((assert((((((char *) localFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) localFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(localFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
					callerContextOrNil = longAt((thePage1->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil));
					assert((callerContextOrNil == (nilObject()))
					 || (isContext(callerContextOrNil)));
					contextToReturnTo = callerContextOrNil;
					freeStackPageNoAssert(GIV(stackPage));
					retToContext = ((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
					if (retToContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1);

						/* begin stackPageFor: */
						thePage = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
						pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l334;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l334;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l334:	/* end findFrameAbove:inPage: */;
							/* begin newStackPage */
							lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
							if (((lruOrFree->baseFP)) == 0) {
								newPage = lruOrFree;
								goto l331;
							}
							divorceFramesIn(lruOrFree);
							newPage = lruOrFree;
						l331:	/* end newStackPage */;
							assert(newPage == GIV(stackPage));
							moveFramesInthroughtoPage(thePage, frameAbove, newPage);
							markStackPageMostRecentlyUsed(newPage);
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(retToContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
							contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
							tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, localReturnValue);
							/* begin externalCannotReturn:from: */
							longAtput((sp = GIV(stackPointer) - BytesPerWord), contextToReturnFrom);
							GIV(stackPointer) = sp;
							/* begin push: */
							longAtput((sp1 = GIV(stackPointer) - BytesPerWord), localReturnValue);
							GIV(stackPointer) = sp1;
							/* begin push: */
							longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
							GIV(stackPointer) = sp2;
							ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), contextToReturnFrom, 1);
							goto l326;
						}
						GIV(instructionPointer) = 0;
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					localIP = pointerForOop(longAtPointer(localSP));
					if ((((usqInt)localIP)) < (startOfMemory())) {
						if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {

							/* localIP in the cog method zone indicates a return to machine code. */
							/* begin returnToMachineCodeFrame */
							assertCStackWellAligned();
							assert((((usqInt)localIP)) < (startOfMemory()));
							assert(isMachineCodeFrame(localFP));
							assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
							longAtPointerput(localSP, localIP);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							/* begin externalizeFPandSP */
							assert((localSP < ((GIV(stackPage)->baseAddress)))
							 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							ceEnterCogCodePopReceiverReg();
							goto l326;
						}
						localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
					}
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin setMethod: */
					aMethodObj = longAt(localFP + FoxMethod);
					assert((((usqInt)aMethodObj)) >= (startOfMemory()));
					GIV(method) = aMethodObj;
					assert(isOopCompiledMethod(GIV(method)));
					longAtPointerput(localSP, localReturnValue);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l326;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + (frameStackedReceiverOffsetNumArgs(((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
	? ((mframeCogMethod(localFP))->cmNumArgs)
	: byteAt((localFP + FoxIFrameFlags) + 1))));
				localFP = callersFPOrNull;
				if ((((usqInt)localIP)) < (startOfMemory())) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {

						/* localIP in the cog method zone indicates a return to machine code. */
						/* begin returnToMachineCodeFrame */
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
						longAtPointerput(localSP, localIP);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin externalizeFPandSP */
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						ceEnterCogCodePopReceiverReg();
						goto l326;
					}
					localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
				}
				/* begin setMethod: */
				aMethodObj1 = longAt(localFP + FoxMethod);
				assert((((usqInt)aMethodObj1)) >= (startOfMemory()));
				GIV(method) = aMethodObj1;
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l326:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;
				char *theFP;
				char *theSP;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (lengthOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				theFP = localFP;
				theSP = localSP;
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					ourContext = longAt(theFP + FoxThisContext);
					goto l335;
				}
				ourContext = marryFrameSP(theFP, theSP);
			l335:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object2;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					object1 = longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l32;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l32;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object2 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l32;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object11 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object11);

					goto l32;
				}
			}
		l32:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxIFReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxIFReceiver), value);
					}
					longAtput(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l39;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				error("illegal store");
			l39:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;

				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxIFReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxIFReceiver), value);
					}
					longAtput(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l46;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				error("illegal store");
			l46:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(normalSend);
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					usqInt aMethodObj;
					sqInt aValue;
					CogMethod *cogMethod;
					sqInt errorCode;
					sqInt hash;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt methodHeader2;
					sqInt nArgs;
					sqInt numTemps;
					sqInt object;
					sqInt ok;
					sqInt probe;
					sqInt rcvr;
					char *savedFramePointer;
					char *savedStackPointer;
					sqInt selector;
					sqInt succeeded;
					sqInt switched;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					nArgs = 0;
					savedFramePointer = 0;
					savedStackPointer = 0;
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					if (recordSendTrace()) {
						/* begin recordTrace:thing:source: */
						GIV(traceLog)[GIV(traceLogIndex)] = lkupClassTag;
						GIV(traceLog)[GIV(traceLogIndex) + 1] = GIV(messageSelector);
						GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
						GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
						if (printOnTrace()) {
							printActivationNameForSelectorstartClass(GIV(messageSelector), lkupClassTag);
							/* begin cr */
							printf("\n");
						}
					}
					/* begin internalFindNewMethodOrdinary */
					hash = GIV(messageSelector) ^ lkupClassTag;

					/* first probe */
					probe = hash & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l351;
					}

					/* second probe */
					probe = (((usqInt) hash) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l351;
					}
					probe = (((usqInt) hash) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l351;
					}
					ok = 0;
				l351:	/* end inlineLookupInMethodCacheSel:classTag: */;
					if (ok) {
						/* begin ifAppropriateCompileToNativeCode:selector: */
						aMethodObj = GIV(newMethod);
						selector = GIV(messageSelector);
						methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
						if ((assert(((methodHeader & 1))
							 || (((((usqInt)methodHeader)) < (startOfMemory()))
							 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
						(methodHeader & 1) == 0)) {

							/* makeBaseFrame: can create cog methods with nil selectors. */
							cogMethod = ((CogMethod *) methodHeader);
							if (((cogMethod->selector)) == GIV(nilObj)) {
								setSelectorOfto(cogMethod, selector);
							}
						}
						else {
							if (((assert((methodHeader & 1)),
							((((int) methodHeader)) < 0
									? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
									: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
								cogselector(aMethodObj, selector);
							}
							else {
								maybeFlagMethodAsInterpreted(aMethodObj);
							}
						}
					}
					else {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						GIV(lkupClass) = lkupClassTag;
						assert((GIV(lkupClass) != null)
						 && (addressCouldBeClassObj(GIV(lkupClass))));
						lookupMethodInClass(GIV(lkupClass));

						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						addNewMethodToCache(GIV(lkupClass));
					}
				l340:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								aValue = longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
								longAtPointerput(localSP, aValue);
								goto l354;
							}
							if (localPrimIndex == 256) {
								goto l354;
							}
							if (localPrimIndex == 257) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l354;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l354;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l354;
							}
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 1) | 1));
							goto l354;
						}
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						if (recordPrimTrace()) {
							/* begin fastLogPrim: */
							GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
							primTraceLogIndex(GIV(primTraceLogIndex) + 1);
						}
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						nArgs = GIV(argumentCount);
						savedStackPointer = GIV(stackPointer);
						savedFramePointer = GIV(framePointer);

						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
						/* begin maybeRetryPrimitiveOnFailure */
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if ((!GIV(primFailCode))
						 && ((GIV(framePointer) == savedFramePointer)
						 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {

							/* Don't fail if primitive has done something radical, e.g. perform: */
							if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
								flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
								failUnbalancedPrimitive();
								GIV(stackPointer) = savedStackPointer;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						succeeded = !GIV(primFailCode);
						if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
							/* begin iframeSavedIP: */
							GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
						}
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							returntoExecutive(popStack(), 1);
							browserPluginReturnIfNeeded();
							goto l354;
						}
					}
					if ((assert(isNonImmediate(GIV(newMethod))),
					isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) {
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(localFP)));
						longAtput(localFP + FoxIFSavedIP, ((sqInt)localIP));
						GIV(instructionPointer) = ceReturnToInterpreterPC();
						/* begin externalizeFPandSP */
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						activateCoggedNewMethod(1);
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
											}
					else {
						/* begin internalActivateNewMethod */
						methodHeader2 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
						assert(!(isCogMethodReference(methodHeader2)));
						numTemps = (((usqInt) methodHeader2) >> MethodHeaderTempCountShift) & 0x3F;
						assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader2)));

						/* could new rcvr be set at point of send? */
						rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
						assert(!(isOopForwarded(rcvr)));
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localIP);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localFP);
						localFP = localSP;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
						/* begin setMethod:methodHeader: */
						GIV(method) = GIV(newMethod);
						assert(isOopCompiledMethod(GIV(method)));
						assert((methodHeaderOf(GIV(method))) == methodHeader2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
						/* begin internalPush: */
						object = (VMBIGENDIAN
							? ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader2) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
							: ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader2) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
						longAtPointerput((localSP -= BytesPerOop), object);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), 0);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), rcvr);
						for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
						}
						localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader2 & 1)),
((((int) methodHeader2)) < 0
		? ((methodHeader2 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader2) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1);
						if (methodHeader2 & V3PrimitiveBitsMask) {

							/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
							   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
							localIP += 0;
							if (GIV(primFailCode) != 0) {
								if ((byteAt(localIP + 1)) == (LongStoreBytecode)) {
									/* begin getErrorObjectFromPrimFailCode */
									if (GIV(primFailCode) > 0) {
										/* begin splObj: */
										table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
										if (GIV(primFailCode) <= (numSlotsOf(table))) {
											errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
											goto l352;
										}
									}
									errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
								l352:	/* end getErrorObjectFromPrimFailCode */;
									longAtPointerput(localSP, errorCode);
								}
								GIV(primFailCode) = 0;
							}
						}
						assert((frameNumArgs(localFP)) == GIV(argumentCount));
						assert(!(frameIsBlockActivation(localFP)));
						assert(!(frameHasContext(localFP)));
						if (localSP < GIV(stackLimit)) {
							/* begin externalizeIPandSP */
							assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2));
							returnToExecutivepostContextSwitch(1, switched);
							/* begin internalizeIPandSP */
							assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
							localIP = pointerForOop(GIV(instructionPointer));
							localSP = pointerForOop(GIV(stackPointer));
							localFP = pointerForOop(GIV(framePointer));
													}
					}
				l354:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				sqInt callerContextOrNil;
				char *callerFP;
				sqInt litVar1;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object3;
				int onCurrentPage;
				sqInt opType;
				sqInt result;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage *thePage;
				StackPage * thePage1;
				sqInt thePC;
				sqInt thePC1;
				sqInt top;
				sqInt value;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l55;
				}
				if (opType == 1) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l55;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushMaybeContextReceiverVariable: */
					obj = longAt(localFP + FoxIFReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (!(((longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
							value = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							if ((byte3 == InstructionPointerIndex)
							 && (((value & 1))
							 && ((((int) value)) < 0))) {
								/* begin internalMustMapMachineCodePC:context: */
								assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								result = mustMapMachineCodePCcontext((value >> 1), obj);
								/* begin internalizeIPandSP */
								assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
								localIP = pointerForOop(GIV(instructionPointer));
								localSP = pointerForOop(GIV(stackPointer));
								localFP = pointerForOop(GIV(framePointer));
								value = result;
							}
							object3 = value;
							goto l57;
						}
						if (isWidowedContext(obj)) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l57;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						spouseFP = pointerForOop(senderOop - 1);

						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								/* begin frameCallerContext: */
								assert(isBaseFrame(spouseFP));
								/* begin stackPageFor: */
								thePage = stackPageAtpages((assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
								pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
								callerContextOrNil = longAt((thePage->baseAddress));
								assert(addressCouldBeObj(callerContextOrNil));
								assert((callerContextOrNil == (nilObject()))
								 || (isContext(callerContextOrNil)));
								object3 = callerContextOrNil;
								goto l57;
							}
							/* begin ensureFrameIsMarried:SP: */
							if (((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
								? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
								: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
								assert(isContext(frameContext(callerFP)));
								object3 = longAt(callerFP + FoxThisContext);
								goto l57;
							}
							object3 = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP))),
							(spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord));
							goto l57;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object3 = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l57;
						}
						if (byte3 == InstructionPointerIndex) {
							object3 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l57;
						}
						error("bad index");
						object3 = 0;
					l57:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object3);
					}
					else {
						/* begin internalPush: */
						object11 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
						longAtPointerput((localSP -= BytesPerOop), object11);
					}
					goto l55;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object);
					goto l55;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object1);

					goto l55;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar1, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar1, top);
					}
					longAtput((litVar1 + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), top);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l55;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj1 = longAt(localFP + FoxIFReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt) (longAt(obj1))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
				 && ((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 || ((byte3 == MethodIndex)
				 && (((((int) ((thePC = longAt((top + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
				 && ((thePC & 1))))))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1));
					assert(!((isObjImmutable(obj1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && (!(isWidowedContext(obj1))))) {
						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(obj1, GIV(youngStart))) {
							possibleRootStoreIntovalue(obj1, top);
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
						if (byte3 == StackPointerIndex) {
							ensureContextIsExecutionSafeAfterAssignToStackPointer(obj1);
						}
						goto l61;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop1 & 1));
					theFP = pointerForOop(senderOop1 - 1);

					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						thePage1 = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
						pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage1 == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l61;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1);
					if ((byte3 == MethodIndex)
					 && (((((int) ((thePC1 = longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
					 && ((thePC1 & 1)))) {
						ensureContextHasBytecodePC(obj1);
					}
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
					if (byte3 == StackPointerIndex) {
						ensureContextIsExecutionSafeAfterAssignToStackPointer(obj1);
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l61:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
				}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
		l55:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;
				sqInt offset;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				offset = (literalCountOfMethodHeader(methodHeaderOf(GIV(method)))) - 1;
				literal = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				if ((literal != GIV(nilObj))
				 && (((literal & 1) == 0)
				 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))) {

					/* filters out fullBlock last literal */
					assert((numSlotsOf(literal)) > ValueIndex);
					classPointer = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
				}
				else {
					/* begin nilObject */
					classPointer = GIV(nilObj);
				}
				superclass = longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				/* begin classTagForClass: */
				lkupClassTag = superclass;
				/* begin ensureReceiverUnforwarded */
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;
				char *theFP;
				char *theSP;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				theFP = localFP;
				theSP = localSP;
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					ourContext = longAt(theFP + FoxThisContext);
					goto l86;
				}
				ourContext = marryFrameSP(theFP, theSP);
			l86:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, 2, size);

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 140:
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord()))))));
			}
			break;
		case 141:
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			break;
		case 142:
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt newClosure;
				sqInt newClosure1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				char *theFP;
				char *theSP;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				/* begin fetchByte */
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				theFP = localFP;
				theSP = localSP + (numCopied * BytesPerOop);
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					context = longAt(theFP + FoxThisContext);
					goto l104;
				}
				context = marryFrameSP(theFP, theSP);
			l104:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
				newClosure = newClosure1;
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
					GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 145:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 146:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 147:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 148:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 149:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 150:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 151:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l112;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l112:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt backwardJumpCountByte;
				sqInt offset;
				sqInt switched;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if (offset >= 0) {
					goto l115;
				}
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					switched = checkForEventsMayContextSwitch(1);
					returnToExecutivepostContextSwitch(1, switched);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (switched) {
						goto l115;
					}
				}
				backwardJumpCountByte = byteAt(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)));
				if (((backwardJumpCountByte -= 2)) == 1) {
					if (methodWithHeaderShouldBeCogged(methodHeaderOf(GIV(method)))) {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						attemptToSwitchToMachineCode(((((oopForPointer(localIP)) - offset) - GIV(method)) - BaseHeaderSize) - 1);
					}
					backwardJumpCountByte = 0x7F;
				}
				else {
					if (backwardJumpCountByte == -1) {

						/* initialize the count */
						assert(minBackwardJumpCountForCompile <= 128);
						backwardJumpCountByte = (((sqInt)((usqInt)((minBackwardJumpCountForCompile - 1)) << 1))) + 1;
					}
				}
				/* begin iframeBackwardBranchByte:put: */
				byteAtput(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)), backwardJumpCountByte);
			l115:	/* end ifBackwardsCheckForEvents: */;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l118;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l118:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l122;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l122:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l124;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l125;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l128;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l128;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l128;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l128:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l125;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l125:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l129;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l132;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l132;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l132;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l132:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l129;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l129:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l124;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l124:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l134;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l135;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l138;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l138;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l138;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l138:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l135;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l135:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l139;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l142;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l142;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l142;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l142:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l139;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l139:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l134;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((1 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l134:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l144;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l147;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l152;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l152;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l152;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l152:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l147;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l147:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l150;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l146;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l146;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l146;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l146:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l150;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l150:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l144;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((2 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l144:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l360;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l360;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);

						goto l360;
					}
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l360:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l153;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l156;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l161;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l161;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l161;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l161:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l156;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l156:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l159;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l155;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l155;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l155;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l155:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l159;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l159:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l153;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((3 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l153:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l363;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l363;
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l363:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l162;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l165;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l170;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l170;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l170;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l170:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l165;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l165:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l168;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l164;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l164;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l164;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l164:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l168;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l168:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l162;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((4 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l162:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l171;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l174;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l179;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l179;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l179;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l179:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l174;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l174:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l177;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l173;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l173;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l173;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l173:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l177;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l177:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l171;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((5 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l171:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l180;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l183;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l188;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l188;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l188;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l188:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l183;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l183:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l186;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l182;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l182;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l182;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l182:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l186;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l186:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l180;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((6 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l180:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l189;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l192;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l197;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l197;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l197;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l197:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l192;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l192:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l195;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l191;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l191;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l191;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l191:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l195;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l195:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l189;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((7 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l189:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt oop1;
				int overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 1) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l198;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l199;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l202;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l202;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l202;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l202:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l199;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l199:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l203;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l206;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l206;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l206;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l206:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l203;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l203:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l198;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((8 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l198:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
							/* begin fetchNextBytecode */
							/* begin fetchByte */
							currentBytecode = byteAtPointer(++localIP);

							goto l208;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l209;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l212;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l212;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l212;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l212:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l209;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l209:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l213;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l216;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l216;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l216;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l216:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l213;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l213:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l208;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((9 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l208:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt oop;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l218;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((10 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l218:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt arg;
				sqInt oop;
				sqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((((rcvr & 1))
				 || (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))
				 && (((arg & 1))
				 || (((((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))) {
					pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), pt);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l221;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((11 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l221:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt shifted;
				char *sp;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l227;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 0x1F)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l227;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l227;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-0x1F))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l227;
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if ((((unsigned int) shifted)) <= (MaxSmallInteger)) {
						shifted = (((usqInt)shifted << 1) | 1);
						goto l232;
					}
					newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
					/* begin storeLong32:ofObject:withValue: */
					valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(shifted);
					long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

					shifted = newLargeInteger;
					goto l232;

				l232:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l227:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l226;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((12 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l226:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt oop;
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)quotient << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l234;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((13 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l234:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l237;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l237;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((14 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l237:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l241;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l241;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((15 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l241:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				VM_LABEL(bytecodePrimAt);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)((16 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				VM_LABEL(bytecodePrimAtPut);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)((17 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt fmt;
				sqInt fmt1;
				sqInt header;
				sqInt header1;
				sqInt isArray;
				sqInt isString;
				sqInt oop;
				sqInt rcvr;
				sqInt sz;
				sqInt sz1;
				sqInt sz2;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isString = 0;
					goto l249;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isString = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l249;
				}
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l249;

				isString = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l249:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz1 = header & SizeMask;
					}
					sz1 -= header & Size4Bit;
					if (fmt <= 4) {
						sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
						goto l251;
					}
					sz = (fmt < (firstByteFormat())
						? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
						: (sz1 - BaseHeaderSize) - (fmt & 3));
				l251:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l247;
				}
				/* begin is:instanceOf:compactClassIndex: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isArray = 0;
					goto l252;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isArray = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l252;
				}
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l252;

				isArray = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l252:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf: */
					header1 = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
					if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
						sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz2 = header1 & SizeMask;
					}
					sz2 -= header1 & Size4Bit;
					if (fmt1 <= 4) {
						sz = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
						goto l254;
					}
					sz = (fmt1 < (firstByteFormat())
						? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
						: (sz2 - BaseHeaderSize) - (fmt1 & 3));
				l254:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l247;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((18 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l247:	/* end case */;
			break;
		case 195:
			/* bytecodePrimNext */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((19 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 196:
			/* bytecodePrimNextPut */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((20 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 197:
			/* bytecodePrimAtEnd */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((21 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 198:
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199:
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt ccIndex;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				/* begin internalStackTopPut: */
				if ((rcvr & 1)) {
					/* begin fetchPointer:ofObject: */
					aValue = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						aValue = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						aValue = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			break;
		case 200:
			/* bytecodePrimNotIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l267;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l267;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l267:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l266;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((25 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l266:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l272;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l272;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l272:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l271;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((26 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l271:	/* end case */;
			break;
		case 203:
			/* bytecodePrimDo */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((27 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 204:
			/* bytecodePrimNew */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((28 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205:
			/* bytecodePrimNewWithArg */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((29 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l279;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((30 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l279:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l286;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0x1F * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l286:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 0;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 1;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 2;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		}
	}

	/* undo the pre-increment of IP before returning */
	localIP -= 1;
	/* begin externalizeIPandSP */
	assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}

	/* CogBlockMethod>>#cmHomeMethod */
static CogMethod * NoDbgRegParms
cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod)
{
	return ((CogMethod *) ((((usqInt)self_in_cmHomeMethod)) - ((self_in_cmHomeMethod->homeOffset))));
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin stackPageAt: */
	return stackPageAtpages((assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages)))))),
	pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statNumMaps) == 0
		? 0.0
		: (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps));
}


/*	Activate newMethod when newMethod has been cogged, i.e. create a
	machine-code frame and (re)enter machine-code.
 */

	/* CoInterpreter>>#activateCoggedNewMethod: */
static void NoDbgRegParms
activateCoggedNewMethod(sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt errorCode;
    usqInt i;
    sqInt initialPC;
    sqInt methodHeader;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt offset;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt table;

	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	assert(isCogMethodReference(methodHeader));
	cogMethod = ((CogMethod *) methodHeader);
	methodHeader = (cogMethod->methodHeader);
	/* begin stackValue: */
	offset = (cogMethod->cmNumArgs);
	rcvr = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	if (((cogMethod->stackCheckOffset)) == 0) {

		/* frameless method; nothing to activate... */
		
		/* dont use and: so as to get Slang to inline cogit numRegArgs > 0 */
		if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
			callRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
		}

		/* begin push: */
		object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp1;
		ceCallCogCodePopReceiverReg();
		error("should not be reached");
	}
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), ((sqInt)cogMethod));
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp9;
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = (((cogMethod->cmNumArgs)) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp2;
	}
	if (methodHeader & V3PrimitiveBitsMask) {

		/* Store the error code if the method starts with a long store temp.  No instructionPointer skip because we're heading for machine code. */
		initialPC = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) + (0);
		if (GIV(primFailCode) != 0) {
			if ((byteAt(initialPC)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l5;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l5:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	if (GIV(stackPointer) >= GIV(stackLimit)) {
		assert(((cogMethod->stackCheckOffset)) > (noCheckEntryOffset()));
		/* begin push: */
		object1 = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp4;
		ceEnterCogCodePopReceiverReg();
		error("should not be reached");
	}
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}

	/* CoInterpreter>>#activateNewMethod */
static void
activateNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt header;
    sqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt switched;
    sqInt table;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((header & 1)) {
		methodHeader = header;
	}
	else {
		assert((((usqInt)header)) < (heapBase()));
		assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
		methodHeader = ((((CogMethod *) header))->methodHeader);
	}
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
		}
	}
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp4;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp6;
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp7;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l4;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l4:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	switched = 1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */
/*	Override to refuse to cache other than compiled methods.
	This protects open PICs against having to test for compiled methods. */

	/* CoInterpreter>>#addNewMethodToCache: */
static void NoDbgRegParms
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt header;
    sqInt methodHeader;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;

	if (!(((GIV(newMethod) & 1) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
		return;
	}
	/* begin methodCacheHashOf:with: */
	hash = GIV(messageSelector) ^ classObj;
	if (((GIV(newMethod) & 1) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod)));
		header = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((header & 1)) {
			methodHeader = header;
		}
		else {
			assert((((usqInt)header)) < (heapBase()));
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
			methodHeader = ((((CogMethod *) header))->methodHeader);
		}
		primBits = (methodHeader >> 1);
		primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
		 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = classObj;
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = classObj;
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}

	/* CoInterpreter>>#argumentCountAddress */
usqInt
argumentCountAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(argumentCount))));
}


/*	Coerce either a CMMethod or a CMBlock to the home CMMethod */

	/* CoInterpreter>>#asCogHomeMethod: */
static CogMethod * NoDbgRegParms
asCogHomeMethod(CogBlockMethod *aCogMethod)
{
	return (((aCogMethod->cmType)) == CMMethod
		? ((CogMethod *) aCogMethod)
		: ((CogMethod *) ((((usqInt)aCogMethod)) - ((aCogMethod->homeOffset)))));
}

	/* CoInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static void NoDbgRegParms
assertValidExecutionPointersimbarline(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt methodField;
    sqInt methodField1;
    usqInt theIP;

	assertl(GIV(stackPage) == (mostRecentlyUsedPage()), ln);
	assertl(addressIsInPage(GIV(stackPage), lifp), ln);
	assert(deferStackLimitSmashAroundwith(assertValidStackLimits, ln));
	assertl(lisp < lifp, ln);
	assertl(lifp > lisp, ln);
	assertl(lisp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl(((lifp - lisp) / BytesPerOop) < LargeContextSlots, ln);
	methodField = longAt(lifp + FoxMethod);
	if (inInterpreter) {
		assertl(!(isMachineCodeFrame(lifp)), ln);
		assertl(GIV(method) == methodField, ln);
		if (assertal(cheapAddressCouldBeInHeap(methodField), ln)) {
			if (lip == (ceReturnToInterpreterPC())) {
				theIP = longAt(lifp + FoxIFSavedIP);
			}
			else {
				theIP = lip;
			}
			assertl((theIP >= (methodField + (lastPointerOf(methodField))))
			 && (theIP < (((methodField + (numBytesOfBytes(methodField))) + BaseHeaderSize) - 1)), ln);
		}
		assertl((iframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (iframeReceiver(lifp))), ln);
	}
	else {
		assertl(isMachineCodeFrame(lifp), ln);
		if ((assertal((((usqInt)methodField)) >= (minCogMethodAddress()), ln))
		 && (assertal((((usqInt)methodField)) < (maxCogMethodAddress()), ln))) {
			/* begin mframeHomeMethod: */
			methodField1 = longAt(lifp + FoxMethod);
			if ((methodField1 & MFMethodFlagIsBlockFlag) != 0) {
				cogMethod = ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField1 & MFMethodMask))))) - (((((CogBlockMethod *) (methodField1 & MFMethodMask)))->homeOffset))));
				goto l2;
			}
			cogMethod = ((CogMethod *) (methodField1 & MFMethodMask));
		l2:	/* end mframeHomeMethod: */;
			assertl((lip > (methodField + ((mframeIsBlockActivation(lifp)
	? sizeof(CogBlockMethod)
	: sizeof(CogMethod)))))
			 && (lip < (methodField + ((cogMethod->blockSize)))), ln);
		}
		assertl((mframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (mframeReceiver(lifp))), ln);
	}
	if ((longAt(lifp + FoxSavedFP)) == 0) {
		assertl(frameHasContext(lifp), ln);
		assertl((frameContext(lifp)) == (longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)), ln);
	}
}

	/* CoInterpreter>>#assertValidMachineCodeFrame: */
void
assertValidMachineCodeFrame(sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    CogMethod *homeMethod;

	assert(isMachineCodeFrame(GIV(framePointer)));
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	/* begin asCogHomeMethod: */
	homeMethod = (((cogMethod->cmType)) == CMMethod
		? ((CogMethod *) cogMethod)
		: ((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset)))));
	assert((methodFor(cogMethod)) == homeMethod);
	assert((instrPtr > (((sqInt)cogMethod)))
	 && (instrPtr < ((((sqInt)homeMethod)) + ((homeMethod->blockSize)))));
}


/*	Check that the stacked instruction pointers in the given page are correct.
	Checks the interpreter sender/machine code callee contract. */

	/* CoInterpreter>>#assertValidStackedInstructionPointersIn:line: */
static sqInt NoDbgRegParms
assertValidStackedInstructionPointersInline(StackPage *aStackPage, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt methodField;
    usqInt methodObj;
    sqInt prevFrameWasCogged;
    char *theFP;
    usqInt theIP;
    CogMethod *theMethod;

	if (!(assertal(!(isFree(aStackPage)), ln))) {
		return 0;
	}

	/* The top of stack of an inactive page is always the instructionPointer.
	   The top of stack of the active page may be the instructionPointer if it has been pushed,
	   which is indicated by a 0 instructionPointer. */
	prevFrameWasCogged = 0;
	if ((GIV(stackPage) == aStackPage)
	 && (GIV(instructionPointer) != 0)) {
		theIP = GIV(instructionPointer);
		theFP = GIV(framePointer);
	}
	else {
		theIP = ((usqInt)(longAt((aStackPage->headSP))));
		theFP = (aStackPage->headFP);
		if (GIV(stackPage) == aStackPage) {
			assertl(GIV(framePointer) == theFP, ln);
		}
	}
	while (1) {
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			/* begin mframeHomeMethod: */
			methodField = longAt(theFP + FoxMethod);
			if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
				theMethod = ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset))));
				goto l2;
			}
			theMethod = ((CogMethod *) (methodField & MFMethodMask));
		l2:	/* end mframeHomeMethod: */;
			assertl((theIP == (ceCannotResumePC()))
			 || ((theIP >= (((usqInt)theMethod)))
			 && (theIP < ((((usqInt)theMethod)) + ((theMethod->blockSize))))), ln);
			prevFrameWasCogged = 1;
		}
		else {

			/* assert-check the interpreter frame. */
			methodObj = longAt(theFP + FoxMethod);
			if (prevFrameWasCogged) {
				assertl(theIP == (ceReturnToInterpreterPC()), ln);
			}
			if (theIP == (ceReturnToInterpreterPC())) {
				theIP = longAt(theFP + FoxIFSavedIP);
			}
			assertl((theIP >= (methodObj + (lastPointerOf(methodObj))))
			 && (theIP < (((methodObj + (numBytesOfBytes(methodObj))) + BaseHeaderSize) - 1)), ln);
			prevFrameWasCogged = 0;
		}
		theIP = ((usqInt)(longAt(theFP + FoxCallerSavedIP)));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theFP = callerFP;
	}
	assertl(theIP == (ceBaseFrameReturnPC()), ln);
	return 1;
}


/*	Check that the stacked instruction pointers in all pages are correct.
	Checks the interpreter sender/machine code callee contract.
	Written so it will be optimized away if not in an assert VM. */

	/* CoInterpreter>>#assertValidStackedInstructionPointers: */
static void NoDbgRegParms
assertValidStackedInstructionPointers(sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			assertl(assertValidStackedInstructionPointersInline(thePage, ln), ln);
		}
	}
}


/*	Attempt to convert the current interpreted activation into a machine code
	activation, and if this is popssible, jump into machine code. bcpc is the
	0-relative pc of the backward branch bytecode (not any preceding
	extension).  */

	/* CoInterpreter>>#attemptToSwitchToMachineCode: */
static void NoDbgRegParms
attemptToSwitchToMachineCode(sqInt bcpc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCompiledMethodHeader1;
    sqInt closure;
    CogMethod *cogMethod;
    CogBlockMethod *cogMethod1;
    CogBlockMethod *cogMethod2;
    CogMethod *homeMethod;
    sqInt methodField;
    sqInt methodHeader;
    char *p;
    usqInt pc;
    usqInt pc1;
    char *sp;
    char *sp1;
    sqInt startBcpc;
    char *theFP;

	if (!((assert(isNonImmediate(GIV(method))),
		isCogMethodReference(longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		cogselector(GIV(method), GIV(nilObj));

	}
	if ((assert(isNonImmediate(GIV(method))),
	isCogMethodReference(longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) {
		/* begin cogMethodOf: */
		methodHeader = longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		/* begin convertToMachineCodeFrame:bcpc: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		if ((longAt(GIV(framePointer) + FoxSavedFP)) == 0) {
			longAtput(GIV(framePointer) + FoxCallerSavedIP, ceBaseFrameReturnPC());
		}
		else {
			if (!((((usqInt)(longAt((pointerForOop(longAt(GIV(framePointer) + FoxSavedFP))) + FoxMethod)))) < (startOfMemory()))) {
				/* begin iframeSavedIP:put: */
				theFP = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				assert(!(isMachineCodeFrame(theFP)));
				longAtput(theFP + FoxIFSavedIP, ((sqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP)))));
				longAtput(GIV(framePointer) + FoxCallerSavedIP, ceReturnToInterpreterPC());
			}
		}
		if ((byteAt((GIV(framePointer) + FoxIFrameFlags) + 3)) != 0) {
			closure = longAt(GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer))));
			startBcpc = (((longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 1)) - 1;
			cogMethod2 = findMethodForStartBcpcinHomeMethod(startBcpc, cogMethod);

			methodField = (((sqInt)cogMethod2)) + MFMethodFlagIsBlockFlag;
		}
		else {
			/* begin startPCOfMethodHeader: */
			aCompiledMethodHeader1 = (cogMethod->methodHeader);
			startBcpc = (((assert((aCompiledMethodHeader1 & 1)),
((((int) aCompiledMethodHeader1)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((aCompiledMethodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) aCompiledMethodHeader1) >> 10) & 0xFF)))) + LiteralStart) * BytesPerOop;
			cogMethod2 = ((CogBlockMethod *) cogMethod);
			methodField = ((sqInt)cogMethod);
		}
		pc1 = mcPCForBackwardBranchstartBcpcin(bcpc, startBcpc, cogMethod2);
		assert(pc1 > ((((usqInt)cogMethod2)) + (noCheckEntryOffset())));
		assert(bcpc == (bytecodePCForstartBcpcin(pc1, startBcpc, cogMethod2)));
		longAtput(GIV(framePointer) + FoxMethod, methodField + (((byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0
	? MFMethodFlagHasContextFlag
	: 0)));
		for (p = (GIV(framePointer) + FoxIFReceiver); p >= GIV(stackPointer); p += (-BytesPerWord)) {
			longAtput((p + FoxMFReceiver) - FoxIFReceiver, longAt(p));
		}
		GIV(stackPointer) = (GIV(stackPointer) + FoxMFReceiver) - FoxIFReceiver;
		pc = pc1;
		/* begin assertValidMachineCodeFrame: */
		assert(isMachineCodeFrame(GIV(framePointer)));
		/* begin mframeCogMethod: */
		cogMethod1 = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
		/* begin asCogHomeMethod: */
		homeMethod = (((cogMethod1->cmType)) == CMMethod
			? ((CogMethod *) cogMethod1)
			: ((CogMethod *) ((((usqInt)cogMethod1)) - ((cogMethod1->homeOffset)))));
		assert((methodFor(cogMethod1)) == homeMethod);
		assert((pc > (((sqInt)cogMethod1)))
		 && (pc < ((((sqInt)homeMethod)) + ((homeMethod->blockSize)))));
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), pc);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
}


/*	Re-enter the interpreter for executing a callback */

	/* CoInterpreter>>#callbackEnter: */
EXPORT(sqInt)
callbackEnter(sqInt *callbackID)
{   DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT
    volatile int calledFromMachineCode;
    volatile void *currentCFramePointer;
    volatile void *currentCStackPointer;
    volatile sqInt header;
    volatile sqInt header1;
    volatile jmp_buf savedReenterInterpreter;
    volatile sqInt wasInMachineCode;


	/* For now, do not allow a callback unless we're in a primitiveResponse */
	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	assert(GIV(primFailCode) == 0);
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}
	GIV(jmpDepth) += 1;
	wasInMachineCode = (((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory());

	/* Suspend the currently active process */
	calledFromMachineCode = GIV(instructionPointer) <= (startOfMemory());
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	flag("need to debug this properly.  Conceptually it is the right thing to do but it crashes in practice");
	transferTofrom(wakeHighestPriority(), CSCallbackLeave);

	forceInterruptCheck();
	currentCStackPointer = getCStackPointer();
	currentCFramePointer = getCFramePointer();
	memcpy(((void *)savedReenterInterpreter), reenterInterpreter, sizeof(jmp_buf));
	assertCStackWellAligned();
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {

		/* Fill in callbackID */
		callbackID[0] = GIV(jmpDepth);
		enterSmalltalkExecutive();
		assert(0);
	}
	setCStackPointer(currentCStackPointer);
	setCFramePointer(currentCFramePointer);
	memcpy(reenterInterpreter, ((void *) savedReenterInterpreter), sizeof(jmp_buf));
	putToSleepyieldingIf(fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))), GIV(preemptionYields));
	transferTofrom(GIV(suspendedCallbacks)[GIV(jmpDepth)], CSCallbackLeave);

	/* see comment above */
	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	/* begin argumentCountOfMethodHeader: */
	assert(isCompiledMethod(GIV(newMethod)));
	header1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((header1 & 1)) {
		header = header1;
	}
	else {
		assert((((usqInt)header1)) < (heapBase()));
		assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
		header = ((((CogMethod *) header1))->methodHeader);
	}
	GIV(argumentCount) = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	assert(wasInMachineCode == (isMachineCodeFrame(GIV(framePointer))));
	if (calledFromMachineCode) {
		if ((((usqInt)GIV(instructionPointer))) >= (startOfMemory())) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
	}
	else {

		/* Even if the context was flushed to the heap and rebuilt in transferTo:from:
		   above it will remain an interpreted frame because the context's pc would
		   remain a bytecode pc.  So the instructionPointer must also be a bytecode pc. */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		assert(GIV(instructionPointer) > (startOfMemory()));
	}
	assert(GIV(primFailCode) == 0);
	GIV(jmpDepth) -= 1;
	return 1;
}

	/* CoInterpreter>>#callForCogCompiledCodeCompaction */
void
callForCogCompiledCodeCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(cogCompiledCodeCompactionCalledFor) = 1;
	forceInterruptCheck();
}


/*	convert
	rcvr	base
	arg(s)
	retpc	<- sp
	to
	retpc	base
	entrypc
	rcvr
	arg(s)	<- sp
	and then enter at either the checked or the unchecked entry-point. */

	/* CoInterpreter>>#callRegisterArgCogMethod:at:receiver: */
static void NoDbgRegParms
callRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt object1;
    char *sp;
    char *sp1;
    char *sp2;

	assert(((cogMethod->cmNumArgs)) <= (numRegArgs()));
	if (((cogMethod->cmNumArgs)) == 2) {
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), longAt(GIV(stackPointer)));
		/* begin push: */
		object = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer) + (3 * BytesPerWord)));
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceCallCogCodePopReceiverArg1Arg0Regs();
	}
	if (((cogMethod->cmNumArgs)) == 1) {
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), longAt(GIV(stackPointer)));
		/* begin push: */
		object1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceCallCogCodePopReceiverArg0Regs();
	}
	assert(((cogMethod->cmNumArgs)) == 0);
	/* begin stackValue:put: */
	longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer)));
	longAtput(GIV(stackPointer) + (0 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	ceCallCogCodePopReceiverReg();
}


/*	An external call or FFI primitive has failed. Build the frame and
	activate as appropriate. Enter either the interpreter or machine
	code depending on whether aPrimitiveMethod has been or is still
	cogged. Note that we could always interpret but want the efficiency
	of executing machine code if it is available. */

	/* CoInterpreter>>#ceActivateFailingPrimitiveMethod: */
void
ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodHeader;

	assert(GIV(primFailCode) != 0);
	assert(GIV(newMethod) == aPrimitiveMethod);
	methodHeader = longAt((aPrimitiveMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((assert(((methodHeader & 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	(methodHeader & 1) == 0)) {
		activateCoggedNewMethod(0);
	}
	else {
		activateNewMethod();
	}
}


/*	Since the trampoline checks for marriage we should only be here for a
	single frame.
 */

	/* CoInterpreter>>#ceActiveContext */
sqInt
ceActiveContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	return marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
}


/*	Return across a page boundary. The context to return to (which may be
	married) is stored in the first word of the stack. We get here when a
	return instruction jumps
	to the ceBaseFrameReturn: address that is the return pc for base frames. A
	consequence of this is that the current frame is no longer valid since an
	interrupt may have overwritten
	its state as soon as the stack pointer has been cut-back beyond the return
	pc. So to have
	a context to send the cannotReturn: message to we also store the base
	frame's context
	in the second word of the stack page. */

	/* CoInterpreter>>#ceBaseFrameReturn: */
sqInt
ceBaseFrameReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    char *callerFP;
    sqInt contextToReturnFrom;
    sqInt contextToReturnTo;
    char *fp;
    char *frameAbove;
    sqInt isAContext;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt senderOop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    StackPage *thePage;

	assert((stackPageFor(GIV(stackPointer))) == GIV(stackPage));
	assert((mostRecentlyUsedPage()) == GIV(stackPage));
	assertCStackWellAligned();
	assert(GIV(framePointer) == 0);
	assert(GIV(stackPointer) <= (((GIV(stackPage)->baseAddress)) - BytesPerWord));
	assert((((GIV(stackPage)->baseFP)) + (2 * BytesPerWord)) < ((GIV(stackPage)->baseAddress)));
	assert((addressCouldBeObj(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)))
	 && (isContext(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord))));
	contextToReturnTo = longAt((GIV(stackPage)->baseAddress));
	assert(addressCouldBeObj(contextToReturnTo));
	freeStackPageNoAssert(GIV(stackPage));
	isAContext = ((contextToReturnTo & 1) == 0)
	 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
	if (isAContext
	 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(contextToReturnTo))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		GIV(framePointer) = pointerForOop(senderOop - 1);

		/* begin stackPageFor: */
		thePage = stackPageAtpages((assert((((((char *) GIV(framePointer))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) GIV(framePointer))) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(GIV(framePointer), GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
		if (GIV(framePointer) == ((thePage->headFP))) {
			GIV(stackPointer) = (thePage->headSP);
		}
		else {

			/* Returning to some interior frame, presumably because of a sender assignment.
			   Move the frames above to another page (they may be in use, e.g. via coroutining).
			   Make the interior frame the top frame. */
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == GIV(framePointer)) {
				frameAbove = 0;
				goto l2;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == GIV(framePointer)) {
					frameAbove = fp;
					goto l2;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			frameAbove = 0;
		l2:	/* end findFrameAbove:inPage: */;
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l1;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
		l1:	/* end newStackPage */;
			assert(newPage == GIV(stackPage));
			moveFramesInthroughtoPage(thePage, frameAbove, newPage);
			markStackPageMostRecentlyUsed(newPage);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (thePage->headSP);
			GIV(framePointer) = (thePage->headFP);
		}
	}
	else {
		if (!(isAContext
			 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
			contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
			tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, returnValue);
			/* begin externalCannotReturn:from: */
			longAtput((sp3 = GIV(stackPointer) - BytesPerWord), contextToReturnFrom);
			GIV(stackPointer) = sp3;
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), returnValue);
			GIV(stackPointer) = sp1;
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp2;
			return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), contextToReturnFrom, 1);
		}
		GIV(instructionPointer) = 0;
		thePage = makeBaseFrameFor(contextToReturnTo);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	assert((stackPageFor(GIV(framePointer))) == GIV(stackPage));
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp;
		ceEnterCogCodePopReceiverReg();
	}
	GIV(instructionPointer) = longAt(GIV(stackPointer));
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	}
	/* begin setMethod: */
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	longAtPointerput(GIV(stackPointer), returnValue);
	assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}


/*	index is unboxed and 0-based. The call-back expects 1-based value (to
	perform the operation with instVarAt:put:
 */

	/* CoInterpreter>>#ceCannotAssignTo:withIndex:valueToAssign: */
#if IMMUTABILITY
sqInt
ceCannotAssignTowithIndexvalueToAssign(sqInt immutableObject, sqInt index, sqInt valueToAssign)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), immutableObject);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), valueToAssign);
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), (((usqInt)(index + 1) << 1) | 1));
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp3;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAttemptToAssign) << (shiftForWord()))))), immutableObject, 2);
}
#endif /* IMMUTABILITY */


/*	A context that has been returned from, or otherwise has an invalid pc has
	been reentered.
	Until we have a cannotResume: selector, simply resend cannotReturn:. */

	/* CoInterpreter>>#ceCannotResume */
sqInt
ceCannotResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt resultOop;
    char *sp;
    char *sp1;
    char *sp2;

	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameHasContext(GIV(framePointer)));
	resultOop = longAt(GIV(stackPointer));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt(GIV(framePointer) + FoxThisContext));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), resultOop);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object = ceCannotResumePC();
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp2;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), longAt(GIV(framePointer) + FoxThisContext), 1);
}

	/* CoInterpreter>>#ceCheckForInterrupts */
void
ceCheckForInterrupts(void)
{
    sqInt switched;

	switched = checkForEventsMayContextSwitch(1);
	returnToExecutivepostContextSwitch(0, switched);
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil.
	As a courtesy to compileInterpreterPrimitive: map NULL to nilObj. */

	/* CoInterpreter>>#ceCheckProfileTick */
void
ceCheckProfileTick(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(GIV(newMethod))) {
		GIV(newMethod) = GIV(nilObj);
	}
	checkProfileTick(GIV(newMethod));
}

	/* CoInterpreter>>#ceContext:instVar: */
sqInt
ceContextinstVar(sqInt maybeContext, sqInt slotIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt result;
    char *sp;
    sqInt top;

	if (((((usqInt) (longAt(maybeContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		result = externalInstVarofContext(slotIndex, maybeContext);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		result = longAt((maybeContext + BaseHeaderSize) + (((sqInt)((usqInt)(slotIndex) << (shiftForWord())))));
	}
	return result;
}


/*	genStorePop:MaybeContextReceiverVariable: filters out unmarried contexts
	but not arbitrary objects in subclasses. It answers maybeMarriedContext so
	that the StackToRegisterMappingCogit can keep ReceiverResultReg live. */

	/* CoInterpreter>>#ceContext:instVar:value: */
sqInt
ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt top;

	if ((((((usqInt) (longAt(maybeMarriedContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
	 && (((longAt((maybeMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		externalInstVarofContextput(slotIndex, maybeMarriedContext, anOop);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(maybeMarriedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(slotIndex) << (shiftForWord())))), anOop);
	}
	return maybeMarriedContext;
}

	/* CoInterpreter>>#ceInterpretMethodFromPIC:receiver: */
sqInt
ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodHeader;
    CogMethod *pic;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt top;


	/* pop off inner return and locate open or closed PIC */
	pic = ((CogMethod *) ((popStack()) - (interpretOffset())));
	assert((((pic->cmType)) == CMOpenPIC)
	 || (((pic->cmType)) == CMClosedPIC));
	if (((pic->cmType)) == CMOpenPIC) {
		assert(!(methodHasCogMethod(aMethodObj)));
		if (methodShouldBeCogged(aMethodObj)) {
			cogselector(aMethodObj, (pic->selector));
		}
	}
	if ((assert(isNonImmediate(aMethodObj)),
	isCogMethodReference(longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) {
		executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(aMethodObj), rcvr);
	}
	GIV(messageSelector) = (pic->selector);
	GIV(newMethod) = aMethodObj;
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(aMethodObj));
	header = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((header & 1)) {
		methodHeader = header;
	}
	else {
		assert((((usqInt)header)) < (heapBase()));
		assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
		methodHeader = ((((CogMethod *) header))->methodHeader);
	}
	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = (pic->cmNumArgs);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	return interpretMethodFromMachineCode();
}

	/* CoInterpreter>>#ceMNUFromPICMNUMethod:receiver: */
sqInt
ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    CogMethod *cPIC;
    sqInt header;
    sqInt methodHeader;
    sqInt oop;
    sqInt oop1;
    sqInt primBits;
    sqInt primitiveIndex;
    char *sp;
    sqInt top;

	assert(addressCouldBeOop(rcvr));
	assert((aMethodObj == 0)
	 || ((addressCouldBeObj(aMethodObj))
	 && (isOopCompiledMethod(aMethodObj))));
	cPIC = ((CogMethod *) ((popStack()) - (mnuOffset())));
	assert((((cPIC->cmType)) == CMClosedPIC)
	 || (((cPIC->cmType)) == CMOpenPIC));
	GIV(argumentCount) = (cPIC->cmNumArgs);
	GIV(messageSelector) = (cPIC->selector);
	if (aMethodObj != 0) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		createActualMessageTo(((rcvr & 1)
			? (/* begin splObj: */
				longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
			: (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
					? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
					: (/* begin fetchPointer:ofObject: */
						(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
						longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))));
		if (((aMethodObj & 1) == 0)
		 && ((((((usqInt) (longAt(aMethodObj))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
		 && (isCogMethodReference(longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp;
			executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(aMethodObj), rcvr);
			assert(0);
		}
		GIV(newMethod) = aMethodObj;
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(aMethodObj));
		header = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((header & 1)) {
			methodHeader = header;
		}
		else {
			assert((((usqInt)header)) < (heapBase()));
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
			methodHeader = ((((CogMethod *) header))->methodHeader);
		}
		primBits = (methodHeader >> 1);
		primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
		return interpretMethodFromMachineCode();
	}
	handleMNUInMachineCodeToclassForMessage(SelectorDoesNotUnderstand, rcvr, ((rcvr & 1)
		? (/* begin splObj: */
			(GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))))))
		: (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)
				: (/* begin fetchPointer:ofObject: */
					(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					(GIV(lkupClass) = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord()))))))))));
	assert(0);
	return 0;
}

	/* CoInterpreter>>#ceNewArraySlotSize: */
sqInt
ceNewArraySlotSize(sqInt slotSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return eeInstantiateAndInitializeClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), slotSize);
}

	/* CoInterpreter>>#ceNonLocalReturn: */
sqInt
ceNonLocalReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt callerContextOrNil1;
    sqInt callerContextOrNil2;
    char *callerFP;
    sqInt closure;
    sqInt contextToReturnTo;
    sqInt currentCtx;
    char *frameToReturnTo;
    sqInt home;
    StackPage *newPage;
    sqInt nextCntx;
    sqInt ourContext;
    sqInt ourContext1;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp12;
    char *sp2;
    char *sp21;
    char *sp22;
    char *sp3;
    char *sp31;
    char *sp4;
    char *theFP;
    char *theFP1;
    char *theFP2;
    char *theFP3;
    char *theFP4;
    char *theFP5;
    StackPage *thePage;
    StackPage *thePage1;
    StackPage *thePage2;
    StackPage *thePage3;
    char *theSP;
    char *theSP1;
    char *theSP2;
    sqInt top;
    sqInt unwindContextOrNilOrZero;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* self shortPrintFrameAndCallers: framePointer.
	   self printOop: returnValue.
	   self halt. */
	frameToReturnTo = 0;
	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameIsBlockActivation(GIV(framePointer)));
	closure = longAt(GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer))));

	/* Walk the closure's lexical chain to find the context or frame to return from (home). */
	home = null;
	while (closure != GIV(nilObj)) {
		home = longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
		closure = longAt((home + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	unwindContextOrNilOrZero = findUnwindThroughContext(home);
	if (unwindContextOrNilOrZero == GIV(nilObj)) {

		/* error: can't find home on chain; cannot return */
		/* begin ensureFrameIsMarried:SP: */
		theFP1 = GIV(framePointer);
		theSP = GIV(stackPointer);
		if (((((usqInt)(longAt(theFP1 + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP1 + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP1)));
			ourContext = longAt(theFP1 + FoxThisContext);
			goto l8;
		}
		ourContext = marryFrameSP(theFP1, theSP);
	l8:	/* end ensureFrameIsMarried:SP: */;
		/* begin externalCannotReturn:from: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), ourContext);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp2;
		return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), ourContext, 1);
	}
	if (unwindContextOrNilOrZero != 0) {
		/* begin externalAboutToReturn:through: */
		theFP5 = GIV(framePointer);
		theSP2 = GIV(stackPointer);
		if (((((usqInt)(longAt(theFP5 + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP5 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP5 + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP5)));
			ourContext1 = longAt(theFP5 + FoxThisContext);
			goto l16;
		}
		ourContext1 = marryFrameSP(theFP5, theSP2);
	l16:	/* end ensureFrameIsMarried:SP: */;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), ourContext1);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp12 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp12;
		/* begin push: */
		longAtput((sp22 = GIV(stackPointer) - BytesPerWord), unwindContextOrNilOrZero);
		GIV(stackPointer) = sp22;
		/* begin push: */
		longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp31;
		return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAboutToReturn) << (shiftForWord()))))), ourContext1, 2);
	}
	contextToReturnTo = null;
	if (((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(home, GIV(framePointer)));
		/* begin frameOfMarriedContext: */
		senderOop = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1);

		if ((longAt(theFP + FoxSavedFP)) == 0) {
			/* begin frameCallerContext: */
			assert(isBaseFrame(theFP));
			/* begin stackPageFor: */
			thePage1 = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
			callerContextOrNil = longAt((thePage1->baseAddress));
			assert(addressCouldBeObj(callerContextOrNil));
			assert((callerContextOrNil == (nilObject()))
			 || (isContext(callerContextOrNil)));
			contextToReturnTo = callerContextOrNil;
		}
		else {
			frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
		}
	}
	else {
		contextToReturnTo = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		if ((((contextToReturnTo & 1) == 0)
		 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
			assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
			/* begin frameOfMarriedContext: */
			senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop1 & 1));
			frameToReturnTo = pointerForOop(senderOop1 - 1);

			contextToReturnTo = null;
		}
	}
	if (contextToReturnTo != null) {
		frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
		if (frameToReturnTo == 0) {

			/* error: home's sender is dead; cannot return */
			/* begin ensureFrameIsMarried:SP: */
			theFP2 = GIV(framePointer);
			theSP1 = GIV(stackPointer);
			if (((((usqInt)(longAt(theFP2 + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP2 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP2 + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP2)));
				ourContext = longAt(theFP2 + FoxThisContext);
				goto l11;
			}
			ourContext = marryFrameSP(theFP2, theSP1);
		l11:	/* end ensureFrameIsMarried:SP: */;
			/* begin externalCannotReturn:from: */
			longAtput((sp3 = GIV(stackPointer) - BytesPerWord), ourContext);
			GIV(stackPointer) = sp3;
			/* begin push: */
			longAtput((sp11 = GIV(stackPointer) - BytesPerWord), returnValue);
			GIV(stackPointer) = sp11;
			/* begin push: */
			longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp21;
			return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), ourContext, 1);
		}
	}
	assert(pageListIsWellFormed());
	/* begin stackPageFor: */
	newPage = stackPageAtpages((assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages)))))),
	pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
	if (newPage != GIV(stackPage)) {
		/* begin frameCallerContext: */
		theFP4 = (GIV(stackPage)->baseFP);
		assert(isBaseFrame(theFP4));
		/* begin stackPageFor: */
		thePage3 = stackPageAtpages((assert((((((char *) theFP4)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP4)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP4, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
		callerContextOrNil2 = longAt((thePage3->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil2));
		assert((callerContextOrNil2 == (nilObject()))
		 || (isContext(callerContextOrNil2)));
		currentCtx = callerContextOrNil2;
		assert(isContext(currentCtx));
		freeStackPage(GIV(stackPage));
		while (1) {
			assert(isContext(currentCtx));
			if ((((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
			if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
				/* begin stackPageFor: */
				thePage = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
				/* begin frameCallerContext: */
				theFP3 = (thePage->baseFP);
				assert(isBaseFrame(theFP3));
				/* begin stackPageFor: */
				thePage2 = stackPageAtpages((assert((((((char *) theFP3)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP3)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFP3, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
				callerContextOrNil1 = longAt((thePage2->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil1));
				assert((callerContextOrNil1 == (nilObject()))
				 || (isContext(callerContextOrNil1)));
				currentCtx = callerContextOrNil1;
				freeStackPage(thePage);
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer = GIV(nilObj);
				longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer1 = GIV(nilObj);
				longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
				currentCtx = nextCntx;
			}
		}
		/* begin setStackPageAndLimit: */
		assert(newPage != 0);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (newPage->headSP);
		GIV(framePointer) = (newPage->headFP);
	}
	if (GIV(framePointer) == frameToReturnTo) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
	}
	else {
		do {
			callerFP = GIV(framePointer);
			GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
		} while(GIV(framePointer) != frameToReturnTo);
		GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(callerFP + FoxCallerSavedIP))));
		assert(!(isBaseFrame(callerFP)));
		GIV(stackPointer) = (callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord;

	}
	return returntoExecutive(returnValue, 0);
}


/*	Perform a return from a machine code frame to an interpreted frame.
	The machine code has executed a return instruction when the return address
	is set to ceReturnToInterpreterPC. Return the result and switch to the
	interpreter.  */

	/* CoInterpreter>>#ceReturnToInterpreter: */
sqInt
ceReturnToInterpreter(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    char *sp;
    StackPage *thePage;

	assert(addressCouldBeOop(anOop));
	flag("are you really sure setStackPageAndLimit: is needed?");
	/* begin setStackPageAndLimit: */
	thePage = GIV(stackPage);
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	assert(!(isMachineCodeFrame(GIV(framePointer))));
	/* begin setMethod: */
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	assertValidExecutionPointersimbarline(longAt(GIV(framePointer) + FoxIFSavedIP), GIV(framePointer), GIV(stackPointer), 1, __LINE__);
	GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), anOop);
	GIV(stackPointer) = sp;
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}


/*	Entry-point for an abort send in a CogMethod (aboutToReturn:through:,
	cannotReturn: et al).
	Try and dispatch the send, but the send may turn into an MNU in which case
	defer to
	handleMNUInMachineCodeTo:... which will dispatch the MNU.
	
	Continue execution via either executeMethod or
	interpretMethodFromMachineCode: depending on whether the target method is
	cogged or not. */

	/* CoInterpreter>>#ceSendAbort:to:numArgs: */
sqInt
ceSendAborttonumArgs(sqInt selector, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt aMethodObj;
    sqInt ccIndex;
    sqInt classObj;
    sqInt classTag;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt methodHeader;
    sqInt oop;
    sqInt top;


	/* self printExternalHeadFrame */
	/* self printStringOf: selector */
	assertCStackWellAligned();
	assert(addressCouldBeOop(rcvr));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), rcvr);
	GIV(argumentCount) = numArgs;
	if ((rcvr & 1)) {
		/* begin fetchPointer:ofObject: */
		classTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	if (lookupInMethodCacheSelclassTag(selector, classTag)) {

		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		aMethodObj = GIV(newMethod);
		methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((methodHeader & 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		(methodHeader & 1) == 0)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((assert((methodHeader & 1)),
			((((int) methodHeader)) < 0
					? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
				cogselector(aMethodObj, selector);
			}
			else {
				maybeFlagMethodAsInterpreted(aMethodObj);
			}
		}
	}
	else {
		GIV(messageSelector) = selector;
		classObj = classTag;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		executeNewMethod();
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	Send from an Open PIC when the first-level method lookup probe has failed,
	or to continue when PIC creation has failed (e.g. because we're out of
	code space),
	or when a send has failed due to a forwarded receiver. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#ceSendFromInLineCacheMiss: */
sqInt
ceSendFromInLineCacheMiss(CogMethod *cogMethodOrPIC)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt aMethodObj;
    sqInt ccIndex;
    sqInt classObj;
    sqInt classTag;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt methodHeader;
    usqInt numArgs;
    sqInt oop;
    sqInt rcvr;
    sqInt selector;
    sqInt top;

	numArgs = (cogMethodOrPIC->cmNumArgs);

	/* skip return pc */
	rcvr = longAt(GIV(stackPointer) + ((numArgs + 1) * BytesPerWord));
	assert(addressCouldBeOop(rcvr));
	if ((rcvr & 1)) {
		/* begin fetchPointer:ofObject: */
		classTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	GIV(argumentCount) = numArgs;
	if (lookupInMethodCacheSelclassTag((cogMethodOrPIC->selector), classTag)) {

		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		aMethodObj = GIV(newMethod);
		selector = (cogMethodOrPIC->selector);
		methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((methodHeader & 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		(methodHeader & 1) == 0)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((assert((methodHeader & 1)),
			((((int) methodHeader)) < 0
					? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
				cogselector(aMethodObj, selector);
			}
			else {
				maybeFlagMethodAsInterpreted(aMethodObj);
			}
		}
	}
	else {
		GIV(messageSelector) = (cogMethodOrPIC->selector);
		classObj = classTag;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		executeNewMethod();
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	For RegisterAllocatingCogit we want the address following a conditional
	branch not to be reachable, so we
	don't have to generate code to reload registers. Instead simply convert to
	an interpreter frame,
	backup the pc to the branch, reenter the interpreter and hence retry the
	mustBeBoolean send therein. */

	/* CoInterpreter>>#ceSendMustBeBooleanTo:interpretingAtDelta: */
void
ceSendMustBeBooleanTointerpretingAtDelta(sqInt aNonBooleanObject, sqInt jumpSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    sqInt methodHeader;
    sqInt methodObj;
    sqInt oop;
    char *p;
    char *sp;
    sqInt startBcpc;
    sqInt top;

	assert(addressCouldBeOop(aNonBooleanObject));
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	if ((((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0)
	 && (!(0))) {
		methodHeader = ((((CogMethod *) (((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset)))))))->methodHeader);
		methodObj = ((((CogMethod *) (((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset)))))))->methodObject);
		startBcpc = (cogMethod->startpc);
	}
	else {
		methodHeader = ((((CogMethod *) cogMethod))->methodHeader);
		methodObj = ((((CogMethod *) cogMethod))->methodObject);
		startBcpc = ((literalCountOfMethodHeader(methodHeaderOf(methodObj))) + LiteralStart) * BytesPerOop;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	GIV(instructionPointer) = bytecodePCForstartBcpcin(GIV(instructionPointer), startBcpc, cogMethod);

	/* pre-decrement */
	/* Make space for the two extra fields in an interpreter frame */
	GIV(instructionPointer) = (((methodObj + BaseHeaderSize) + GIV(instructionPointer)) - jumpSize) - 1;
	for (p = GIV(stackPointer); p <= (GIV(framePointer) + FoxMFReceiver); p += BytesPerWord) {
		oop = longAt(p);
		longAtput((p - BytesPerWord) - BytesPerWord, longAt(p));
	}
	GIV(stackPointer) = (GIV(stackPointer) - BytesPerWord) - BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), aNonBooleanObject);
	GIV(stackPointer) = sp;
	longAtput(GIV(framePointer) + FoxIFrameFlags, encodeFrameFieldHasContextisBlocknumArgs(((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0, ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0, (cogMethod->cmNumArgs)));
	longAtput(GIV(framePointer) + FoxIFSavedIP, 0);
	longAtput(GIV(framePointer) + FoxMethod, methodObj);
	/* begin setMethod:methodHeader: */
	GIV(method) = methodObj;
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
}

	/* CoInterpreter>>#ceSendMustBeBoolean: */
sqInt
ceSendMustBeBoolean(sqInt anObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), anObject);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord()))))), anObject, 0);
}


/*	Entry-point for an unlinked send in a CogMethod. Smalltalk stack looks
	like receiver
	args
	head sp ->	sender return pc
	
	If an MNU then defer to handleMNUInMachineCodeTo:... which will dispatch
	the MNU and
	may choose to allocate a closed PIC with a fast MNU dispatch for this
	send. Otherwise
	attempt to link the send site as efficiently as possible. All link
	attempts may fail; e.g.
	because we're out of code memory.
	
	Continue execution via either executeMethod or
	interpretMethodFromMachineCode: depending on whether the target method is
	cogged or not. */

	/* CoInterpreter>>#ceSend:super:to:numArgs: */
sqInt
ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt aMethodObj;
    sqInt ccIndex;
    sqInt classObj;
    sqInt classObj1;
    sqInt classPointer;
    sqInt classTag;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt errSelIdx;
    sqInt literal;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodPointer;
    CogMethod *newCogMethod;
    sqInt offset;
    sqInt oop;
    sqInt top;
    sqInt top1;


	/* self printExternalHeadFrame */
	/* self printStringOf: selector */
	assertCStackWellAligned();
	assert(addressCouldBeOop(rcvr));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), rcvr);
	if (superNormalBar == 0) {
		if ((rcvr & 1)) {
			/* begin fetchPointer:ofObject: */
			classTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
		}
		else {
			if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
				classTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
			}
			else {
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
				classTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
			}
		}
	}
	else {
		/* begin classTagForClass: */
		if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
			methodPointer = ((mframeHomeMethod(GIV(framePointer)))->methodObject);
		}
		else {
			/* begin iframeMethod: */
			methodPointer = longAt(GIV(framePointer) + FoxMethod);
		}
		/* begin followLiteral:ofMethod: */
		offset = (literalCountOfMethodHeader(methodHeaderOf(methodPointer))) - 1;
		literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
		if ((literal != GIV(nilObj))
		 && (((literal & 1) == 0)
		 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))) {

			/* filters out fullBlock last literal */
			assert((numSlotsOf(literal)) > ValueIndex);
			classPointer = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		}
		else {
			/* begin nilObject */
			classPointer = GIV(nilObj);
		}
		classObj1 = longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		classTag = classObj1;
	}
	GIV(argumentCount) = numArgs;
	if (lookupInMethodCacheSelclassTag(selector, classTag)) {

		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		aMethodObj = GIV(newMethod);
		methodHeader1 = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((methodHeader1 & 1))
			 || (((((usqInt)methodHeader1)) < (startOfMemory()))
			 && ((((usqInt)methodHeader1)) >= (minCogMethodAddress())))),
		(methodHeader1 & 1) == 0)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod1 = ((CogMethod *) methodHeader1);
			if (((cogMethod1->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod1, selector);
			}
		}
		else {
			if (((assert((methodHeader1 & 1)),
			((((int) methodHeader1)) < 0
					? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt) methodHeader1) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
				cogselector(aMethodObj, selector);
			}
			else {
				maybeFlagMethodAsInterpreted(aMethodObj);
			}
		}
	}
	else {
		GIV(messageSelector) = selector;
		classObj = classTag;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			if ((errSelIdx == SelectorDoesNotUnderstand)
			 && ((((usqInt)((cogMethod = cogMNUPICSelectorreceivermethodOperandnumArgs(GIV(messageSelector), rcvr, mnuMethodOrNilFor(rcvr), GIV(argumentCount)))))) > (minCogMethodAddress()))) {
				linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, (superNormalBar == 0
					? entryOffset()
					: noCheckEntryOffset()), rcvr);
			}
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		/* begin cogMethodOf: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, selector);
		}
		else {

			/* Deal with anonymous accessors, e.g. in Newspeak.  The cogMethod may not have the
			   correct selector.  If not, try and compile a new method with the correct selector. */
			if (((cogMethod->selector)) != selector) {
				newCogMethod = cogselector(GIV(newMethod), selector);
				if (!(newCogMethod == null)) {
					cogMethod = newCogMethod;
				}
			}
		}
		if (((cogMethod->selector)) == selector) {
			linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, (superNormalBar == 0
				? entryOffset()
				: noCheckEntryOffset()), rcvr);
		}
		else {

			/* If patchToOpenPICFor:.. returns we're out of code memory */
			patchToOpenPICFornumArgsreceiver(selector, numArgs, rcvr);
		}
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		executeNewMethod();
		assert(0);
	}
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top1;
	return interpretMethodFromMachineCode();
}


/*	If contextSwitchIfNotNil is nil we can't context switch.
	contextSwitchIfNotNil is set to nil by
	- the special primitiveClosureValueNoContextSwitch entry-point in block
	dispatch - the stack check in methods with primitive 198.
	In a normal method contextSwitchIfNotNil will be the method (see e.g.
	SimpleStackBasedCogit>>compileFrameBuild). In a block it will be the
	closure (see e.g. SimpleStackBasedCogit>>compileMethodBody). */

	/* CoInterpreter>>#ceStackOverflow: */
void
ceStackOverflow(sqInt contextSwitchIfNotNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cesoRetAddr;
    CogBlockMethod *cogMethod;
    sqInt switched;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	cesoRetAddr = top;
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	assert((cesoRetAddr - (abortOffset())) == (((sqInt)(asCogHomeMethod(cogMethod)))));
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	GIV(method) = (GIV(newMethod) = (GIV(messageSelector) = GIV(nilObj)));
	switched = handleStackOverflowOrEventAllowContextSwitch(contextSwitchIfNotNil != 0);
	returnToExecutivepostContextSwitch(0, switched);
	error("should not be reached");
}

	/* CoInterpreter>>#ceTraceBlockActivation */
void
ceTraceBlockActivation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt selector;

	if (recordBlockTrace()) {
		/* begin recordTrace:thing:source: */
		selector = ((mframeHomeMethod(GIV(framePointer)))->methodObject);
		GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockActivation;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
		if (printOnTrace()) {
			printActivationNameForreceiverisBlockfirstTemporary(((mframeHomeMethod(GIV(framePointer)))->methodObject), ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
				? (/* begin mframeReceiver: */
					longAt(GIV(framePointer) + FoxMFReceiver))
				: (/* begin iframeReceiver: */
					longAt(GIV(framePointer) + FoxIFReceiver))), 1, null);
			/* begin cr */
			printf("\n");
		}
	}
}

	/* CoInterpreter>>#ceTraceLinkedSend: */
void
ceTraceLinkedSend(sqInt theReceiver)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOrInteger;
    CogMethod *cogMethod;
    sqInt oop;
    sqInt selector;
    sqInt selector1;

	cogMethod = ((CogMethod *) ((longAt(GIV(stackPointer))) - (traceLinkedSendOffset())));
	/* begin recordTrace:thing:source: */
	if ((theReceiver & 1)) {
		/* begin splObj: */
		classOrInteger = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(theReceiver))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classOrInteger = (longAt(theReceiver - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classOrInteger = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	selector = (cogMethod->selector);
	GIV(traceLog)[GIV(traceLogIndex)] = classOrInteger;
	GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
	GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
	GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	if (printOnTrace()) {
		printActivationNameForreceiverisBlockfirstTemporary((cogMethod->methodObject), theReceiver, 0, null);
		/* begin cr */
		printf("\n");
	}
	/* begin sendBreakpoint:receiver: */
	selector1 = (cogMethod->selector);
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector1), lengthOfMaybeImmediate(selector1), theReceiver);
}


/*	For assertion checking. */

	/* CoInterpreter>>#ceTraceStoreOf:into: */
void
ceTraceStoreOfinto(sqInt aValue, sqInt anObject)
{
	assert((isImmediate(aValue))
	 || (addressCouldBeObj(aValue)));
	assert(addressCouldBeObj(anObject));
}

	/* CoInterpreter>>#checkAssertsEnabledInCoInterpreter */
void
checkAssertsEnabledInCoInterpreter(void)
{
    sqInt assertsAreEnabledInCoInterpreter;

	assertsAreEnabledInCoInterpreter = 0;
	assert(assertsAreEnabledInCoInterpreter);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all object references in machine
	code are valid. Answer if all checks pass. */

	/* CoInterpreter>>#checkCodeIntegrity: */
static sqInt NoDbgRegParms
checkCodeIntegrity(sqInt gcModes)
{
	return checkIntegrityOfObjectReferencesInCode(gcModes);
}


/*	Check the log for leaks. The trace log is a circular buffer of pairs of
	entries. If there is an entry at traceLogIndex - 3 \\ TraceBufferSize it
	has entries. If
	there is something at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#checkLogIntegrity */
static sqInt
checkLogIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt ok;
    sqInt oop;
    sqInt remainder;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return 1;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	ok = 1;
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!((oop & 1))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i))) {
				ok = 0;
			}
		}
		oop = GIV(traceLog)[i + 1];
		if (!((oop & 1))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i + 1))) {
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* CoInterpreter>>#checkOkayFields: */
static sqInt NoDbgRegParms
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;
    sqInt i1;
    sqInt oop1;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
		 || (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return 1;
	}
	hasYoung = isYoungObject((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))));
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		i = ((literalCountOfMethodHeader(methodHeaderOf(oop))) + LiteralStart) - 1;
	}
	else {
		if (((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOf(oop)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((fieldOop & 1) == 0) {
			if ((i == 0)
			 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
				if ((methodFor(pointerForOop(fieldOop))) == 0) {
					print("method ");
					printHex(oop);
					print(" has an invalid cog method reference");
					return 0;
				}
			}
			else {
				hasYoung = hasYoung
				 || (((fieldOop & 1) == 0)
				 && (oopisGreaterThanOrEqualTo(fieldOop, GIV(youngStart))));
				if (!(checkOkayOop(fieldOop))) {
					return 0;
				}
				if (!(checkOopHasOkayClass(fieldOop))) {
					return 0;
				}
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisGreaterThanOrEqualTo(oop, GIV(youngStart))) {
			return 1;
		}
		if (!(((longAt(oop)) & RootBit) != 0)) {
			print("root bit is not set in ");
			printHex(oop);
			/* begin cr */
			printf("\n");
			return 0;
		}
		for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {
			if (oop == (GIV(rootTable)[i1])) {
				return 1;
			}
		}
		printHex(oop);
		print(" has root bit set but is not in rootTable");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* CoInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    CogMethod *cogMethod;
    char *frameRcvrOffset;
    sqInt i;
    sqInt methodField;
    sqInt ok;
    usqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? (/* begin mframeHasContext: */
						((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0)
					: (/* begin iframeHasContext: */
						(byteAt((theFP + FoxIFrameFlags) + 2)) != 0))) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && (((longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && ((frameOfMarriedContext(oop)) == theFP))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
					/* begin mframeHomeMethod: */
					methodField = longAt(theFP + FoxMethod);
					if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
						cogMethod = ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset))));
						goto l4;
					}
					cogMethod = ((CogMethod *) (methodField & MFMethodMask));
				l4:	/* end mframeHomeMethod: */;
					if ((heapMapAtWord(pointerForOop(cogMethod))) == 0) {
						printFrameThingandFrameat("object leak in mframe mthd", theFP, theFP + FoxMethod);
						ok = 0;
					}
				}
				else {
					oop = longAt(theFP + FoxMethod);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in iframe mthd", theFP, theFP + FoxMethod);
						ok = 0;
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}

	/* CoInterpreter>>#clearTraceLog */
void
clearTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	GIV(traceLogIndex) = 0;
	for (i = 0; i < TraceBufferSize; i += 1) {
		GIV(traceLog)[i] = 0;
	}
}

	/* CoInterpreter>>#cogMethodOf: */
CogMethod *
cogMethodOf(sqInt aMethodOop)
{
    sqInt methodHeader;

	methodHeader = longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	assert((isNonImmediate(methodHeader))
	 && ((((usqInt)methodHeader)) < (startOfMemory())));
	return ((CogMethod *) methodHeader);
}

	/* CoInterpreter>>#commenceCogCompiledCodeCompaction */
static void
commenceCogCompiledCodeCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    usqLong startTime;
    sqInt top;

	GIV(cogCompiledCodeCompactionCalledFor) = 0;
	if (recordEventTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TraceCodeCompaction;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}

	/* This can be called in a number of circumstances.  The instructionPointer
	   may contain a native pc that must be relocated.  There may already be a
	   pushed instructionPointer on stack.  Clients ensure that instructionPointer
	   is 0 if it should not be pushed and/or relocated.  Pushing twice is a mistake
	   because only the top one will be relocated. */
	startTime = ioUTCMicrosecondsNow();
	if (GIV(instructionPointer) != 0) {

		/* better not have already been pushed */
		assert((((usqInt)(stackTop()))) != GIV(instructionPointer));
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	assertValidStackedInstructionPointers(__LINE__);
	compactCogCompiledCode();
	/* begin nilUncoggableMethods */
	GIV(lastCoggableInterpretedBlockMethod) = (GIV(lastUncoggableInterpretedBlockMethod) = null);
	if (GIV(instructionPointer) != 0) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	assertValidStackedInstructionPointers(__LINE__);
	GIV(statCodeCompactionCount) += 1;
	GIV(statCodeCompactionUsecs) += (ioUTCMicrosecondsNow()) - startTime;
	if (checkForLeaks != 0) {
		clearLeakMapAndMapAccessibleObjects();
		asserta(checkCodeIntegrity(0));
	}
}

	/* CoInterpreter>>#compilationBreakpointFor: */
void
compilationBreakpointFor(sqInt selectorOop)
{
	suppressHeartbeatFlag = 1;
	warning("compilation send break (heartbeat suppressed)");
}


/*	Answer a value to store in the InstructionPointer index of a context
	object for theIP and theFP.
	Mapping native pcs to bytecode pcs is quite expensive, requiring a search
	through the method
	map. We mitigate this cost by deferring mapping until we really have to,
	which is when a context's
	instruction pointer is accessed by Smalltalk code (either direct inst var
	access or through the
	instVarAt: primitive). But to defer mapping we have to be able to
	distinguish machine code from
	bytecode pcs, which we do by using negative values for machine code pcs.
	So if the frame is a
	machine code one answer the negation of the offset in the cog method.
	
	As a whorish performance hack we also include the block method offset in
	the pc of a block.
	The least significant 16 bits are the native pc and the most significant
	14 bits are the block
	start, in block alignment units. So when mapping back we can find the
	start of the block.
	
	See mustMapMachineCodePC:context: for the code that does the actual
	mapping.  */

	/* CoInterpreter>>#contextInstructionPointer:frame: */
static sqInt NoDbgRegParms
contextInstructionPointerframe(sqInt theIP, char *theFP)
{
    sqInt blockOffset;
    CogBlockMethod *cogMethod;
    CogMethod *homeMethod;

	assert(validInstructionPointerinFrame(theIP, theFP));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		/* begin encodedNativePCOf:cogMethod: */
		cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
		if (theIP == (ceCannotResumePC())) {
			return HasBeenReturnedFromMCPCOop;
		}
		if (((cogMethod->cmType)) == CMMethod) {
			return (((usqInt)((((sqInt)cogMethod)) - theIP) << 1) | 1);
		}
		homeMethod = ((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset))));
		blockOffset = ((((sqInt)homeMethod)) - (((sqInt)cogMethod))) / (blockAlignment());
		return (((usqInt)((((usqInt) blockOffset << 16)) | (((((sqInt)cogMethod)) - theIP) & 0xFFFF)) << 1) | 1);
	}
	return (((usqInt)(((((theIP == (ceReturnToInterpreterPC())
	? longAt(theFP + FoxIFSavedIP)
	: theIP)) - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
}

	/* CoInterpreter>>#createClosureNumArgs:numCopied:startpc: */
sqInt
createClosureNumArgsnumCopiedstartpc(sqInt numArgs, sqInt numCopied, sqInt initialIP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt newClosure;
    sqInt newClosure1;
    char *theFP;
    char *theSP;

	assert(isMachineCodeFrame(GIV(framePointer)));
	/* begin ensureFrameIsMarried:SP: */
	theFP = GIV(framePointer);
	theSP = GIV(stackPointer) + ((1 + numCopied) * BytesPerWord);
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		context = longAt(theFP + FoxThisContext);
		goto l1;
	}
	context = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
	newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
	newClosure = newClosure1;
	if (recordSendTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (numCopied > 0) {

		/* N.B. the expression ((numCopied - i) * BytesPerWord)) skips the return address */
		for (i = 0; i < numCopied; i += 1) {

			/* Assume: have just allocated a new BlockClosure; it must be young.
			   Thus, can use unchecked stores. */
			longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAt(GIV(stackPointer) + ((numCopied - i) * BytesPerWord)));
		}
	}
	return newClosure;
}


/*	default native stack frame size */

	/* CoInterpreter>>#defaultNativeStackFrameSize */
sqInt
defaultNativeStackFrameSize(void)
{
	return 256;
}


/*	Defer smashes of the stackLimit around the call of functionSymbol (for
	assert checks)
 */

	/* CoInterpreter>>#deferStackLimitSmashAround:with: */
static sqInt NoDbgRegParms
deferStackLimitSmashAroundwith(void (*functionSymbol)(sqInt), sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(deferSmash) = 1;
	sqLowLevelMFence();
	functionSymbol(arg);
	GIV(deferSmash) = 0;
	sqLowLevelMFence();
	if (GIV(deferredSmash)) {
		GIV(deferredSmash) = 0;
		sqLowLevelMFence();
		forceInterruptCheck();
	}
	return 1;
}


/*	Divorce at most one frame in the current page (since the divorce may cause
	the page to be split)
	and answer whether a frame was divorced. */

	/* CoInterpreter>>#divorceAMachineCodeFrameWithCogMethod:in: */
static sqInt NoDbgRegParms
divorceAMachineCodeFrameWithCogMethodin(CogMethod *cogMethod, StackPage *aStackPage)
{
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    char *theSP;

	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);

	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	while (1) {
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
		 && (cogMethod == (mframeHomeMethod(theFP)))) {
			/* begin ensureFrameIsMarried:SP: */
			if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP)));
				theContext = longAt(theFP + FoxThisContext);
				goto l1;
			}
			theContext = marryFrameSP(theFP, theSP);
		l1:	/* end ensureFrameIsMarried:SP: */;
			externalDivorceFrameandContext(theFP, theContext);
			return 1;
		}
		calleeFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP))) + BytesPerWord;

	}
	return 0;
}


/*	The prim trace log is a circular buffer of entries. If there is
	an entry at primTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* CoInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			printPrimLogEntryAt(i);
			/* begin cr */
			printf("\n");
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		printPrimLogEntryAt(i);
		/* begin cr */
		printf("\n");
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is
	an entry at traceLogIndex - 3 \\ TraceBufferSize it has entries.
	If there is something at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#dumpTraceLog */
void
dumpTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(traceLog)[(((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
			? remainder + TraceBufferSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		for (i = GIV(traceLogIndex); i <= (TraceBufferSize - 3); i += 3) {
			printLogEntryAt(i);
		}
	}
	for (i = 0; i <= (GIV(traceLogIndex) - 3); i += 3) {
		printLogEntryAt(i);
	}
}


/*	Make sure the context has a byetcode pc. Can only be used on single
	contexts. 
 */

	/* CoInterpreter>>#ensureContextHasBytecodePC: */
static void NoDbgRegParms
ensureContextHasBytecodePC(sqInt aContext)
{
    sqInt pc;

	assert(!(isMarriedOrWidowedContext(aContext)));
	pc = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if (((pc & 1))
	 && (((pc = (pc >> 1))) < 0)) {
		pc = mustMapMachineCodePCcontext(pc, aContext);
		assert(validBCPCinMethod((pc >> 1), fetchPointerofObject(MethodIndex, aContext)));
		longAtput((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), pc);
	}
}


/*	Safety to give the JIT lattitude in calling convention. Conceptually,
	returning a value to a context involves pushing that value onto the stack.
	This is used
	in Squeak methods such as ContextPart>>jump
	jump
	| top |
	thisContext sender push: nil.
	stackp = 0 ifTrue: [self stepToSendOrReturn].
	stackp = 0 ifTrue: [self push: nil].
	top := self pop.
	thisContext privSender: self.
	^top
	Here jump may pop the value of a temporary variable off the stack which
	will, conceptually and, in the interpreter, actually, get pushed back on
	return. But
	if the JIT is mapping the stack to registers disaster may ensue since the
	value may not get pushed to the stack and code may access an invalid value
	(e.g. a pc).
	
	The solution is to fall back on the interpreter. If the stack pointer is
	changed we
	also ensure the pc is a bytecode pc (+ive) which will cause
	makeBaseFrameFor: to create an interpreter frame if the context is
	executed again. */

	/* CoInterpreter>>#ensureContextIsExecutionSafeAfterAssignToStackPointer: */
static void NoDbgRegParms
ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext)
{
	ensureContextHasBytecodePC(aContext);
}


/*	Main entry-point into the interpreter at each execution level, where an
	execution level is either the start of execution or reentry for a
	callback. Capture the C stack
	pointers so that calls from machine-code into the C run-time occur at this
	level. This is the actual implementation, separated from
	enterSmalltalkExecutive so the
	simulator can wrap it in an exception handler and hence simulate the
	setjmp/longjmp.  */

	/* CoInterpreter>>#enterSmalltalkExecutiveImplementation */
static sqInt
enterSmalltalkExecutiveImplementation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;

	assertCStackWellAligned();
	ceCaptureCStackPointers();
	sigsetjmp(reenterInterpreter, 0);
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		returnToExecutivepostContextSwitch(0, 1);
	}
	/* begin setMethod: */
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	}
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__);
	interpret();
	return 0;
}


/*	Execute a CogMethod from a linked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogMethod:fromLinkedSendWithReceiver: */
void
executeCogMethodfromLinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	
	/* dont use and: so as to get Slang to inline cogit numRegArgs > 0 */
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		callRegisterArgCogMethodatreceiver(cogMethod, entryOffset(), rcvr);
	}

	/* begin push: */
	object = (((sqInt)cogMethod)) + (entryOffset());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp1;
	ceCallCogCodePopReceiverReg();
}


/*	Execute a CogMethod from an unlinked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogMethod:fromUnlinkedSendWithReceiver: */
static void NoDbgRegParms
executeCogMethodfromUnlinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	
	/* dont use and: so as to get Slang to inline cogit numRegArgs > 0 */
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		callRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
	}

	/* begin push: */
	object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp1;
	ceCallCogCodePopReceiverReg();
}


/*	Execute a closed PIC from a linked send, to redispatch based on the rcvr.
	The receiver, arguments and return address are on the Smalltalk stack.
	First push the entry-point and finally the register argument(s). Then
	write back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogPIC:fromLinkedSendWithReceiver:andCacheTag: */
void
executeCogPICfromLinkedSendWithReceiverandCacheTag(CogMethod *cogPIC, sqInt rcvr, sqInt cacheTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	/* begin push: */
	object = (((sqInt)cogPIC)) + (entryOffset());
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp1;
	
	/* dont use and: so as to get Slang to inline cogit numRegArgs > 0 */
	if (((cogPIC->cmNumArgs)) <= (numRegArgs())) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), cacheTag);
		GIV(stackPointer) = sp;
		
		switch ((cogPIC->cmNumArgs)) {
		case 0:
			ceCall0ArgsPIC();
			break;
		case 1:
			ceCall1ArgsPIC();
			break;
		case 2:
			ceCall2ArgsPIC();
			break;
		default:
			;
		}
		error("not reached");
	}

	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), cacheTag);
	GIV(stackPointer) = sp3;
	ceCallCogCodePopReceiverAndClassRegs();
}


/*	Execute newMethod - either primitiveFunctionPointer must be set directly
	(i.e. from primitiveExecuteMethod et al), or it would have been set
	probing the method cache (i.e. primitivePerform et al).
	Eagerly compile it if appropriate so that doits are fast. */

	/* CoInterpreter>>#executeNewMethod */
static sqInt
executeNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt methodHeader;

	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
		if (slowPrimitiveResponse()) {
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
	}
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if (!((assert(((methodHeader & 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		(methodHeader & 1) == 0))) {
		if (((assert((methodHeader & 1)),
		((((int) methodHeader)) < 0
				? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(nilObj));
			methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	if ((assert(((methodHeader & 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	(methodHeader & 1) == 0)) {
		if ((((usqInt)GIV(instructionPointer))) >= (startOfMemory())) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, ((sqInt)GIV(instructionPointer)));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		activateCoggedNewMethod(inInterpreter);
	}
	else {
		activateNewMethod();
	}
	return 0;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state.
	
	If the context is single but has a negative instruction pointer
	recognise that the instruction pointer is actually into machine
	code and convert it to the corresponding bytecode pc. */

	/* CoInterpreter>>#externalInstVar:ofContext: */
static sqInt NoDbgRegParms
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value;

	assert(isContext(aContext));
	assert(offset <= (ReceiverIndex + (checkStackPointerForMaybeMarriedContext(aContext))));
	if (!(offset <= StackPointerIndex)) {
		return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContext)))) {
		return fetchPointerofMarriedContext(offset, aContext);
	}
	value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
	if ((offset == InstructionPointerIndex)
	 && (((value & 1))
	 && ((((int) value)) < 0))) {
		return mustMapMachineCodePCcontext((value >> 1), aContext);
	}
	return value;
}


/*	Find the compiled method to be run when the current messageSelector is
	sent to the given classTag, setting the values of newMethod and
	primitiveIndex. 
 */

	/* CoInterpreter>>#findNewMethodInClassTag: */
static void NoDbgRegParms
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt aMethodObj;
    sqInt classTag;
    CogMethod *cogMethod;
    sqInt methodHeader;
    sqInt ok;
    sqInt selector;

	ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg);
	if (ok) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		aMethodObj = GIV(newMethod);
		selector = GIV(messageSelector);
		methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((methodHeader & 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		(methodHeader & 1) == 0)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((assert((methodHeader & 1)),
			((((int) methodHeader)) < 0
					? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
				cogselector(aMethodObj, selector);
			}
			else {
				maybeFlagMethodAsInterpreted(aMethodObj);
			}
		}
	}
	else {

		/* entry was not found in the cache; perhaps soemthing was forwarded. */
		classTag = classTagArg;
		GIV(lkupClass) = classTag;
		lookupMethodInClass(GIV(lkupClass));

		addNewMethodToCache(GIV(lkupClass));
	}
}


/*	methodObj is a CompiledMethod. If it contains an external primitive,
	flush the function address and session ID of the CM. Answer the prim
	index for the benefit of subclass overrides. */
/*	methodObj is a CompiledMethod containing an external primitive.
	Flush the function address and session ID of the CM. Override
	to also flush the machine code call if one exists. */

	/* CoInterpreter>>#flushExternalPrimitiveOf: */
void
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt header;
    sqInt header1;
    sqInt lit;
    sqInt methodHeader;
    sqInt primBits;
    sqInt primIdx;
    sqInt primIdx1;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header1 = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((header1 & 1)) {
		header = header1;
	}
	else {
		assert((((usqInt)header1)) < (heapBase()));
		assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
		header = ((((CogMethod *) header1))->methodHeader);
	}
	primBits = (header >> 1);
	primIdx1 = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	if ((primIdx1 == PrimNumberExternalCall)
	 && (((assert((header & 1)),
	((((int) header)) < 0
			? (/* begin literalCountOfAlternateHeader: */
				((header >> 1)) & AlternateHeaderNumLiteralsMask)
			: (/* begin literalCountOfOriginalHeader: */
				(((usqInt) header) >> 10) & 0xFF)))) > 0)) {

		/* If not, something's broken */
		lit = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		if ((((lit & 1) == 0)
		 && (((((usqInt) (longAt(lit))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((numSlotsOf(lit)) == 4)) {

			/* If not, something's broken */
			longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord())), ConstZero);
			longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), ConstZero);
		}
	}
	primIdx = primIdx1;
	if ((primIdx == PrimNumberExternalCall)
	 && ((assert(isNonImmediate(methodObj)),
	/* begin isCogMethodReference: */
	(methodHeader = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))),
	assert(((methodHeader & 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	(methodHeader & 1) == 0))) {
		rewritePrimInvocationInto(cogMethodOf(methodObj), primitiveExternalCall);
	}
}


/*	Flush the method cache. The method cache is flushed on every programming
	change and garbage collect.
 */
/*	Flush the method cache. The method cache is flushed on every programming
	change and garbage collect.
 */

	/* CoInterpreter>>#flushMethodCache */
static void
flushMethodCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* CoInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
	l1:	/* end checkForLongRunningPrimitive */;
		sqLowLevelMFence();
		if (GIV(deferSmash)) {
			GIV(deferredSmash) = 1;
			sqLowLevelMFence();
		}
		else {
			forceInterruptCheck();
		}
	}
}


/*	In the StackInterpreter the saved ip field of a base frame holds the
	base frame's caller context. But in the Cog VM the first word on the
	stack holds the base frame's caller context, which is immediately
	above the stacked receiver. */

	/* CoInterpreter>>#frameCallerContext: */
static sqInt NoDbgRegParms
frameCallerContext(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    StackPage *thePage;

	assert(isBaseFrame(theFP));
	/* begin stackPageFor: */
	thePage = stackPageAtpages((assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
	pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(callerContextOrNil)));
	return callerContextOrNil;
}


/*	In the StackInterpreter the saved ip field of a base frame holds the
	base frame's caller context. But in the Cog VM the first word on the
	stack holds the base frame's caller context, which is immediately
	above the stacked receiver. */

	/* CoInterpreter>>#frameCallerContext:put: */
static sqInt NoDbgRegParms
frameCallerContextput(char *theFP, sqInt aValue)
{
	assert(isBaseFrame(theFP));
	assert(((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord)) == (((stackPageFor(theFP))->baseAddress)));
	assert((longAt((theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) == (frameContext(theFP)));
	return longAtput((theFP + (frameStackedReceiverOffsetNumArgs(((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? ((mframeCogMethod(theFP))->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))))) + (2 * BytesPerWord), aValue);
}

	/* CoInterpreter>>#frameHasContext: */
static sqInt NoDbgRegParms
frameHasContext(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0);
}


/*	<Integer> */

	/* CoInterpreter>>#frameIsBlockActivation: */
static sqInt NoDbgRegParms
frameIsBlockActivation(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* CoInterpreter>>#frameNumArgs: */
static sqInt NoDbgRegParms
frameNumArgs(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeCogMethod(theFP))->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
}

	/* CoInterpreter>>#framePointerAddress */
usqInt
framePointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(framePointer))));
}

	/* CoInterpreter>>#frameReceiver: */
static sqInt NoDbgRegParms
frameReceiver(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
}

	/* CoInterpreter>>#functionPointerForCompiledMethod:primitiveIndex: */
void (*functionPointerForCompiledMethodprimitiveIndex(sqInt methodObj, sqInt primIndex))(void)

{
    static void *function = (void *)-1;
    void (*functionPointer)(void);
    void (*functionPointer1)(void);
    sqInt index;
    sqInt lit;

	/* begin functionPointerFor:inClass: */
	functionPointer = ((void (*)(void)) ((primIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIndex])));
	if (functionPointer == primitiveCalloutToFFI) {
		/* begin functionForPrimitiveCallout */
		if ((((sqInt)function)) == -1) {
			function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
		}
		return ((void (*)(void)) function);
	}
	if (functionPointer == primitiveExternalCall) {
		/* begin functionForPrimitiveExternalCall: */
		setPostCompileHook(recordCallOffsetIn);
		if (!((literalCountOfMethodHeader(methodHeaderOf(methodObj))) > 0)) {
			return ((void (*)(void)) primitiveExternalCall);
		}

		/* Check if it's an array of length 4 */
		lit = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		if (!((((lit & 1) == 0)
			 && (((((usqInt) (longAt(lit))) >> (instFormatFieldLSB())) & 15) == 2))
			 && ((lengthOf(lit)) == 4))) {
			return ((void (*)(void)) primitiveExternalCall);
		}
		index = longAt((lit + BaseHeaderSize) + (3U << (shiftForWord())));
		if (!(((index & 1))
			 && ((((index = (index >> 1))) > 0)
			 && (index <= MaxExternalPrimitiveTableSize)))) {
			return ((void (*)(void)) primitiveExternalCall);
		}
		functionPointer1 = externalPrimitiveTable[index - 1];
		if (functionPointer1 == 0) {
			return ((void (*)(void)) primitiveExternalCall);
		}
		return functionPointer1;
	}
	return functionPointer;
}

	/* CoInterpreter>>#getCheckAllocFiller */
sqInt
getCheckAllocFiller(void)
{
	return checkAllocFiller;
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. Override to answer -1 if we're not in an interpreter frame. */

	/* CoInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((((((usqInt)GIV(framePointer))) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)GIV(framePointer))) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)GIV(framePointer))) <= (((usqInt)GIV(pages)))))))
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())))
		? byteAt(GIV(instructionPointer))
		: -1);
}


/*	A message send from either an open PIC or an unlinked send has not been
	understood. Create a message and execute the relevant resulting MNU
	method. messageSelector is an implicit argument (yuck). */

	/* CoInterpreter>>#handleMNU:InMachineCodeTo:classForMessage: */
static sqInt NoDbgRegParms
handleMNUInMachineCodeToclassForMessage(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt aMethodObj;
    sqInt classForThisMessage;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt methodHeader;
    sqInt selector;
    char *sp;
    char *sp1;
    sqInt top;

	assert(addressCouldBeOop(rcvr));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	createActualMessageTo(classForMessage);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(selectorIndex) << (shiftForWord())))));
	if (lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClass))) {

		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		aMethodObj = GIV(newMethod);
		selector = GIV(messageSelector);
		methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((methodHeader & 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		(methodHeader & 1) == 0)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((assert((methodHeader & 1)),
			((((int) methodHeader)) < 0
					? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt) methodHeader) >> 10) & 0xFF))) <= maxLiteralCountForCompile) {
				cogselector(aMethodObj, selector);
			}
			else {
				maybeFlagMethodAsInterpreted(aMethodObj);
			}
		}
	}
	else {
		errSelIdx = lookupMNUInClass((classForThisMessage = GIV(lkupClass)));
		if (errSelIdx != 0) {
			if (selectorIndex == SelectorDoesNotUnderstand) {
				error("Recursive not understood error encountered");
			}
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp;
			return handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classForThisMessage);
		}
	}
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp1;
		executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(GIV(newMethod)), rcvr);
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	<Integer> */

	/* CoInterpreter>>#iframeIsBlockActivation: */
static sqInt NoDbgRegParms
iframeIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxIFrameFlags) + 3)) != 0;
}

	/* CoInterpreter>>#iframeReceiver: */
static sqInt NoDbgRegParms
iframeReceiver(char *theFP)
{
	return longAt(theFP + FoxIFReceiver);
}

	/* CoInterpreter>>#iframeSavedIP: */
static sqInt NoDbgRegParms
iframeSavedIP(char *theFP)
{
	return longAt(theFP + FoxIFSavedIP);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null. */

	/* CoInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (savedFPP != 0) {
		savedFPP[0] = GIV(framePointer);
	}
	if (savedSPP != 0) {
		savedSPP[0] = GIV(stackPointer);
	}
	if ((((((usqInt)theCFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCFP)) <= (((usqInt)GIV(pages))))))) {
		GIV(framePointer) = theCFP;
	}
	if ((((((usqInt)theCSP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCSP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCSP)) <= (((usqInt)GIV(pages))))))) {
		GIV(stackPointer) = theCSP;
	}
}

	/* CoInterpreter>>#instructionPointerAddress */
usqInt
instructionPointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(instructionPointer))));
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* CoInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static sqInt NoDbgRegParms
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;
    sqInt value;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages((assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))), GIV(pages));
		/* begin findFrameAbove:inPage: */
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l2;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l2;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
	l2:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove == 0
			? longAt((thePage->headSP))
			: oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP))));
	}
	value = contextInstructionPointerframe(theIP, spouseFP);
	return ((((int) value)) < 0
		? mustMapMachineCodePCcontext((value >> 1), longAt(spouseFP + FoxThisContext))
		: value);
}


/*	This is used for asserts that check that inline cache editing results in
	valid addresses.
	In the C VM interpret is presumed to come before any primitives and so it
	constitutes the lowest address in C code that machine code should be
	linked. In the simulator
	we just answer something not low. */

	/* CoInterpreter>>#interpretAddress */
usqInt
interpretAddress(void)
{
	return ((usqInt)((&interpret)));
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* CoInterpreter>>#interpreterAllocationReserveBytes */
static sqInt NeverInline
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes()) + ((IFrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / MFrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	Execute a method interpretively from machine code. We assume (require)
	that newMethod
	messageSelector, primitiveFunctionPointer and argumentCount have been set
	in the caller.
	Once evaluated either continue in the interpreter via a jongjmp or in
	machine code via an
	enilopmart (a form of longjmp - a stinking rose by any other name). */

	/* CoInterpreter>>#interpretMethodFromMachineCode */
static sqInt
interpretMethodFromMachineCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nArgs;
    char *savedFramePointer;
    char *savedStackPointer;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	assertCStackWellAligned();
	assert(validInstructionPointerinFrame(GIV(instructionPointer), GIV(framePointer)));
	if (primitiveFunctionPointer != 0) {
		if (primitiveFunctionPointer == primitiveInvokeObjectAsMethod) {
			assert(!(isOopCompiledMethod(GIV(newMethod))));
		}
		else {
			assert((isOopCompiledMethod(GIV(newMethod)))
			 && ((primitiveIndexOf(GIV(newMethod))) != 0));
		}
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			GIV(primFailCode) = 0;
		}
		else {
			/* begin slowPrimitiveResponse */
			if (recordPrimTrace()) {
				/* begin fastLogPrim: */
				GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
				primTraceLogIndex(GIV(primTraceLogIndex) + 1);
			}
			assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
			assert((remapBufferCount()) == 0);
			nArgs = GIV(argumentCount);
			savedStackPointer = GIV(stackPointer);
			savedFramePointer = GIV(framePointer);

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
			assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
			/* begin maybeRetryPrimitiveOnFailure */
			/* begin maybeFailForLastObjectOverwrite */
			if (checkAllocFiller) {
				if (((freeStart()) < GIV(scavengeThreshold))
				 && ((longAt(freeStart())) != (freeStart()))) {
					/* begin primitiveFailFor: */
					GIV(primFailCode) = PrimErrWritePastObject;
				}
			}
			if ((!GIV(primFailCode))
			 && ((GIV(framePointer) == savedFramePointer)
			 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {

				/* Don't fail if primitive has done something radical, e.g. perform: */
				if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
					flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
					failUnbalancedPrimitive();
					GIV(stackPointer) = savedStackPointer;
				}
			}
			if (GIV(nextProfileTick) > 0) {
				checkProfileTick(GIV(newMethod));
			}
			!GIV(primFailCode);
		}
		if (!GIV(primFailCode)) {
			returntoExecutive(popStack(), 0);
		}
	}
	else {
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && (((primitiveIndexOf(GIV(newMethod))) == 0)
		 || (((functionPointerForinClass(primitiveIndexOf(GIV(newMethod)), nilObject())) == 0)
		 || (isNullExternalPrimitiveCall(GIV(newMethod))))));
	}
	activateNewMethod();
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}

	/* CoInterpreter>>#isCogMethodReference: */
sqInt
isCogMethodReference(sqInt methodHeader)
{
	assert(((methodHeader & 1))
	 || (((((usqInt)methodHeader)) < (startOfMemory()))
	 && ((((usqInt)methodHeader)) >= (minCogMethodAddress()))));
	return (methodHeader & 1) == 0;
}

	/* CoInterpreter>>#isMachineCodeFrame: */
static sqInt NoDbgRegParms
isMachineCodeFrame(char *theFP)
{
	return (((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory());
}


/*	Lookup selector in rcvr, without doing MNU processing, and answer either a
	method or an error code if the message was not understood. Used to
	populate closed PICs. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#lookupMNU:receiver: */
sqInt
lookupMNUreceiver(sqInt selector, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classTag;
    sqInt erridx;
    sqInt inCache;
    sqInt oop;

	if ((rcvr & 1)) {
		/* begin fetchPointer:ofObject: */
		classTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	inCache = lookupInMethodCacheSelclassTag(selector, classTag);

	if (!inCache) {
		GIV(messageSelector) = selector;
		erridx = lookupMNUInClass(classTag);
		if (erridx != 0) {
			assert(erridx <= (maxLookupNoMNUErrorCode()));
			return erridx;
		}
	}
	return GIV(newMethod);
}


/*	Lookup selector in rcvr, without doing MNU processing, and answer either a
	method or an error code if the message was not understood. Used to
	populate closed PICs. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#lookupOrdinary:receiver: */
sqInt
lookupOrdinaryreceiver(sqInt selector, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classTag;
    sqInt erridx;
    sqInt oop;

	if ((rcvr & 1)) {
		/* begin fetchPointer:ofObject: */
		classTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	if (!(lookupInMethodCacheSelclassTag(selector, classTag))) {
		GIV(messageSelector) = selector;
		if (((erridx = lookupOrdinaryNoMNUEtcInClass(classTag))) != 0) {
			assert(erridx <= (maxLookupNoMNUErrorCode()));
			return erridx;
		}
	}
	return GIV(newMethod);
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. Override to
	hold the caller context in a different place, In the StackInterpreter we
	use the caller saved ip, but in the Cog VM caller saved ip is the
	ceBaseReturn: trampoline. Simply hold the caller context in the first word
	of the stack. */

	/* CoInterpreter>>#makeBaseFrameFor: */
static StackPage * NoDbgRegParms
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    sqInt header1;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rawHeader;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    char *value;
    sqInt valuePointer;
    sqInt yetToCompact;


	/* theIP must be typed as signed because it is assigned ceCannotResumePC and so maybe implicitly typed as unsigned. */
	assert(isContext(aContext));
	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));
	theIP = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	assert(HasBeenReturnedFromMCPC < 0);
	theIP = ((theIP & 1)
		? (theIP >> 1)
		: HasBeenReturnedFromMCPC);
	theMethod = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		page = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
l1:	/* end newStackPage */;
	longAtput((pointer = (page->baseAddress)), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord()))))));
	longAtput((pointer -= BytesPerWord), aContext);

	/* If the frame is a closure activation then the closure should be on the stack in
	   the pushed receiver position (closures receive the value[:value:] messages).
	   Otherwise it should be the receiver proper. */
	rcvr = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	maybeClosure = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (maybeClosure != GIV(nilObj)) {
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
		assert((oop & 1));
		numArgs = (oop >> 1);
		longAtput((pointer -= BytesPerWord), maybeClosure);
	}
	else {
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(theMethod));
		header1 = longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((header1 & 1)) {
			header = header1;
		}
		else {
			assert((((usqInt)header1)) < (heapBase()));
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
			header = ((((CogMethod *) header1))->methodHeader);
		}

		/* If this is a synthetic context its IP could be pointing at the CallPrimitive opcode.  If so, skip it. */
		numArgs = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
		if ((header & V3PrimitiveBitsMask)
		 && (theIP == (1 + ((((assert((header & 1)),
((((int) header)) < 0
		? ((header >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) header) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop)))) {
			theIP += 0;
		}
		longAtput((pointer -= BytesPerWord), rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
	longAtput((pointer -= BytesPerWord), ceBaseFrameReturnPC());
	longAtput((pointer -= BytesPerWord), 0);
	(page->headFP = pointer);
	if (theIP < 0) {

		/* Since we would have to generate a machine-code method to be able to map
		   the native pc anyway we should create a native method and native frame. */
		/* begin ensureMethodIsCogged:maybeClosure: */
		rawHeader = longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((assert(((rawHeader & 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		(rawHeader & 1) == 0)) {
			cogMethod = ((CogMethod *) rawHeader);
			goto l9;
		}
		yetToCompact = 1;
		while (1) {
			cogMethod1 = cogselector(theMethod, GIV(nilObj));

			if (!((cogMethod1 == null)
			 && (GIV(cogCompiledCodeCompactionCalledFor)
			 && (yetToCompact)))) break;
			yetToCompact = 0;
			commenceCogCompiledCodeCompaction();
		}
		if (!(asserta(cogMethod1 != null))) {
			error("could not compile method that should have been compiled");
		}
		cogMethod = cogMethod1;
	l9:	/* end ensureMethodIsCogged:maybeClosure: */;
		theMethod = ((sqInt)cogMethod);
		if (maybeClosure != GIV(nilObj)) {
			
			/* If the pc is the special HasBeenReturnedFromMCPC pc set the pc
			   appropriately so that the frame stays in the cannotReturn: state. */
			if (theIP == HasBeenReturnedFromMCPC) {
				theMethod = ((sqInt)(findMethodForStartBcpcinHomeMethod((((longAt((maybeClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 1)) - 1, ((CogMethod *) theMethod))));
				if (theMethod == 0) {
					error("cannot find machine code block matching closure's startpc");
				}
				theIP = ceCannotResumePC();
			}
			else {
				assert((((signed)theIP >> 16)) < -1);
				theMethod -= (((signed)theIP >> 16)) * (blockAlignment());
				theIP = theMethod - (((short)theIP));
			}

			longAtput((pointer -= BytesPerWord), (theMethod + MFMethodFlagHasContextFlag) + MFMethodFlagIsBlockFlag);
		}
		else {
			assert((((signed)theIP >> 16)) >= -1);
			theIP = (theIP == HasBeenReturnedFromMCPC
				? ceCannotResumePC()
				: (((sqInt)theMethod)) - theIP);
			longAtput((pointer -= BytesPerWord), theMethod + MFMethodFlagHasContextFlag);
		}
		longAtput((pointer -= BytesPerWord), aContext);
	}
	else {
		longAtput((pointer -= BytesPerWord), theMethod);
		longAtput((pointer -= BytesPerWord), aContext);
		longAtput((pointer -= BytesPerWord), (VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (1U << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
	? 1U << ((BytesPerWord * 8) - 24)
	: 0))
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (1U << 16)) + ((maybeClosure != GIV(nilObj)
	? 1U << 24
	: 0))));
		longAtput((pointer -= BytesPerWord), 0);
		assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
		theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;

	}
	(page->baseFP = (page->headFP));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	stackPtrIndex = (oop1 >> 1);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = (page->baseFP);
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(value)) + 1;
	longAtput((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), (assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0),
	(oopForPointer(0)) + 1));
	assert(((fetchPointerofObject(SenderIndex, aContext)) & 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}


/*	The prim trace log is a circular buffer of selectors. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* CoInterpreter>>#mapPrimTraceLog */
static void
mapPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;
    sqInt selector;

	if ((GIV(primTraceLog)[(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			selector = GIV(primTraceLog)[i];
			if ((selector != 0)
			 && (((selector & 1) == 0)
			 && (((selector & 1) == 0)
			 && (((longAt(selector)) & MarkBit) != 0)))) {
				GIV(primTraceLog)[i] = (remapObj(selector));
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		selector = GIV(primTraceLog)[i];
		if ((selector != 0)
		 && (((selector & 1) == 0)
		 && (((selector & 1) == 0)
		 && (((longAt(selector)) & MarkBit) != 0)))) {
			GIV(primTraceLog)[i] = (remapObj(selector));
		}
	}
}

	/* CoInterpreter>>#mapStackPages */
static void NeverInline
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			numLivePages += 1;
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
				 || ((longAt(theFP + FoxIFSavedIP)) == 0)
					? 0
					: theFP + FoxIFSavedIP);
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && (((oop & 1) == 0)
					 && (((longAt(oop)) & MarkBit) != 0))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					if (shouldRemapObj(longAt(theFP + FoxThisContext))) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
									}
				if (!((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))) {
					if (shouldRemapObj(longAt(theFP + FoxMethod))) {
						if (theIPPtr != 0) {
							theIP = longAt(theIPPtr);
							if (theIP == (ceReturnToInterpreterPC())) {
								assert((iframeSavedIP(theFP)) > (iframeMethod(theFP)));
								theIPPtr = theFP + FoxIFSavedIP;
								theIP = longAt(theIPPtr);
							}
							else {
								assert(theIP > (iframeMethod(theFP)));
							}
							theIP -= longAt(theFP + FoxMethod);
						}
						longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
						if (theIPPtr != 0) {
							longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
						}
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && (((oop & 1) == 0)
				 && (((longAt(oop)) & MarkBit) != 0))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	The trace log is a circular buffer of pairs of entries. If there is
	an entry at traceLogIndex - 3 \\ TraceBufferSize it has entries.
	If there is something at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#mapTraceLog */
static void
mapTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt intOrClass;
    sqInt limit;
    sqInt remainder;
    sqInt selectorOrMethod;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		intOrClass = GIV(traceLog)[i];
		if (((intOrClass & 1) == 0)
		 && (((intOrClass & 1) == 0)
		 && (((longAt(intOrClass)) & MarkBit) != 0))) {
			GIV(traceLog)[i] = (remapObj(intOrClass));
		}
		selectorOrMethod = GIV(traceLog)[i + 1];
		if (((selectorOrMethod & 1) == 0)
		 && (((selectorOrMethod & 1) == 0)
		 && (((longAt(selectorOrMethod)) & MarkBit) != 0))) {
			GIV(traceLog)[i + 1] = (remapObj(selectorOrMethod));
		}
	}
}

	/* CoInterpreter>>#markActiveMethodsAndReferents */
void
markActiveMethodsAndReferents(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			markCogMethodsAndReferentsOnPage(thePage);
		}
	}
}


/*	The prim trace log is a circular buffer of selectors. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* CoInterpreter>>#markAndTracePrimTraceLog */
static void
markAndTracePrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;
    sqInt selector;

	if ((GIV(primTraceLog)[(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			selector = GIV(primTraceLog)[i];
			if ((selector != 0)
			 && ((selector & 1) == 0)) {
				markAndTrace(selector);
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		selector = GIV(primTraceLog)[i];
		if ((selector != 0)
		 && ((selector & 1) == 0)) {
			markAndTrace(selector);
		}
	}
}

	/* CoInterpreter>>#markAndTraceStackPage: */
static void NoDbgRegParms
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *aCogMethod;
    char *callerFP;
    char *frameRcvrOffset;
    CogMethod *homeMethod;
    sqInt oop;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? theFP + FoxMFReceiver
			: theFP + FoxIFReceiver);
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(longAt(theFP + FoxThisContext));
		}
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			/* begin markAndTraceMachineCodeMethod: */
			aCogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
			/* begin asCogHomeMethod: */
			homeMethod = (((aCogMethod->cmType)) == CMMethod
				? ((CogMethod *) aCogMethod)
				: ((CogMethod *) ((((usqInt)aCogMethod)) - ((aCogMethod->homeOffset)))));
			markAndTrace((homeMethod->methodObject));
		}
		else {
			markAndTrace(longAt(theFP + FoxMethod));
		}
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is ceBaseReturnPC */
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is an
	entry at
	traceLogIndex - 3 \\ TraceBufferSize it has entries. If there is something
	at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#markAndTraceTraceLog */
static void
markAndTraceTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt oop;
    sqInt remainder;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		oop = GIV(traceLog)[i + 1];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}

	/* CoInterpreter>>#markCogMethodsAndReferentsOnPage: */
static void NoDbgRegParms
markCogMethodsAndReferentsOnPage(StackPage *thePage)
{
    char *callerFP;
    char *theFP;

	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	while (1) {
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			markMethodAndReferents(mframeCogMethod(theFP));
		}
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theFP = callerFP;
	}
}


/*	Answer whether marryFrame:SP: copies non-argument temporaries. */

	/* CoInterpreter>>#marryFrameCopiesTemps */
sqInt
marryFrameCopiesTemps(void)
{
	return 0;
}

	/* CoInterpreter>>#maxLookupNoMNUErrorCode */
sqInt
maxLookupNoMNUErrorCode(void)
{
	return ((SelectorCannotInterpret < SelectorDoesNotUnderstand) ? SelectorDoesNotUnderstand : SelectorCannotInterpret);
}


/*	The flag bit can be used to flag methods that are interpreted, if it has
	been requested
	from the image header flags. */

	/* CoInterpreter>>#maybeFlagMethodAsInterpreted: */
static void NoDbgRegParms
maybeFlagMethodAsInterpreted(sqInt aMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rawHeader;
    sqInt realHeader;

	if (GIV(flagInterpretedMethods)) {
		rawHeader = longAt((aMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
		realHeader = ((assert(((rawHeader & 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		(rawHeader & 1) == 0)
			? ((((CogMethod *) rawHeader))->methodHeader)
			: rawHeader);
		realHeader = realHeader | ((((usqInt)(1U << MethodHeaderFlagBitPosition) << 1) | 1));
		if ((assert(((rawHeader & 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		(rawHeader & 1) == 0)) {
			((((CogMethod *) rawHeader))->methodHeader = realHeader);
		}
		else {
			longAtput((aMethod + BaseHeaderSize) + (0U << (shiftForWord())), realHeader);
		}
	}
}

	/* CoInterpreter>>#mcprimFunctionForPrimitiveIndex: */
sqInt
mcprimFunctionForPrimitiveIndex(sqInt primIndex)
{
	if (primIndex == PrimNumberHashMultiply) {
		return mcprimHashMultiply;
	}
	error("unknown mcprim");
	return null;
}

	/* CoInterpreter>>#methodCacheAddress */
void *
methodCacheAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(methodCache);
}

	/* CoInterpreter>>#methodHasCogMethod: */
sqInt
methodHasCogMethod(sqInt aMethodOop)
{
    sqInt methodHeader;

	assert(isNonImmediate(aMethodOop));
	/* begin isCogMethodReference: */
	methodHeader = longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	assert(((methodHeader & 1))
	 || (((((usqInt)methodHeader)) < (startOfMemory()))
	 && ((((usqInt)methodHeader)) >= (minCogMethodAddress()))));
	return (methodHeader & 1) == 0;
}

	/* CoInterpreter>>#methodNeedsLargeContext: */
sqInt
methodNeedsLargeContext(sqInt methodObj)
{
    sqInt header;
    sqInt methodHeader;

	/* begin methodHeaderIndicatesLargeFrame: */
	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((header & 1)) {
		methodHeader = header;
	}
	else {
		assert((((usqInt)header)) < (heapBase()));
		assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
		methodHeader = ((((CogMethod *) header))->methodHeader);
	}
	return (methodHeader & LargeContextBit) != 0;
}

	/* CoInterpreter>>#methodShouldBeCogged: */
sqInt
methodShouldBeCogged(sqInt aMethodObj)
{
	if (methodWithHeaderShouldBeCogged(methodHeaderOf(aMethodObj))) {
		return 1;
	}
	maybeFlagMethodAsInterpreted(aMethodObj);
	return 0;
}


/*	At the moment jit any method with less than N literals, where N defaults
	to 60.
	See e.g. SimpleStackBasedCogit class>>initialize.
	In my dev image eem 2/22/2009 13:39
	(30 to: 100 by: 5) collect:
	[:n| n -> (SystemNavigation default allSelect: [:m| m numLiterals > n])
	size] #(30->1681 35->1150 40->765 45->523 50->389 55->289 60->206
	65->151 70->124 75->99 80->73 85->63 90->54 95->42 100->38).
	And running the CogVMSimulator with flagging of interpreted methods turned
	on reveals
	the following sizes of interpreted methods.
	| sizes |
	sizes := Bag new.
	SystemNavigation default allSelect: [:m| m flag ifTrue: [sizes add: m
	numLiterals]. false].
	sizes sortedElements asArray
	#(	40->4 41->1 42->2 44->1 45->3 46->1 47->2 48->1
	50->2 51->1 53->1 55->1 56->1
	87->1 108->1 171->1)
	literalCountOfHeader: does not include the header word. */

	/* CoInterpreter>>#methodWithHeaderShouldBeCogged: */
static sqInt NoDbgRegParms
methodWithHeaderShouldBeCogged(sqInt methodHeader)
{
	return ((assert((methodHeader & 1)),
	((((int) methodHeader)) < 0
			? (/* begin literalCountOfAlternateHeader: */
				((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask)
			: (/* begin literalCountOfOriginalHeader: */
				(((usqInt) methodHeader) >> 10) & 0xFF)))) <= maxLiteralCountForCompile;
}


/*	Answer the Cog method for a machine code frame. This may be
	either a full CogMethod or merely a CogBlockMethod rump header. */

	/* CoInterpreter>>#mframeCogMethod: */
static CogBlockMethod * NoDbgRegParms
mframeCogMethod(char *theFP)
{
	return ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
}

	/* CoInterpreter>>#mframeHomeMethodExport */
CogMethod *
mframeHomeMethodExport(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodField;

	/* begin mframeHomeMethod: */
	methodField = longAt(GIV(framePointer) + FoxMethod);
	if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
		return ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset))));
	}
	return ((CogMethod *) (methodField & MFMethodMask));
}


/*	Answer the home method for a machine code frame. From a block frame we
	find the home method through the block's homeOffset field which is the
	delta to it.
	In both cases we need to strip the isBlock and isContext flags from the
	method field. */

	/* CoInterpreter>>#mframeHomeMethod: */
CogMethod *
mframeHomeMethod(char *theFP)
{
    sqInt methodField;

	/* begin frameMethodField: */
	methodField = longAt(theFP + FoxMethod);
	if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
		return ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset))));
	}
	return ((CogMethod *) (methodField & MFMethodMask));
}


/*	<Integer> */

	/* CoInterpreter>>#mframeIsBlockActivation: */
static sqInt NoDbgRegParms
mframeIsBlockActivation(char *theFP)
{
	return ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0;
}

	/* CoInterpreter>>#mframeReceiver: */
static sqInt NoDbgRegParms
mframeReceiver(char *theFP)
{
	return longAt(theFP + FoxMFReceiver);
}


/*	Traverse all stack pages looking for non-zero bytes in the headroom part
	of each page.
	Answer the minimum size of unused headroom (zero bytes) in the pages. This
	is for
	checking that there is enough headroom allocated in stack pages. */

	/* CoInterpreter>>#minimumUnusedHeadroom */
static sqInt
minimumUnusedHeadroom(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    int minUnused;
    char *p;
    StackPage *page;
    int unused;

	minUnused = (((stackPageAt(0))->baseAddress)) - (((stackPageAt(0))->lastAddress));
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(i, GIV(pages));
		p = (page->lastAddress);
		do {
			p += BytesPerWord;
		} while(((longAtPointer(p)) == 0)
			 && (p <= ((page->baseAddress))));
		unused = (p - BytesPerWord) - ((page->lastAddress));
		if (unused < minUnused) {
			minUnused = unused;
		}
	}
	return minUnused;
}

	/* CoInterpreter>>#mMethodClass */
sqInt
mMethodClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt methodPointer;
    sqInt offset;

	/* begin methodClassOf: */
	methodPointer = ((mframeHomeMethod(GIV(framePointer)))->methodObject);
	/* begin followLiteral:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(methodPointer))) - 1;
	literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	return ((literal != GIV(nilObj))
	 && (((literal & 1) == 0)
	 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))
		? (assert((numSlotsOf(literal)) > ValueIndex),
			longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord()))))))
		: (/* begin nilObject */
			GIV(nilObj)));
}

	/* CoInterpreter>>#mnuCompilationBreakpointFor: */
void
mnuCompilationBreakpointFor(sqInt selectorOop)
{
	suppressHeartbeatFlag = 1;
	warning("compilation MNU break (heartbeat suppressed)");
}


/*	Lookup the doesNotUnderstand: selector in the class of the argument rcvr.
	Answer either the matching method (cogged if appropriate), or nil, if not
	found. 
 */

	/* CoInterpreter>>#mnuMethodOrNilFor: */
static sqInt NoDbgRegParms
mnuMethodOrNilFor(sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt currentClass;
    sqInt dictionary;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt methodHeader;
    sqInt mnuMethod;
    sqInt mnuSelector;
    sqInt nextSelector;
    sqInt oop;
    sqInt sz;
    sqInt wrapAround;

	assert(!((isOopForwarded(rcvr))));
	if ((rcvr & 1)) {
		/* begin splObj: */
		currentClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			currentClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			currentClass = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	mnuSelector = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		header = longAt(dictionary);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((mnuSelector & 1)
	? (mnuSelector >> 1)
	: (/* begin hashBitsOf: */
		(((usqInt) (longAt(mnuSelector))) >> HashBitsOffset) & HashMaskUnshifted))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				mnuMethod = null;
				goto l10;
			}
			if (nextSelector == mnuSelector) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				mnuMethod = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				goto l10;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					mnuMethod = null;
					goto l10;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		mnuMethod = null;
	l10:	/* end lookupMethodFor:InDictionary: */;
		if (!(mnuMethod == null)) {
			methodHeader = longAt((mnuMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
			if ((!((assert(((methodHeader & 1))
				 || (((((usqInt)methodHeader)) < (startOfMemory()))
				 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
			(methodHeader & 1) == 0)))
			 && (((assert((methodHeader & 1)),
			((((int) methodHeader)) < 0
					? (/* begin literalCountOfAlternateHeader: */
						((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask)
					: (/* begin literalCountOfOriginalHeader: */
						(((usqInt) methodHeader) >> 10) & 0xFF)))) <= maxLiteralCountForCompile)) {
				cogselector(mnuMethod, mnuSelector);
			}
			return mnuMethod;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return null;
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* CoInterpreter>>#moveFramesIn:through:toPage: */
static char * NoDbgRegParms
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    usqInt callerIP;
    int delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    sqInt numArgs;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    char *theSP;


	/* A base frame must have a context for cannotReturn: processing. */
	assert(!(isBaseFrame(theFP)));
	assert(validStackPageBaseFrames());
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(frameHasContext(callerFP));
	assert(isContext(frameContext(callerFP)));
	/* begin ensureFrameIsMarried:SP: */
	theSP = theFP + (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? FoxMFReceiver
	: FoxIFReceiver));
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		theContext = longAt(theFP + FoxThisContext);
		goto l4;
	}
	theContext = marryFrameSP(theFP, theSP);
l4:	/* end ensureFrameIsMarried:SP: */;
	longAtput((newSP = (newPage->baseAddress)), longAt(callerFP + FoxThisContext));
	longAtput((newSP -= BytesPerWord), theContext);
	/* begin frameStackedReceiverOffsetNumArgs: */
	numArgs = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeCogMethod(theFP))->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)(