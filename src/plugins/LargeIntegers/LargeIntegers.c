/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.1746 uuid: 9e4a49eb-8ebe-486d-b6f0-430100efa288
   from
	LargeIntegersPlugin VMMaker.oscog-eem.1746 uuid: 9e4a49eb-8ebe-486d-b6f0-430100efa288
 */
static char __buildInfo[] = "LargeIntegersPlugin VMMaker.oscog-eem.1746 uuid: 9e4a49eb-8ebe-486d-b6f0-430100efa288 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3


/*** Function Prototypes ***/
static sqInt anyBitOfLargeIntfromto(sqInt aBytesOop, sqInt start, sqInt stopArg);
static sqInt cCopyIntValtoBytes(sqInt val, sqInt bytes);
static unsigned char cDigitAddlenwithleninto(unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes);
static sqInt cDigitComparewithlen(unsigned char *pFirst, unsigned char *pSecond, sqInt len);
static int cDigitCopyFromtolen(unsigned char *pFrom, unsigned char *pTo, sqInt len);
static sqInt cDigitDivlenremlenquolen(unsigned char *pDiv, sqInt divLen, unsigned char *pRem, sqInt remLen, unsigned char *pQuo, sqInt quoLen);
static sqInt cDigitHighBitlen(unsigned char *pByte, sqInt len);
static sqInt cDigitLengthOfCSI(sqInt csi);
static sqInt cDigitLshiftfromlentolen(sqInt shiftCount, unsigned char *pFrom, sqInt lenFrom, unsigned char *pTo, sqInt lenTo);
static sqInt cDigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned char *pBytesFirst, sqInt firstLen, unsigned char *pBytesSecond, sqInt secondLen, unsigned char *pBytesThird, sqInt thirdLen, sqInt mInv, unsigned char *pBytesRes);
static unsigned char cDigitMultiplylenwithleninto(unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes);
static sqInt cDigitOfCSIat(sqInt csi, sqInt ix);
static sqInt cDigitOpshortlenlongleninto(sqInt opIndex, unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes);
static int cDigitReplacefromtowithstartingAt(unsigned char *pTo, sqInt start, sqInt stop, unsigned char *pFrom, sqInt repStart);
static sqInt cDigitRshiftfromlentolen(sqInt shiftCount, unsigned char *pFrom, sqInt fromLen, unsigned char *pTo, sqInt toLen);
static sqInt cDigitSublenwithleninto(unsigned char *pByteSmall, sqInt smallLen, unsigned char *pByteLarge, sqInt largeLen, unsigned char *pByteRes);
static sqInt cHighBit(unsigned int uint);
static sqInt createLargeFromSmallInteger(sqInt anOop);
static sqInt digitAddLargewith(sqInt firstInteger, sqInt secondInteger);
static sqInt digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx);
static sqInt digitCompareLargewith(sqInt firstInteger, sqInt secondInteger);
static sqInt digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg);
static sqInt digitLengthOfNonImmediate(sqInt oop);
static sqInt digitLength(sqInt oop);
static sqInt digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, sqInt mInv);
static sqInt digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg);
static sqInt digitOfLargeIntat(sqInt aBytesOop, sqInt ix);
static sqInt digitSizeOfLargeInt(sqInt bytesOop);
static sqInt digitSubLargewith(sqInt firstInteger, sqInt secondInteger);
static sqInt digitLshift(sqInt aBytesOop, sqInt shiftCount);
static sqInt digitRshiftlookfirst(sqInt aBytesOop, sqInt shiftCount, sqInt a);
EXPORT(const char*) getModuleName(void);
static sqInt highBitOfLargeInt(sqInt aBytesOop);
static sqInt isNormalized(sqInt anInteger);
static sqInt largeIntOrIntgrowTo(sqInt oop, sqInt len);
static sqInt largeIntgrowTo(sqInt aBytesObject, sqInt newLen);
static sqInt msg(char *s);
static sqInt normalizeNegative(sqInt aLargeNegativeInteger);
static sqInt normalizePositive(sqInt aLargePositiveInteger);
static sqInt normalize(sqInt aLargeInteger);
EXPORT(sqInt) primAnyBitFromTo(void);
EXPORT(sqInt) primAsLargeInteger(void);
EXPORT(sqInt) primCheckIfCModuleExists(void);
EXPORT(sqInt) primDigitAdd(void);
EXPORT(sqInt) primDigitAddWith(void);
EXPORT(sqInt) primDigitBitAnd(void);
EXPORT(sqInt) primDigitBitLogicWithOp(void);
EXPORT(sqInt) primDigitBitOr(void);
EXPORT(sqInt) primDigitBitShift(void);
EXPORT(sqInt) primDigitBitShiftMagnitude(void);
EXPORT(sqInt) primDigitBitXor(void);
EXPORT(sqInt) primDigitCompare(void);
EXPORT(sqInt) primDigitCompareWith(void);
EXPORT(sqInt) primDigitDivNegative(void);
EXPORT(sqInt) primDigitDivWithNegative(void);
EXPORT(sqInt) primDigitMultiplyNegative(void);
EXPORT(sqInt) primDigitMultiplyWithNegative(void);
EXPORT(sqInt) primDigitSubtract(void);
EXPORT(sqInt) primDigitSubtractWith(void);
EXPORT(sqInt) primGetModuleName(void);
EXPORT(sqInt) primMontgomeryDigitLength(void);
EXPORT(sqInt) primMontgomeryTimesModulo(void);
EXPORT(sqInt) primNormalize(void);
EXPORT(sqInt) primNormalizeNegative(void);
EXPORT(sqInt) primNormalizePositive(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt sqAssert(sqInt aBool);
static sqInt unsafeDigitOfat(sqInt bytesObj, sqInt ix);
EXPORT(sqInt) _primDigitBitShift(void);


/*** Variables ***/
static const int  andOpIndex = 0;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*classArray)(void);
static sqInt (*classLargeNegativeInteger)(void);
static sqInt (*classLargePositiveInteger)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static sqInt (*integerValueOf)(sqInt oop);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*isIntegerObject)(sqInt objectPointer);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stObjectatput)(sqInt array, sqInt index, sqInt value);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*success)(sqInt aBoolean);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt classArray(void);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt fetchClassOf(sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt success(sqInt aBoolean);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"LargeIntegers v1.5 VMMaker.oscog-eem.1746 (i)"
#else
	"LargeIntegers v1.5 VMMaker.oscog-eem.1746 (e)"
#endif
;
static const int  orOpIndex = 1;
static const int  xorOpIndex = 2;



/*	Argument has to be aBytesOop! */
/*	Tests for any magnitude bits in the interval from start to stopArg. */

	/* LargeIntegersPlugin>>#anyBitOfLargeInt:from:to: */
static sqInt
anyBitOfLargeIntfromto(sqInt aBytesOop, sqInt start, sqInt stopArg)
{
	sqInt digit;
	sqInt firstByteIx;
	sqInt ix;
	sqInt lastByteIx;
	sqInt leftShift;
	sqInt magnitude;
	sqInt mask;
	sqInt rightShift;
	sqInt stop;

	/* missing DebugCode */;
	if ((start < 1) || (stopArg < 1)) {
		return primitiveFail();
	}
	magnitude = aBytesOop;
	stop = ((stopArg < (cDigitHighBitlen(firstIndexableField(magnitude), slotSizeOf(magnitude)))) ? stopArg : (cDigitHighBitlen(firstIndexableField(magnitude), slotSizeOf(magnitude))));
	if (start > stop) {
		return 0;
	}
	firstByteIx = ((start - 1) / 8) + 1;
	lastByteIx = ((stop - 1) / 8) + 1;
	rightShift = (start - 1) % 8;
	leftShift = 7 - ((stop - 1) % 8);
	if (firstByteIx == lastByteIx) {
		mask = (0xFFL << rightShift) & (((usqInt) 0xFF) >> leftShift);
		/* begin digitOfLargeInt:at: */
		if (firstByteIx > (slotSizeOf(magnitude))) {
			digit = 0;
			goto l1;
		}
		else {
			digit = (((unsigned char *) (firstIndexableField(magnitude))))[firstByteIx - 1];
			goto l1;
		}
	l1:	/* end digitOfLargeInt:at: */;
		return (digit & mask) != 0;
	}
	if ((((usqInt) (digitOfLargeIntat(magnitude, firstByteIx))) >> rightShift) != 0) {
		return 1;
	}
	for (ix = (firstByteIx + 1); ix < lastByteIx; ix += 1) {
		if ((digitOfLargeIntat(magnitude, ix)) != 0) {
			return 1;
		}
	}
	if ((((digitOfLargeIntat(magnitude, lastByteIx)) << leftShift) & 0xFF) != 0) {
		return 1;
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cCopyIntVal:toBytes: */
static sqInt
cCopyIntValtoBytes(sqInt val, sqInt bytes)
{
	sqInt ix;
	sqInt ixLimiT;
	unsigned char *pByte;

	pByte = firstIndexableField(bytes);
	for (ix = 1, ixLimiT = (cDigitLengthOfCSI(val)); ix <= ixLimiT; ix += 1) {
		pByte[ix - 1] = ((((usqInt) ((val < 0
	? 0 - val
	: val))) >> ((ix - 1) * 8)) & 0xFF);
	}
	return 0;
}


/*	pByteRes len = longLen; returns over.. */

	/* LargeIntegersPlugin>>#cDigitAdd:len:with:len:into: */
static unsigned char
cDigitAddlenwithleninto(unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes)
{
	unsigned int accum;
	sqInt i;
	sqInt limit;

	accum = 0;
	limit = shortLen - 1;
	for (i = 0; i <= limit; i += 1) {
		accum = ((((usqInt) accum) >> 8) + (pByteShort[i])) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	limit = longLen - 1;
	for (i = shortLen; i <= limit; i += 1) {
		accum = (((usqInt) accum) >> 8) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	return ((usqInt) accum) >> 8;
}


/*	Precondition: pFirst len = pSecond len. */

	/* LargeIntegersPlugin>>#cDigitCompare:with:len: */
static sqInt
cDigitComparewithlen(unsigned char *pFirst, unsigned char *pSecond, sqInt len)
{
	unsigned int firstDigit;
	sqInt ix;
	unsigned int secondDigit;

	ix = len - 1;
	while (ix >= 0) {
		if (((secondDigit = pSecond[ix])) != ((firstDigit = pFirst[ix]))) {
			if (secondDigit < firstDigit) {
				return 1;
			}
			else {
				return -1;
			}
		}
		ix -= 1;
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitCopyFrom:to:len: */
static int
cDigitCopyFromtolen(unsigned char *pFrom, unsigned char *pTo, sqInt len)
{
	sqInt i;
	sqInt limit;

	limit = len - 1;
	for (i = 0; i <= limit; i += 1) {
		pTo[i] = (pFrom[i]);
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitDiv:len:rem:len:quo:len: */
static sqInt
cDigitDivlenremlenquolen(unsigned char *pDiv, sqInt divLen, unsigned char *pRem, sqInt remLen, unsigned char *pQuo, sqInt quoLen)
{
	unsigned int a;
	unsigned int b;
	sqInt cond;
	unsigned int dh;
	sqInt dl;
	unsigned int dnh;
	unsigned int hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	unsigned int lo;
	unsigned int mul;
	unsigned int q;
	sqInt ql;
	unsigned int r1r2;
	unsigned int r3;
	unsigned int t;


	/* Last actual byte of data (ST ix) */
	dl = divLen - 1;
	ql = quoLen;
	dh = pDiv[dl - 1];
	if (dl == 1) {
		dnh = 0;
	}
	else {
		dnh = pDiv[dl - 2];
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two digits of rem by dh. */
		/* The estimate is q = qhi*16r100+qlo, where qhi and qlo are unsigned char. */

		/* r1 := rem digitAt: j. */
		j = (remLen + 1) - k;
		if ((pRem[j - 1]) == dh) {
			q = 0xFF;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh. */
			/* r2 := (rem digitAt: j - 2). */
			r1r2 = pRem[j - 1];
			r1r2 = (r1r2 << 8) + (pRem[j - 2]);
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */
			q = r1r2 / dh;
			mul = q * dnh;
			hi = ((usqInt) mul) >> 8;

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */
			lo = mul & 0xFF;
			if (j < 3) {
				r3 = 0;
			}
			else {
				r3 = pRem[j - 3];
			}
			while (1) {
				if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */
					q -= 1;
					if (hi == 0) {

						/* since hi is unsigned we must have this guard */
						cond = 0;
					}
					else {
						if (lo < dnh) {
							hi -= 1;
							lo = (lo + 256) - dnh;
						}
						else {
							lo -= dnh;
						}
						cond = hi >= dh;
					}
				}
				else {
					cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
			hi = (pDiv[i - 1]) * (((usqInt) q) >> 8);
			lo = (pDiv[i - 1]) * (q & 0xFF);
			b = ((pRem[l - 1]) - a) - (lo & 0xFF);
			pRem[l - 1] = (b & 0xFF);

			/* This is a possible replacement to simulate arithmetic shift (preserving sign of b) */
			/* b := b >> 8 bitOr: (0 - (b >> ((interpreterProxy sizeof: b)*8 */
			/* CHAR_BIT */
			/* -1)) << 8). */
			b = ((signed)b >> 8);
			a = (hi + (((usqInt) lo) >> 8)) - b;
			l += 1;
		}
		if (a > 0) {

			/* Add div back into rem, decrease q by 1 */
			q -= 1;
			l = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
				a = ((((usqInt) a) >> 8) + (pRem[l - 1])) + (pDiv[i - 1]);
				pRem[l - 1] = (a & 0xFF);
				l += 1;
			}
		}
		pQuo[quoLen - k] = q;
	}
	return 0;
}


/*	Answer the index (in bits) of the high order bit of the receiver, or zero
	if the 
	receiver is zero. This method is allowed (and needed) for 
	LargeNegativeIntegers as well, since Squeak's LargeIntegers are 
	sign/magnitude. */

	/* LargeIntegersPlugin>>#cDigitHighBit:len: */
static sqInt
cDigitHighBitlen(unsigned char *pByte, sqInt len)
{
	unsigned int lastDigit;
	sqInt realLength;

	realLength = len;
	while (((lastDigit = pByte[realLength - 1])) == 0) {
		if (((realLength -= 1)) == 0) {
			return 0;
		}
	}
	return (cHighBit(lastDigit)) + (8 * (realLength - 1));
}


/*	Answer the number of bytes required to represent the value of a
	CSmallInteger. 
 */

	/* LargeIntegersPlugin>>#cDigitLengthOfCSI: */
static sqInt
cDigitLengthOfCSI(sqInt csi)
{
	if (csi >= 0) {
		if (csi < 256) {
			return 1;
		}
		if (csi < 65536) {
			return 2;
		}
		if (csi < 0x1000000) {
			return 3;
		}
		
#    if BytesPerOop == 4
		return 4;

#    else /* BytesPerOop == 4 */
		if (csi < 0x100000000ULL) {
			return 4;
		}
		if (csi < 0x10000000000ULL) {
			return 5;
		}
		if (csi < 0x1000000000000ULL) {
			return 6;
		}
		if (csi < 0x100000000000000ULL) {
			return 7;
		}
		return 8;

#    endif /* BytesPerOop == 4 */

	}
	if (csi > -256) {
		return 1;
	}
	if (csi > -65536) {
		return 2;
	}
	if (csi > -16777216) {
		return 3;
	}
	
#  if BytesPerOop == 4
	return 4;

#  else /* BytesPerOop == 4 */
	if (csi > -4294967296) {
		return 4;
	}
	if (csi > -1099511627776) {
		return 5;
	}
	if (csi > -281474976710656) {
		return 6;
	}
	if (csi > -72057594037927936) {
		return 7;
	}
	return 8;

#  endif /* BytesPerOop == 4 */

	return 0;
}


/*	C indexed! */

	/* LargeIntegersPlugin>>#cDigitLshift:from:len:to:len: */
static sqInt
cDigitLshiftfromlentolen(sqInt shiftCount, unsigned char *pFrom, sqInt lenFrom, unsigned char *pTo, sqInt lenTo)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt i;
	sqInt limit;
	sqInt rshift;

	digitShift = shiftCount / 8;
	bitShift = shiftCount % 8;
	limit = digitShift - 1;
	for (i = 0; i <= limit; i += 1) {
		pTo[i] = 0;
	}
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		return cDigitCopyFromtolen(pFrom, pTo + digitShift, ((lenTo - 1) - digitShift) + 1);
	}
	rshift = 8 - bitShift;
	carry = 0;
	limit = lenFrom - 1;
	for (i = 0; i <= limit; i += 1) {
		digit = pFrom[i];
		pTo[i + digitShift] = ((carry | (digit << bitShift)) & 0xFF);
		carry = ((usqInt) digit) >> rshift;
	}
	if (!(carry == 0)) {
		pTo[lenTo - 1] = carry;
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
static sqInt
cDigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned char *pBytesFirst, sqInt firstLen, unsigned char *pBytesSecond, sqInt secondLen, unsigned char *pBytesThird, sqInt thirdLen, sqInt mInv, unsigned char *pBytesRes)
{
	unsigned int accum;
	sqInt i;
	sqInt k;
	unsigned char lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char u;

	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
		accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
			accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
		accum = pBytesRes[0];
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */
		accum = 0;
		for (i = 0; i <= limit3; i += 1) {
			accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = accum;
			accum = ((signed)accum >> 8);
		}
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitMultiply:len:with:len:into: */
static unsigned char
cDigitMultiplylenwithleninto(unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes)
{
	unsigned int ab;
	unsigned int carry;
	unsigned int digit;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;

	if ((shortLen == 1)
	 && ((pByteShort[0]) == 0)) {
		return 0;
	}
	if ((longLen == 1)
	 && ((pByteLong[0]) == 0)) {
		return 0;
	}
	limitShort = shortLen - 1;
	limitLong = longLen - 1;
	for (i = 0; i <= limitShort; i += 1) {
		if (((digit = pByteShort[i])) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=0377, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=0377, k=i+j (C) (?) */
			carry = 0;
			for (j = 0; j <= limitLong; j += 1) {
				ab = pByteLong[j];
				ab = ((ab * digit) + carry) + (pByteRes[k]);
				carry = ((usqInt) ab) >> 8;
				pByteRes[k] = (ab & 0xFF);
				k += 1;
			}
			pByteRes[k] = carry;
		}
	}
	return 0;
}


/*	Answer the value of an indexable field in the receiver. 
	LargePositiveInteger uses bytes of base two number, and each is a 
	'digit' base 256. */
/*	ST indexed! */

	/* LargeIntegersPlugin>>#cDigitOfCSI:at: */
static sqInt
cDigitOfCSIat(sqInt csi, sqInt ix)
{
	return (((usqInt) ((csi < 0
		? 0 - csi
		: csi))) >> ((ix - 1) * 8)) & 0xFF;
}


/*	pByteRes len = longLen. */

	/* LargeIntegersPlugin>>#cDigitOp:short:len:long:len:into: */
static sqInt
cDigitOpshortlenlongleninto(sqInt opIndex, unsigned char *pByteShort, sqInt shortLen, unsigned char *pByteLong, sqInt longLen, unsigned char *pByteRes)
{
	sqInt i;
	sqInt limit;

	limit = shortLen - 1;
	if (opIndex == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) & (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = 0;
		}
		return 0;
	}
	if (opIndex == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) | (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = (pByteLong[i]);
		}
		return 0;
	}
	if (opIndex == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) ^ (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = (pByteLong[i]);
		}
		return 0;
	}
	return primitiveFail();
}


/*	C indexed! */

	/* LargeIntegersPlugin>>#cDigitReplace:from:to:with:startingAt: */
static int
cDigitReplacefromtowithstartingAt(unsigned char *pTo, sqInt start, sqInt stop, unsigned char *pFrom, sqInt repStart)
{
	return cDigitCopyFromtolen(pFrom + repStart, pTo + start, (stop - start) + 1);
}

	/* LargeIntegersPlugin>>#cDigitRshift:from:len:to:len: */
static sqInt
cDigitRshiftfromlentolen(sqInt shiftCount, unsigned char *pFrom, sqInt fromLen, unsigned char *pTo, sqInt toLen)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt j;
	sqInt leftShift;
	sqInt limit;
	sqInt start;

	digitShift = shiftCount / 8;
	bitShift = shiftCount % 8;
	if (bitShift == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		return cDigitCopyFromtolen(pFrom + digitShift, pTo, ((toLen - 1)) + 1);
	}
	leftShift = 8 - bitShift;
	carry = ((usqInt) (pFrom[digitShift])) >> bitShift;
	start = digitShift + 1;
	limit = fromLen - 1;
	for (j = start; j <= limit; j += 1) {
		digit = pFrom[j];
		pTo[j - start] = ((carry | (digit << leftShift)) & 0xFF);
		carry = ((usqInt) digit) >> bitShift;
	}
	if (!(carry == 0)) {
		pTo[toLen - 1] = carry;
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitSub:len:with:len:into: */
static sqInt
cDigitSublenwithleninto(unsigned char *pByteSmall, sqInt smallLen, unsigned char *pByteLarge, sqInt largeLen, unsigned char *pByteRes)
{
	sqInt i;
	sqInt z;


	/* Loop invariant is -1<=z<=1 */
	z = 0;
	for (i = 0; i < smallLen; i += 1) {
		z = (z + (pByteLarge[i])) - (pByteSmall[i]);
		pByteRes[i] = z;
		z = ((signed)z >> 8);
	}
	for (i = smallLen; i < largeLen; i += 1) {
		z += pByteLarge[i];
		pByteRes[i] = z;
		z = ((signed)z >> 8);
	}
	return 0;
}


/*	Answer the index of the high order bit of the argument, or zero if the 
	argument is zero. */
/*	For 64 bit uints there could be added a 32-shift. */

	/* LargeIntegersPlugin>>#cHighBit: */
static sqInt
cHighBit(unsigned int uint)
{
	sqInt bitNo;
	unsigned int shifted;

	shifted = uint;
	bitNo = 0;
	if (!(shifted < (1L << 16))) {
		shifted = ((usqInt) shifted >> 16);
		bitNo += 16;
	}
	if (!(shifted < (1L << 8))) {
		shifted = ((usqInt) shifted >> 8);
		bitNo += 8;
	}
	if (!(shifted < (1L << 4))) {
		shifted = ((usqInt) shifted >> 4);
		bitNo += 4;
	}
	if (!(shifted < (1L << 2))) {
		shifted = ((usqInt) shifted >> 2);
		bitNo += 2;
	}
	if (!(shifted < (1L << 1))) {
		shifted = ((usqInt) shifted >> 1);
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	anOop has to be a SmallInteger! */

	/* LargeIntegersPlugin>>#createLargeFromSmallInteger: */
static sqInt
createLargeFromSmallInteger(sqInt anOop)
{
	sqInt byte;
	sqInt class;
	sqInt ix;
	unsigned char *pByte;
	sqInt res;
	sqInt size;
	sqInt val;

	val = integerValueOf(anOop);
	if (val < 0) {
		class = classLargeNegativeInteger();
	}
	else {
		class = classLargePositiveInteger();
	}
	size = cDigitLengthOfCSI(val);
	res = instantiateClassindexableSize(class, size);
	pByte = firstIndexableField(res);
	for (ix = 1; ix <= size; ix += 1) {
		byte = (((usqInt) ((val < 0
			? 0 - val
			: val))) >> ((ix - 1) * 8)) & 0xFF;
		pByte[ix - 1] = byte;
	}
	return res;
}


/*	Does not need to normalize! */

	/* LargeIntegersPlugin>>#digitAddLarge:with: */
static sqInt
digitAddLargewith(sqInt firstInteger, sqInt secondInteger)
{
	unsigned int accum;
	sqInt firstLen;
	sqInt i;
	sqInt limit;
	sqInt longInt;
	sqInt longLen;
	sqInt newSum;
	unsigned char over;
	unsigned char *pByteLong;
	unsigned char *pByteRes;
	unsigned char *pByteShort;
	sqInt resClass;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;
	sqInt sum;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	resClass = fetchClassOf(firstInteger);
	if (firstLen <= secondLen) {
		shortInt = firstInteger;
		shortLen = firstLen;
		longInt = secondInteger;
		longLen = secondLen;
	}
	else {
		shortInt = secondInteger;
		shortLen = secondLen;
		longInt = firstInteger;
		longLen = firstLen;
	}
	
#if SPURVM
	sum = instantiateClassindexableSize(resClass, longLen);

#else /* SPURVM */
	pushRemappableOop(shortInt);
	pushRemappableOop(longInt);
	sum = instantiateClassindexableSize(resClass, longLen);
	longInt = popRemappableOop();
	shortInt = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitAdd:len:with:len:into: */
	pByteShort = ((unsigned char *) (firstIndexableField(shortInt)));
	pByteLong = ((unsigned char *) (firstIndexableField(longInt)));
	pByteRes = ((unsigned char *) (firstIndexableField(sum)));
	accum = 0;
	limit = shortLen - 1;
	for (i = 0; i <= limit; i += 1) {
		accum = ((((usqInt) accum) >> 8) + (pByteShort[i])) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	limit = longLen - 1;
	for (i = shortLen; i <= limit; i += 1) {
		accum = (((usqInt) accum) >> 8) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	over = ((usqInt) accum) >> 8;
	if (over > 0) {

		/* sum := sum growby: 1. */
		
#if SPURVM
		newSum = instantiateClassindexableSize(resClass, longLen + 1);

#else /* SPURVM */
		pushRemappableOop(sum);
		newSum = instantiateClassindexableSize(resClass, longLen + 1);
		sum = popRemappableOop()
#endif /* SPURVM */
;
		cDigitCopyFromtolen(firstIndexableField(sum), firstIndexableField(newSum), longLen);

		/* C index! */
		sum = newSum;
		(((unsigned char *) (firstIndexableField(sum))))[longLen] = over;
	}
	return sum;
}


/*	Bit logic here is only implemented for positive integers or Zero;
	if rec or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#digitBitLogic:with:opIndex: */
static sqInt
digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx)
{
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt limit;
	sqInt longLarge;
	sqInt longLen;
	unsigned char *pByteLong;
	unsigned char *pByteRes;
	unsigned char *pByteShort;
	sqInt result;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt shortLarge;
	sqInt shortLen;

	if (isIntegerObject(firstInteger)) {
		if ((integerValueOf(firstInteger)) < 0) {
			return primitiveFail();
		}
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		if ((fetchClassOf(firstInteger)) == (classLargeNegativeInteger())) {
			return primitiveFail();
		}
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {
		if ((integerValueOf(secondInteger)) < 0) {
			return primitiveFail();
		}
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		if ((fetchClassOf(secondInteger)) == (classLargeNegativeInteger())) {
			return primitiveFail();
		}
		secondLarge = secondInteger;
	}
	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	if (firstLen < secondLen) {
		shortLen = firstLen;
		shortLarge = firstLarge;
		longLen = secondLen;
		longLarge = secondLarge;
	}
	else {
		shortLen = secondLen;
		shortLarge = secondLarge;
		longLen = firstLen;
		longLarge = firstLarge;
	}
	
#if SPURVM
	result = instantiateClassindexableSize(classLargePositiveInteger(), longLen);

#else /* SPURVM */
	pushRemappableOop(shortLarge);
	pushRemappableOop(longLarge);
	result = instantiateClassindexableSize(classLargePositiveInteger(), longLen);
	longLarge = popRemappableOop();
	shortLarge = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitOp:short:len:long:len:into: */
	pByteShort = ((unsigned char *) (firstIndexableField(shortLarge)));
	pByteLong = ((unsigned char *) (firstIndexableField(longLarge)));
	pByteRes = ((unsigned char *) (firstIndexableField(result)));
	limit = shortLen - 1;
	if (opIx == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) & (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = 0;
		}
		goto l1;
	}
	if (opIx == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) | (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = (pByteLong[i]);
		}
		goto l1;
	}
	if (opIx == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pByteRes[i] = ((pByteShort[i]) ^ (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pByteRes[i] = (pByteLong[i]);
		}
		goto l1;
	}
	primitiveFail();
l1:	/* end cDigitOp:short:len:long:len:into: */;
	if (failed()) {
		return 0;
	}
	return normalizePositive(result);
}


/*	Compare the magnitude of firstInteger with that of secondInteger. 
	Return a code of 1, 0, -1 for firstInteger >, = , < secondInteger */

	/* LargeIntegersPlugin>>#digitCompareLarge:with: */
static sqInt
digitCompareLargewith(sqInt firstInteger, sqInt secondInteger)
{
	sqInt firstLen;
	sqInt secondLen;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (secondLen != firstLen) {
		if (secondLen > firstLen) {
			return integerObjectOf(-1);
		}
		else {
			return integerObjectOf(1);
		}
	}
	return integerObjectOf((cDigitComparewithlen(firstIndexableField(firstInteger), firstIndexableField(secondInteger), firstLen)));
}


/*	Does not normalize. */
/*	Division by zero has to be checked in caller. */

	/* LargeIntegersPlugin>>#digitDivLarge:with:negative: */
static sqInt
digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg)
{
	unsigned int a;
	unsigned int b;
	sqInt cond;
	sqInt d;
	unsigned int dh;
	sqInt div;
	sqInt divLen;
	sqInt dl;
	unsigned int dnh;
	sqInt firstLen;
	unsigned int hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	sqInt l1;
	unsigned int lo;
	unsigned int mul;
	unsigned char *pDiv;
	unsigned char *pQuo;
	unsigned char *pRem;
	unsigned int q;
	sqInt ql;
	sqInt quo;
	sqInt quoLen;
	unsigned int r1r2;
	unsigned int r3;
	sqInt rem;
	sqInt remLen;
	sqInt result;
	sqInt resultClass;
	sqInt secondLen;
	unsigned int t;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (neg) {
		resultClass = classLargeNegativeInteger();
	}
	else {
		resultClass = classLargePositiveInteger();
	}
	l = (firstLen - secondLen) + 1;
	if (l <= 0) {
		
#if SPURVM
		result = instantiateClassindexableSize(classArray(), 2);

#else /* SPURVM */
		pushRemappableOop(firstInteger);
		result = instantiateClassindexableSize(classArray(), 2);
		firstInteger = popRemappableOop()
#endif /* SPURVM */
;
		stObjectatput(result,1,(integerObjectOf(0)));
		stObjectatput(result,2,firstInteger);
		return result;
	}
	d = 8 - (cHighBit((((unsigned char *) (firstIndexableField(secondInteger))))[secondLen - 1]));
	
#if SPURVM
	div = digitLshift(secondInteger, d);
	div = largeIntOrIntgrowTo(div, (digitLength(div)) + 1);

#else /* SPURVM */
	pushRemappableOop(firstInteger);
	div = digitLshift(secondInteger, d);
	div = largeIntOrIntgrowTo(div, (digitLength(div)) + 1);
	firstInteger = popRemappableOop()
#endif /* SPURVM */
;
	
#if SPURVM
	rem = digitLshift(firstInteger, d);
	if ((digitLength(rem)) == firstLen) {
		rem = largeIntOrIntgrowTo(rem, firstLen + 1);
	}

#else /* SPURVM */
	pushRemappableOop(div);
	rem = digitLshift(firstInteger, d);
	if ((digitLength(rem)) == firstLen) {
		rem = largeIntOrIntgrowTo(rem, firstLen + 1);
	}
	div = popRemappableOop()
#endif /* SPURVM */
;
	
#if SPURVM
	quo = instantiateClassindexableSize(resultClass, l);

#else /* SPURVM */
	pushRemappableOop(div);
	pushRemappableOop(rem);
	quo = instantiateClassindexableSize(resultClass, l);
	rem = popRemappableOop();
	div = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitDiv:len:rem:len:quo:len: */
	pDiv = ((unsigned char *) (firstIndexableField(div)));
	/* begin digitLength: */
	if (isIntegerObject(div)) {
		divLen = cDigitLengthOfCSI(integerValueOf(div));
		goto l2;
	}
	else {
		divLen = slotSizeOf(div);
		goto l2;
	}
l2:	/* end digitLength: */;
	pRem = ((unsigned char *) (firstIndexableField(rem)));
	/* begin digitLength: */
	if (isIntegerObject(rem)) {
		remLen = cDigitLengthOfCSI(integerValueOf(rem));
		goto l3;
	}
	else {
		remLen = slotSizeOf(rem);
		goto l3;
	}
l3:	/* end digitLength: */;
	pQuo = ((unsigned char *) (firstIndexableField(quo)));
	/* begin digitLength: */
	if (isIntegerObject(quo)) {
		quoLen = cDigitLengthOfCSI(integerValueOf(quo));
		goto l4;
	}
	else {
		quoLen = slotSizeOf(quo);
		goto l4;
	}
l4:	/* end digitLength: */;

	/* Last actual byte of data (ST ix) */
	dl = divLen - 1;
	ql = quoLen;
	dh = pDiv[dl - 1];
	if (dl == 1) {
		dnh = 0;
	}
	else {
		dnh = pDiv[dl - 2];
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two digits of rem by dh. */
		/* The estimate is q = qhi*16r100+qlo, where qhi and qlo are unsigned char. */

		/* r1 := rem digitAt: j. */
		j = (remLen + 1) - k;
		if ((pRem[j - 1]) == dh) {
			q = 0xFF;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh. */
			/* r2 := (rem digitAt: j - 2). */
			r1r2 = pRem[j - 1];
			r1r2 = (r1r2 << 8) + (pRem[j - 2]);
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */
			q = r1r2 / dh;
			mul = q * dnh;
			hi = ((usqInt) mul) >> 8;

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */
			lo = mul & 0xFF;
			if (j < 3) {
				r3 = 0;
			}
			else {
				r3 = pRem[j - 3];
			}
			while (1) {
				if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */
					q -= 1;
					if (hi == 0) {

						/* since hi is unsigned we must have this guard */
						cond = 0;
					}
					else {
						if (lo < dnh) {
							hi -= 1;
							lo = (lo + 256) - dnh;
						}
						else {
							lo -= dnh;
						}
						cond = hi >= dh;
					}
				}
				else {
					cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l1 = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
			hi = (pDiv[i - 1]) * (((usqInt) q) >> 8);
			lo = (pDiv[i - 1]) * (q & 0xFF);
			b = ((pRem[l1 - 1]) - a) - (lo & 0xFF);
			pRem[l1 - 1] = (b & 0xFF);

			/* This is a possible replacement to simulate arithmetic shift (preserving sign of b) */
			/* b := b >> 8 bitOr: (0 - (b >> ((interpreterProxy sizeof: b)*8 */
			/* CHAR_BIT */
			/* -1)) << 8). */
			b = ((signed)b >> 8);
			a = (hi + (((usqInt) lo) >> 8)) - b;
			l1 += 1;
		}
		if (a > 0) {

			/* Add div back into rem, decrease q by 1 */
			q -= 1;
			l1 = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
				a = ((((usqInt) a) >> 8) + (pRem[l1 - 1])) + (pDiv[i - 1]);
				pRem[l1 - 1] = (a & 0xFF);
				l1 += 1;
			}
		}
		pQuo[quoLen - k] = q;
	}
	
#if SPURVM
	rem = digitRshiftlookfirst(rem, d, (digitLength(div)) - 1);

#else /* SPURVM */
	pushRemappableOop(quo);
	rem = digitRshiftlookfirst(rem, d, (digitLength(div)) - 1);
	quo = popRemappableOop()
#endif /* SPURVM */
;
	
#if SPURVM
	result = instantiateClassindexableSize(classArray(), 2);

#else /* SPURVM */
	pushRemappableOop(quo);
	pushRemappableOop(rem);
	result = instantiateClassindexableSize(classArray(), 2);
	rem = popRemappableOop();
	quo = popRemappableOop()
#endif /* SPURVM */
;
	stObjectatput(result,1,quo);
	stObjectatput(result,2,rem);
	return result;
}

	/* LargeIntegersPlugin>>#digitLengthOfNonImmediate: */
static sqInt
digitLengthOfNonImmediate(sqInt oop)
{
	return slotSizeOf(oop);
}

	/* LargeIntegersPlugin>>#digitLength: */
static sqInt
digitLength(sqInt oop)
{
	if (isIntegerObject(oop)) {
		return cDigitLengthOfCSI(integerValueOf(oop));
	}
	else {
		return slotSizeOf(oop);
	}
}

	/* LargeIntegersPlugin>>#digitMontgomery:times:modulo:mInvModB: */
static sqInt
digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, sqInt mInv)
{
	unsigned int accum;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned char lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char *pBytesFirst;
	unsigned char *pBytesRes;
	unsigned char *pBytesSecond;
	unsigned char *pBytesThird;
	sqInt prod;
	sqInt secondLen;
	sqInt thirdLen;
	unsigned char u;

	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	thirdLen = slotSizeOf(thirdLarge);
	if (!(firstLen <= thirdLen)) {
		return primitiveFail();
	}
	if (!(secondLen <= thirdLen)) {
		return primitiveFail();
	}
	if (!((mInv >= 0)
		 && (mInv <= 0xFF))) {
		return primitiveFail();
	}
	
#if SPURVM
	prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);

#else /* SPURVM */
	pushRemappableOop(firstLarge);
	pushRemappableOop(secondLarge);
	pushRemappableOop(thirdLarge);
	prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);
	thirdLarge = popRemappableOop();
	secondLarge = popRemappableOop();
	firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
	pBytesFirst = ((unsigned char *) (firstIndexableField(firstLarge)));
	pBytesSecond = ((unsigned char *) (firstIndexableField(secondLarge)));
	pBytesThird = ((unsigned char *) (firstIndexableField(thirdLarge)));
	pBytesRes = ((unsigned char *) (firstIndexableField(prod)));
	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
		accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
			accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
		accum = pBytesRes[0];
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */
		accum = 0;
		for (i = 0; i <= limit3; i += 1) {
			accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = accum;
			accum = ((signed)accum >> 8);
		}
	}
	return normalizePositive(prod);
}


/*	Normalizes. */

	/* LargeIntegersPlugin>>#digitMultiplyLarge:with:negative: */
static sqInt
digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg)
{
	unsigned int ab;
	unsigned int carry;
	unsigned int digit;
	sqInt firstLen;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;
	sqInt longInt;
	sqInt longLen;
	unsigned char *pByteLong;
	unsigned char *pByteRes;
	unsigned char *pByteShort;
	sqInt prod;
	sqInt resultClass;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (firstLen <= secondLen) {
		shortInt = firstInteger;
		shortLen = firstLen;
		longInt = secondInteger;
		longLen = secondLen;
	}
	else {
		shortInt = secondInteger;
		shortLen = secondLen;
		longInt = firstInteger;
		longLen = firstLen;
	}
	if (neg) {
		resultClass = classLargeNegativeInteger();
	}
	else {
		resultClass = classLargePositiveInteger();
	}
	
#if SPURVM
	prod = instantiateClassindexableSize(resultClass, longLen + shortLen);

#else /* SPURVM */
	pushRemappableOop(shortInt);
	pushRemappableOop(longInt);
	prod = instantiateClassindexableSize(resultClass, longLen + shortLen);
	longInt = popRemappableOop();
	shortInt = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitMultiply:len:with:len:into: */
	pByteShort = ((unsigned char *) (firstIndexableField(shortInt)));
	pByteLong = ((unsigned char *) (firstIndexableField(longInt)));
	pByteRes = ((unsigned char *) (firstIndexableField(prod)));
	if ((shortLen == 1)
	 && ((pByteShort[0]) == 0)) {
		goto l1;
	}
	if ((longLen == 1)
	 && ((pByteLong[0]) == 0)) {
		goto l1;
	}
	limitShort = shortLen - 1;
	limitLong = longLen - 1;
	for (i = 0; i <= limitShort; i += 1) {
		if (((digit = pByteShort[i])) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=0377, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=0377, k=i+j (C) (?) */
			carry = 0;
			for (j = 0; j <= limitLong; j += 1) {
				ab = pByteLong[j];
				ab = ((ab * digit) + carry) + (pByteRes[k]);
				carry = ((usqInt) ab) >> 8;
				pByteRes[k] = (ab & 0xFF);
				k += 1;
			}
			pByteRes[k] = carry;
		}
	}
l1:	/* end cDigitMultiply:len:with:len:into: */;
	/* begin normalize: */
	/* missing DebugCode */;
	if ((fetchClassOf(prod)) == (classLargePositiveInteger())) {
		return normalizePositive(prod);
	}
	else {
		return normalizeNegative(prod);
	}
}


/*	Argument has to be aLargeInteger! */

	/* LargeIntegersPlugin>>#digitOfLargeInt:at: */
static sqInt
digitOfLargeIntat(sqInt aBytesOop, sqInt ix)
{
	if (ix > (slotSizeOf(aBytesOop))) {
		return 0;
	}
	else {
		return (((unsigned char *) (firstIndexableField(aBytesOop))))[ix - 1];
	}
}


/*	Precondition: bytesOop is not anInteger and a bytes object. */

	/* LargeIntegersPlugin>>#digitSizeOfLargeInt: */
static sqInt
digitSizeOfLargeInt(sqInt bytesOop)
{
	return slotSizeOf(bytesOop);
}


/*	Normalizes. */

	/* LargeIntegersPlugin>>#digitSubLarge:with: */
static sqInt
digitSubLargewith(sqInt firstInteger, sqInt secondInteger)
{
	sqInt firstLen;
	sqInt firstNeg;
	sqInt i;
	sqInt larger;
	sqInt largerLen;
	sqInt neg;
	unsigned char *pByteLarge;
	unsigned char *pByteRes;
	unsigned char *pByteSmall;
	sqInt res;
	sqInt resLen;
	sqInt secondLen;
	sqInt smaller;
	sqInt smallerLen;
	sqInt z;

	firstNeg = (fetchClassOf(firstInteger)) == (classLargeNegativeInteger());
	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (firstLen == secondLen) {
		while ((firstLen > 1)
		 && ((digitOfLargeIntat(firstInteger, firstLen)) == (digitOfLargeIntat(secondInteger, firstLen)))) {
			firstLen -= 1;
		}
		secondLen = firstLen;
	}
	if ((firstLen < secondLen)
	 || ((firstLen == secondLen)
	 && ((digitOfLargeIntat(firstInteger, firstLen)) < (digitOfLargeIntat(secondInteger, firstLen))))) {
		larger = secondInteger;
		largerLen = secondLen;
		smaller = firstInteger;
		smallerLen = firstLen;
		neg = firstNeg == 0;
	}
	else {
		larger = firstInteger;
		largerLen = firstLen;
		smaller = secondInteger;
		smallerLen = secondLen;
		neg = firstNeg;
	}
	resLen = largerLen;
	
#if SPURVM
	res = instantiateClassindexableSize((neg
		? classLargeNegativeInteger()
		: classLargePositiveInteger()), resLen);

#else /* SPURVM */
	pushRemappableOop(smaller);
	pushRemappableOop(larger);
	res = instantiateClassindexableSize((neg
		? classLargeNegativeInteger()
		: classLargePositiveInteger()), resLen);
	larger = popRemappableOop();
	smaller = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitSub:len:with:len:into: */
	pByteSmall = ((unsigned char *) (firstIndexableField(smaller)));
	pByteLarge = ((unsigned char *) (firstIndexableField(larger)));
	pByteRes = ((unsigned char *) (firstIndexableField(res)));

	/* Loop invariant is -1<=z<=1 */
	z = 0;
	for (i = 0; i < smallerLen; i += 1) {
		z = (z + (pByteLarge[i])) - (pByteSmall[i]);
		pByteRes[i] = z;
		z = ((signed)z >> 8);
	}
	for (i = smallerLen; i < largerLen; i += 1) {
		z += pByteLarge[i];
		pByteRes[i] = z;
		z = ((signed)z >> 8);
	}
	return (neg
		? normalizeNegative(res)
		: normalizePositive(res));
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#digit:Lshift: */
static sqInt
digitLshift(sqInt aBytesOop, sqInt shiftCount)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt highBit;
	sqInt i;
	sqInt limit;
	sqInt newBytes;
	sqInt newLen;
	sqInt oldLen;
	unsigned char *pFrom;
	unsigned char *pTo;
	sqInt rshift;

	oldLen = slotSizeOf(aBytesOop);
	if (((highBit = cDigitHighBitlen(firstIndexableField(aBytesOop), oldLen))) == 0) {
		return integerObjectOf(0);
	}
	newLen = ((highBit + shiftCount) + 7) / 8;
	
#if SPURVM
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesOop), newLen);

#else /* SPURVM */
	pushRemappableOop(aBytesOop);
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesOop), newLen);
	aBytesOop = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitLshift:from:len:to:len: */
	pFrom = ((unsigned char *) (firstIndexableField(aBytesOop)));
	pTo = ((unsigned char *) (firstIndexableField(newBytes)));
	digitShift = shiftCount / 8;
	bitShift = shiftCount % 8;
	limit = digitShift - 1;
	for (i = 0; i <= limit; i += 1) {
		pTo[i] = 0;
	}
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		cDigitCopyFromtolen(pFrom, pTo + digitShift, ((newLen - 1) - digitShift) + 1);
		goto l1;
	}
	rshift = 8 - bitShift;
	carry = 0;
	limit = oldLen - 1;
	for (i = 0; i <= limit; i += 1) {
		digit = pFrom[i];
		pTo[i + digitShift] = ((carry | (digit << bitShift)) & 0xFF);
		carry = ((usqInt) digit) >> rshift;
	}
	if (!(carry == 0)) {
		pTo[newLen - 1] = carry;
	}
l1:	/* end cDigitLshift:from:len:to:len: */;
	return newBytes;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Shift right shiftCount bits, 0<=shiftCount. 
	Discard all digits beyond a, and all zeroes at or below a. */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#digit:Rshift:lookfirst: */
static sqInt
digitRshiftlookfirst(sqInt aBytesOop, sqInt shiftCount, sqInt a)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt j;
	unsigned int lastDigit;
	sqInt leftShift;
	sqInt limit;
	sqInt newBitLen;
	sqInt newByteLen;
	sqInt newOop;
	sqInt oldBitLen;
	sqInt oldDigitLen;
	unsigned char *pByte;
	unsigned char *pFrom;
	unsigned char *pTo;
	sqInt realLength;
	sqInt start;

	/* begin cDigitHighBit:len: */
	pByte = ((unsigned char *) (firstIndexableField(aBytesOop)));
	realLength = a;
	while (((lastDigit = pByte[realLength - 1])) == 0) {
		if (((realLength -= 1)) == 0) {
			oldBitLen = 0;
			goto l1;
		}
	}
	oldBitLen = (cHighBit(lastDigit)) + (8 * (realLength - 1));
l1:	/* end cDigitHighBit:len: */;
	oldDigitLen = (oldBitLen + 7) / 8;
	newBitLen = oldBitLen - shiftCount;
	if (newBitLen <= 0) {

		/* All bits lost */
		return instantiateClassindexableSize(fetchClassOf(aBytesOop), 0);
	}
	newByteLen = (newBitLen + 7) / 8;
	
#if SPURVM
	newOop = instantiateClassindexableSize(fetchClassOf(aBytesOop), newByteLen);

#else /* SPURVM */
	pushRemappableOop(aBytesOop);
	newOop = instantiateClassindexableSize(fetchClassOf(aBytesOop), newByteLen);
	aBytesOop = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitRshift:from:len:to:len: */
	pFrom = ((unsigned char *) (firstIndexableField(aBytesOop)));
	pTo = ((unsigned char *) (firstIndexableField(newOop)));
	digitShift = shiftCount / 8;
	bitShift = shiftCount % 8;
	if (bitShift == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		cDigitCopyFromtolen(pFrom + digitShift, pTo, ((newByteLen - 1)) + 1);
		goto l2;
	}
	leftShift = 8 - bitShift;
	carry = ((usqInt) (pFrom[digitShift])) >> bitShift;
	start = digitShift + 1;
	limit = oldDigitLen - 1;
	for (j = start; j <= limit; j += 1) {
		digit = pFrom[j];
		pTo[j - start] = ((carry | (digit << leftShift)) & 0xFF);
		carry = ((usqInt) digit) >> bitShift;
	}
	if (!(carry == 0)) {
		pTo[newByteLen - 1] = carry;
	}
l2:	/* end cDigitRshift:from:len:to:len: */;
	return newOop;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* LargeIntegersPlugin>>#highBitOfLargeInt: */
static sqInt
highBitOfLargeInt(sqInt aBytesOop)
{
	unsigned int lastDigit;
	sqInt len;
	unsigned char *pByte;
	sqInt realLength;

	/* begin cDigitHighBit:len: */
	pByte = ((unsigned char *) (firstIndexableField(aBytesOop)));
	len = slotSizeOf(aBytesOop);
	realLength = len;
	while (((lastDigit = pByte[realLength - 1])) == 0) {
		if (((realLength -= 1)) == 0) {
			return 0;
		}
	}
	return (cHighBit(lastDigit)) + (8 * (realLength - 1));
}

	/* LargeIntegersPlugin>>#isNormalized: */
static sqInt
isNormalized(sqInt anInteger)
{
	sqInt class;
	sqInt ix;
	sqInt len;
	unsigned char *pointer;
	sqInt positive;

	if (isIntegerObject(anInteger)) {
		return 1;
	}
	class = fetchClassOf(anInteger);
	if (!((positive = class == (classLargePositiveInteger())))) {
		if (!(class == (classLargeNegativeInteger()))) {
			primitiveFailFor(PrimErrBadArgument);
			return 0;
		}
	}

	/* Check for leading zero of LargeInteger */
	pointer = ((unsigned char *) (firstIndexableField(anInteger)));
	len = slotSizeOf(anInteger);
	if ((len == 0)
	 || ((pointer[len - 1]) == 0)) {
		return 0;
	}
	if (len != BytesPerOop) {
		return len > BytesPerOop;
	}
	if (positive) {

		/* all bytes of but the highest one are just FF's */
		return (pointer[BytesPerOop - 1]) > ((((usqInt) (((MaxSmallInteger) < 0
			? 0 - (MaxSmallInteger)
			: MaxSmallInteger))) >> ((BytesPerOop - 1) * 8)) & 0xFF);
	}
	if ((pointer[BytesPerOop - 1]) < ((((usqInt) (((MinSmallInteger) < 0
		? 0 - (MinSmallInteger)
		: MinSmallInteger))) >> ((BytesPerOop - 1) * 8)) & 0xFF)) {
		return 0;
	}
	for (ix = 0; ix < BytesPerOop; ix += 1) {
		if (!((pointer[ix]) == ((((usqInt) (((MinSmallInteger) < 0
				? 0 - (MinSmallInteger)
				: MinSmallInteger))) >> (((ix + 1) - 1) * 8)) & 0xFF))) {
			return 1;
		}
	}
	return 0;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */

	/* LargeIntegersPlugin>>#largeIntOrInt:growTo: */
static sqInt
largeIntOrIntgrowTo(sqInt oop, sqInt len)
{
	sqInt class;
	sqInt ix;
	sqInt ixLimiT;
	sqInt newBytes;
	unsigned char *pByte;
	sqInt val;

	if (isIntegerObject(oop)) {
		val = integerValueOf(oop);
		if (val < 0) {
			class = classLargeNegativeInteger();
		}
		else {
			class = classLargePositiveInteger();
		}
		newBytes = instantiateClassindexableSize(class, len);
		/* begin cCopyIntVal:toBytes: */
		pByte = firstIndexableField(newBytes);
		for (ix = 1, ixLimiT = (cDigitLengthOfCSI(val)); ix <= ixLimiT; ix += 1) {
			pByte[ix - 1] = ((((usqInt) ((val < 0
	? 0 - val
	: val))) >> ((ix - 1) * 8)) & 0xFF);
		}
	}
	else {
		newBytes = largeIntgrowTo(oop, len);
	}
	return newBytes;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#largeInt:growTo: */
static sqInt
largeIntgrowTo(sqInt aBytesObject, sqInt newLen)
{
	sqInt copyLen;
	sqInt newBytes;
	sqInt oldLen;

	
#if SPURVM
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesObject), newLen);

#else /* SPURVM */
	pushRemappableOop(aBytesObject);
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesObject), newLen);
	aBytesObject = popRemappableOop()
#endif /* SPURVM */
;
	oldLen = slotSizeOf(aBytesObject);
	if (oldLen < newLen) {
		copyLen = oldLen;
	}
	else {
		copyLen = newLen;
	}
	cDigitCopyFromtolen(firstIndexableField(aBytesObject), firstIndexableField(newBytes), copyLen);
	return newBytes;
}

	/* InterpreterPlugin>>#msg: */
static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

	/* LargeIntegersPlugin>>#normalizeNegative: */
static sqInt
normalizeNegative(sqInt aLargeNegativeInteger)
{
	sqInt byte;
	sqInt i;
	sqInt len;
	sqInt oldLen;
	unsigned char * pointer;
	sqInt sLen;
	sqInt val;

	len = (oldLen = slotSizeOf(aLargeNegativeInteger));
	pointer = ((unsigned char *) (firstIndexableField(aLargeNegativeInteger)));
	while ((len > 0)
	 && ((pointer[len - 1]) == 0)) {
		len -= 1;
	}
	if (len == 0) {
		return integerObjectOf(0);
	}

	/* SmallInteger digitLength */
	sLen = ((MinSmallInteger) < -1073741824
		? 8
		: 4);
	if (len <= sLen) {
		if ((len < sLen)
		 || ((pointer[sLen - 1]) < ((((usqInt) (((MinSmallInteger) < 0
			? 0 - (MinSmallInteger)
			: MinSmallInteger))) >> ((sLen - 1) * 8)) & 0xFF))) {

			/* interpreterProxy minSmallInteger lastDigit */
			/* If high digit less, then can be small */
			val = 0 - (pointer[(len -= 1)]);
			for (i = (len - 1); i >= 0; i += -1) {
				val = (val * 256) - (pointer[i]);
			}
			return integerObjectOf(val);
		}
		for (i = 1; i <= sLen; i += 1) {

			/* If all digits same, then = minSmallInteger (sr: minSmallInteger digits 1 to sLen - 1 are 0) */
			byte = (i > len
				? 0
				: pointer[i - 1]);
			if (byte != ((((usqInt) (((MinSmallInteger) < 0
				? 0 - (MinSmallInteger)
				: MinSmallInteger))) >> ((i - 1) * 8)) & 0xFF)) {

				/* Not so; return self shortened */
				if (len < oldLen) {

					/* ^ self growto: len */
					return largeIntgrowTo(aLargeNegativeInteger, len);
				}
				return aLargeNegativeInteger;
			}
		}
		return integerObjectOf((MinSmallInteger));
	}
	if (len < oldLen) {

		/* ^ self growto: len */
		return largeIntgrowTo(aLargeNegativeInteger, len);
	}
	return aLargeNegativeInteger;
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

	/* LargeIntegersPlugin>>#normalizePositive: */
static sqInt
normalizePositive(sqInt aLargePositiveInteger)
{
	sqInt i;
	sqInt len;
	sqInt oldLen;
	unsigned char *pointer;
	sqInt sLen;
	sqInt val;

	len = (oldLen = slotSizeOf(aLargePositiveInteger));
	pointer = ((unsigned char *) (firstIndexableField(aLargePositiveInteger)));
	while ((len > 0)
	 && ((pointer[len - 1]) == 0)) {
		len -= 1;
	}
	if (len == 0) {
		return integerObjectOf(0);
	}
	sLen = ((MaxSmallInteger) > 0x3FFFFFFF
		? 8
		: 4);
	if (len <= sLen) {
		if ((len < sLen)
		 || ((pointer[sLen - 1]) <= ((((usqInt) (((MaxSmallInteger) < 0
			? 0 - (MaxSmallInteger)
			: MaxSmallInteger))) >> ((sLen - 1) * 8)) & 0xFF))) {

			/* If so, return its SmallInt value */
			val = pointer[(len -= 1)];
			for (i = (len - 1); i >= 0; i += -1) {
				val = (val * 256) + (pointer[i]);
			}
			return integerObjectOf(val);
		}
	}
	if (len < oldLen) {

		/* ^ self growto: len */
		return largeIntgrowTo(aLargePositiveInteger, len);
	}
	return aLargePositiveInteger;
}


/*	Check for leading zeroes and return shortened copy if so. */

	/* LargeIntegersPlugin>>#normalize: */
static sqInt
normalize(sqInt aLargeInteger)
{
	/* missing DebugCode */;
	if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
		return normalizePositive(aLargeInteger);
	}
	else {
		return normalizeNegative(aLargeInteger);
	}
}

	/* LargeIntegersPlugin>>#primAnyBitFrom:to: */
EXPORT(sqInt)
primAnyBitFromTo(void)
{
	sqInt from;
	sqInt integer;
	sqInt large;
	sqInt to;
	sqInt _return_value;

	from = stackIntegerValue(1);
	to = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	integer = stackValue(2);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(integer)) {

		/* convert it to a not normalized LargeInteger */
		large = createLargeFromSmallInteger(integer);
	}
	else {
		large = integer;
	}
	if (failed()) {
		return null;
	}
	_return_value = (((anyBitOfLargeIntfromto(large, from, to))) ? trueObject() : falseObject());
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Converts a SmallInteger into a - non normalized! - LargeInteger; 
	aLargeInteger will be returned unchanged. */
/*	Do not check for forced fail, because we need this conversion to test the 
	plugin in ST during forced fail, too. */

	/* LargeIntegersPlugin>>#primAsLargeInteger: */
EXPORT(sqInt)
primAsLargeInteger(void)
{
	sqInt anInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	anInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {
		if (failed()) {
			return null;
		}
		_return_value = createLargeFromSmallInteger(anInteger);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
		if (failed()) {
			return null;
		}
		popthenPush(2, anInteger);
		return null;
	}
}


/*	If calling this primitive fails, then C module does not exist. Do not
	check for forced fail, because we want to know if module exists during
	forced fail, too.
 */

	/* LargeIntegersPlugin>>#primCheckIfCModuleExists */
EXPORT(sqInt)
primCheckIfCModuleExists(void)
{
	sqInt _return_value;

	if (failed()) {
		return null;
	}
	_return_value = ((1) ? trueObject() : falseObject());
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitAdd: */
EXPORT(sqInt)
primDigitAdd(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitAddLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitAdd:with: */
EXPORT(sqInt)
primDigitAddWith(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitAddLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitAnd: */
EXPORT(sqInt)
primDigitBitAnd(void)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, andOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if any
	arg is negative, it fails.
 */

	/* LargeIntegersPlugin>>#primDigitBitLogic:with:op: */
EXPORT(sqInt)
primDigitBitLogicWithOp(void)
{
	sqInt firstInteger;
	sqInt opIndex;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	opIndex = stackIntegerValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, opIndex);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitOr: */
EXPORT(sqInt)
primDigitBitOr(void)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, orOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitBitShift: */
EXPORT(sqInt)
primDigitBitShift(void)
{
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */
		aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
		aLarge = anInteger;
	}
	if (shiftCount >= 0) {
		if (failed()) {
			return null;
		}
		_return_value = digitLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
		rShift = 0 - shiftCount;
		if (failed()) {
			return null;
		}
		/* begin normalize: */
		aLargeInteger = digitRshiftlookfirst(aLarge, rShift, slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
			_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
}

	/* LargeIntegersPlugin>>#primDigitBitShiftMagnitude: */
EXPORT(sqInt)
primDigitBitShiftMagnitude(void)
{
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */
		aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
		aLarge = anInteger;
	}
	if (shiftCount >= 0) {
		if (failed()) {
			return null;
		}
		_return_value = digitLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
		rShift = 0 - shiftCount;
		if (failed()) {
			return null;
		}
		/* begin normalize: */
		aLargeInteger = digitRshiftlookfirst(aLarge, rShift, slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
			_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitXor: */
EXPORT(sqInt)
primDigitBitXor(void)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, xorOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitCompare: */
EXPORT(sqInt)
primDigitCompare(void)
{
	sqInt firstInteger;
	sqInt firstVal;
	sqInt secondInteger;
	sqInt secondVal;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* first */
		if (isIntegerObject(secondInteger)) {

			/* second */
			if (((firstVal = integerValueOf(firstInteger))) > ((secondVal = integerValueOf(secondInteger)))) {
				if (failed()) {
					return null;
				}
				_return_value = integerObjectOf(1);
				if (failed()) {
					return null;
				}
				popthenPush(2, _return_value);
				return null;
			}
			else {
				if (firstVal < secondVal) {
					if (failed()) {
						return null;
					}
					_return_value = integerObjectOf(-1);
					if (failed()) {
						return null;
					}
					popthenPush(2, _return_value);
					return null;
				}
				else {
					if (failed()) {
						return null;
					}
					_return_value = integerObjectOf(0);
					if (failed()) {
						return null;
					}
					popthenPush(2, _return_value);
					return null;
				}
			}
		}
		else {

			/* SECOND */
			if (failed()) {
				return null;
			}
			_return_value = integerObjectOf(-1);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
	}
	else {

		/* FIRST */
		if (isIntegerObject(secondInteger)) {

			/* second */
			if (failed()) {
				return null;
			}
			_return_value = integerObjectOf(1);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
		else {

			/* SECOND */
			if (failed()) {
				return null;
			}
			_return_value = digitCompareLargewith(firstInteger, secondInteger);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
	}
}

	/* LargeIntegersPlugin>>#primDigitCompare:with: */
EXPORT(sqInt)
primDigitCompareWith(void)
{
	sqInt firstInteger;
	sqInt firstVal;
	sqInt secondInteger;
	sqInt secondVal;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* first */
		if (isIntegerObject(secondInteger)) {

			/* second */
			if (((firstVal = integerValueOf(firstInteger))) > ((secondVal = integerValueOf(secondInteger)))) {
				if (failed()) {
					return null;
				}
				_return_value = integerObjectOf(1);
				if (failed()) {
					return null;
				}
				popthenPush(3, _return_value);
				return null;
			}
			else {
				if (firstVal < secondVal) {
					if (failed()) {
						return null;
					}
					_return_value = integerObjectOf(-1);
					if (failed()) {
						return null;
					}
					popthenPush(3, _return_value);
					return null;
				}
				else {
					if (failed()) {
						return null;
					}
					_return_value = integerObjectOf(0);
					if (failed()) {
						return null;
					}
					popthenPush(3, _return_value);
					return null;
				}
			}
		}
		else {

			/* SECOND */
			if (failed()) {
				return null;
			}
			_return_value = integerObjectOf(-1);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
	}
	else {

		/* FIRST */
		if (isIntegerObject(secondInteger)) {

			/* second */
			if (failed()) {
				return null;
			}
			_return_value = integerObjectOf(1);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
		else {

			/* SECOND */
			if (failed()) {
				return null;
			}
			_return_value = digitCompareLargewith(firstInteger, secondInteger);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
	}
}


/*	Answer the result of dividing firstInteger by secondInteger. 
	Fail if parameters are not integers, not normalized or secondInteger is 
	zero. */

	/* LargeIntegersPlugin>>#primDigitDiv:negative: */
EXPORT(sqInt)
primDigitDivNegative(void)
{
	sqInt firstAsLargeInteger;
	sqInt firstInteger;
	sqInt neg;
	sqInt secondAsLargeInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	if (failed()) {
		return null;
	}
	if (!(isNormalized(firstInteger))) {
		/* missing DebugCode */;
		primitiveFail();
		return null;
	}
	if (!(isNormalized(secondInteger))) {
		/* missing DebugCode */;
		primitiveFail();
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert to LargeInteger */
		
#if SPURVM
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstAsLargeInteger = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* check for zerodivide and convert to LargeInteger */
		if ((integerValueOf(secondInteger)) == 0) {
			primitiveFail();
			return null;
		}
		
#if SPURVM
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstAsLargeInteger);
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);
		firstAsLargeInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondAsLargeInteger = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Answer the result of dividing firstInteger by secondInteger.
	Fail if parameters are not integers or secondInteger is zero. */

	/* LargeIntegersPlugin>>#primDigitDiv:with:negative: */
EXPORT(sqInt)
primDigitDivWithNegative(void)
{
	sqInt firstAsLargeInteger;
	sqInt firstInteger;
	sqInt neg;
	sqInt secondAsLargeInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert to LargeInteger */
		
#if SPURVM
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstAsLargeInteger = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* check for zerodivide and convert to LargeInteger */
		if ((integerValueOf(secondInteger)) == 0) {
			primitiveFail();
			return null;
		}
		
#if SPURVM
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstAsLargeInteger);
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);
		firstAsLargeInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondAsLargeInteger = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitMultiply:negative: */
EXPORT(sqInt)
primDigitMultiplyNegative(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt neg;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitMultiplyLargewithnegative(firstLarge, secondLarge, neg);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitMultiply:with:negative: */
EXPORT(sqInt)
primDigitMultiplyWithNegative(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt neg;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitMultiplyLargewithnegative(firstLarge, secondLarge, neg);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitSubtract: */
EXPORT(sqInt)
primDigitSubtract(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitSubLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primDigitSubtract:with: */
EXPORT(sqInt)
primDigitSubtractWith(void)
{
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (failed()) {
		return null;
	}
	_return_value = digitSubLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	If calling this primitive fails, then C module does not exist. */

	/* LargeIntegersPlugin>>#primGetModuleName */
EXPORT(sqInt)
primGetModuleName(void)
{
	sqInt strLen;
	sqInt strOop;

	/* missing DebugCode */;
	strLen = strlen(getModuleName());
	strOop = instantiateClassindexableSize(classString(), strLen);
	strncpy(firstIndexableField(strOop), getModuleName(), strLen);
	if (failed()) {
		return null;
	}
	popthenPush(1, strOop);
	return null;
}

	/* LargeIntegersPlugin>>#primMontgomeryDigitLength */
EXPORT(sqInt)
primMontgomeryDigitLength(void)
{
	sqInt _return_value;

	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	_return_value = integerObjectOf(8);
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primMontgomeryTimes:modulo:mInvModB: */
EXPORT(sqInt)
primMontgomeryTimesModulo(void)
{
	unsigned int accum;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned char lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char *pBytesFirst;
	unsigned char *pBytesRes;
	unsigned char *pBytesSecond;
	unsigned char *pBytesThird;
	sqInt prod;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt secondOperandInteger;
	sqInt smallInverseInteger;
	sqInt thirdLarge;
	sqInt thirdLen;
	sqInt thirdModuloInteger;
	unsigned char u;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	secondOperandInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	thirdModuloInteger = stackValue(1);
	smallInverseInteger = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(3), "Integer"));
	firstInteger = stackValue(3);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger);

#else /* SPURVM */
		pushRemappableOop(secondOperandInteger);
		pushRemappableOop(thirdModuloInteger);
		firstLarge = createLargeFromSmallInteger(firstInteger);
		thirdModuloInteger = popRemappableOop();
		secondOperandInteger = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondOperandInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondOperandInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		pushRemappableOop(thirdModuloInteger);
		secondLarge = createLargeFromSmallInteger(secondOperandInteger);
		thirdModuloInteger = popRemappableOop();
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondOperandInteger;
	}
	if (isIntegerObject(thirdModuloInteger)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		thirdLarge = createLargeFromSmallInteger(thirdModuloInteger);

#else /* SPURVM */
		pushRemappableOop(firstLarge);
		pushRemappableOop(secondLarge);
		thirdLarge = createLargeFromSmallInteger(thirdModuloInteger);
		secondLarge = popRemappableOop();
		firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	}
	else {
		thirdLarge = thirdModuloInteger;
	}
	if (failed()) {
		return null;
	}
	/* begin digitMontgomery:times:modulo:mInvModB: */
	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	thirdLen = slotSizeOf(thirdLarge);
	if (!(firstLen <= thirdLen)) {
		_return_value = primitiveFail();
		goto l1;
	}
	if (!(secondLen <= thirdLen)) {
		_return_value = primitiveFail();
		goto l1;
	}
	if (!((smallInverseInteger >= 0)
		 && (smallInverseInteger <= 0xFF))) {
		_return_value = primitiveFail();
		goto l1;
	}
	
#if SPURVM
	prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);

#else /* SPURVM */
	pushRemappableOop(firstLarge);
	pushRemappableOop(secondLarge);
	pushRemappableOop(thirdLarge);
	prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);
	thirdLarge = popRemappableOop();
	secondLarge = popRemappableOop();
	firstLarge = popRemappableOop()
#endif /* SPURVM */
;
	/* begin cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
	pBytesFirst = ((unsigned char *) (firstIndexableField(firstLarge)));
	pBytesSecond = ((unsigned char *) (firstIndexableField(secondLarge)));
	pBytesThird = ((unsigned char *) (firstIndexableField(thirdLarge)));
	pBytesRes = ((unsigned char *) (firstIndexableField(prod)));
	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
		accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * smallInverseInteger) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
			accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
		accum = pBytesRes[0];
		u = (accum * smallInverseInteger) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
			accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */
		accum = 0;
		for (i = 0; i <= limit3; i += 1) {
			accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = accum;
			accum = ((signed)accum >> 8);
		}
	}
	_return_value = normalizePositive(prod);
l1:	/* end digitMontgomery:times:modulo:mInvModB: */;
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}


/*	Parameter specification #(Integer) doesn't convert! */

	/* LargeIntegersPlugin>>#primNormalize: */
EXPORT(sqInt)
primNormalize(void)
{
	sqInt anInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	anInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {
		if (failed()) {
			return null;
		}
		popthenPush(2, anInteger);
		return null;
	}
	if (failed()) {
		return null;
	}
	/* begin normalize: */
	/* missing DebugCode */;
	if ((fetchClassOf(anInteger)) == (classLargePositiveInteger())) {
		_return_value = normalizePositive(anInteger);
		goto l1;
	}
	else {
		_return_value = normalizeNegative(anInteger);
		goto l1;
	}
l1:	/* end normalize: */;
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primNormalizeNegative */
EXPORT(sqInt)
primNormalizeNegative(void)
{
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isKindOf(stackValue(0), "LargeNegativeInteger"));
	rcvr = stackValue(0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = normalizeNegative(rcvr);
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

	/* LargeIntegersPlugin>>#primNormalizePositive */
EXPORT(sqInt)
primNormalizePositive(void)
{
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isKindOf(stackValue(0), "LargePositiveInteger"));
	rcvr = stackValue(0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		return null;
	}
	_return_value = normalizePositive(rcvr);
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		classArray = interpreterProxy->classArray;
		classLargeNegativeInteger = interpreterProxy->classLargeNegativeInteger;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		isKindOf = interpreterProxy->isKindOf;
		isIntegerObject = interpreterProxy->isIntegerObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stObjectatput = interpreterProxy->stObjectatput;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* SmartSyntaxInterpreterPlugin>>#sqAssert: */
static sqInt
sqAssert(sqInt aBool)
{
	/* missing DebugCode */;
	return aBool;
}


/*	Argument bytesObj must not be aSmallInteger! */

	/* LargeIntegersPlugin>>#unsafeDigitOf:at: */
static sqInt
unsafeDigitOfat(sqInt bytesObj, sqInt ix)
{
	return (((unsigned char *) (firstIndexableField(bytesObj))))[ix - 1];
}

	/* LargeIntegersPlugin>>#primDigit:bitShift: */
EXPORT(sqInt)
_primDigitBitShift(void)
{
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */
		aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
		aLarge = anInteger;
	}
	if (shiftCount >= 0) {
		if (failed()) {
			return null;
		}
		_return_value = digitLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(3, _return_value);
		return null;
	}
	else {
		rShift = 0 - shiftCount;
		if (failed()) {
			return null;
		}
		/* begin normalize: */
		aLargeInteger = digitRshiftlookfirst(aLarge, rShift, slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
			_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(3, _return_value);
		return null;
	}
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "LargeIntegers";
void* LargeIntegers_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primAnyBitFromTo\000\002", (void*)primAnyBitFromTo},
	{(void*)_m, "primAsLargeInteger\000\001", (void*)primAsLargeInteger},
	{(void*)_m, "primCheckIfCModuleExists\000\377", (void*)primCheckIfCModuleExists},
	{(void*)_m, "primDigitAdd\000\002", (void*)primDigitAdd},
	{(void*)_m, "primDigitAddWith\000\002", (void*)primDigitAddWith},
	{(void*)_m, "primDigitBitAnd\000\001", (void*)primDigitBitAnd},
	{(void*)_m, "primDigitBitLogicWithOp\000\001", (void*)primDigitBitLogicWithOp},
	{(void*)_m, "primDigitBitOr\000\001", (void*)primDigitBitOr},
	{(void*)_m, "primDigitBitShift\000\003", (void*)primDigitBitShift},
	{(void*)_m, "primDigitBitShiftMagnitude\000\003", (void*)primDigitBitShiftMagnitude},
	{(void*)_m, "primDigitBitXor\000\001", (void*)primDigitBitXor},
	{(void*)_m, "primDigitCompare\000\001", (void*)primDigitCompare},
	{(void*)_m, "primDigitCompareWith\000\001", (void*)primDigitCompareWith},
	{(void*)_m, "primDigitDivNegative\000\004", (void*)primDigitDivNegative},
	{(void*)_m, "primDigitDivWithNegative\000\004", (void*)primDigitDivWithNegative},
	{(void*)_m, "primDigitMultiplyNegative\000\002", (void*)primDigitMultiplyNegative},
	{(void*)_m, "primDigitMultiplyWithNegative\000\002", (void*)primDigitMultiplyWithNegative},
	{(void*)_m, "primDigitSubtract\000\002", (void*)primDigitSubtract},
	{(void*)_m, "primDigitSubtractWith\000\002", (void*)primDigitSubtractWith},
	{(void*)_m, "primGetModuleName\000\377", (void*)primGetModuleName},
	{(void*)_m, "primMontgomeryDigitLength\000\377", (void*)primMontgomeryDigitLength},
	{(void*)_m, "primMontgomeryTimesModulo\000\001", (void*)primMontgomeryTimesModulo},
	{(void*)_m, "primNormalize\000\001", (void*)primNormalize},
	{(void*)_m, "primNormalizeNegative\000\001", (void*)primNormalizeNegative},
	{(void*)_m, "primNormalizePositive\000\001", (void*)primNormalizePositive},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "_primDigitBitShift\000\003", (void*)_primDigitBitShift},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primAnyBitFromToAccessorDepth = 2;
signed char primAsLargeIntegerAccessorDepth = 1;
signed char primDigitAddAccessorDepth = 2;
signed char primDigitAddWithAccessorDepth = 2;
signed char primDigitBitAndAccessorDepth = 1;
signed char primDigitBitLogicWithOpAccessorDepth = 1;
signed char primDigitBitOrAccessorDepth = 1;
signed char primDigitBitShiftAccessorDepth = 3;
signed char primDigitBitShiftMagnitudeAccessorDepth = 3;
signed char primDigitBitXorAccessorDepth = 1;
signed char primDigitCompareAccessorDepth = 1;
signed char primDigitCompareWithAccessorDepth = 1;
signed char primDigitDivNegativeAccessorDepth = 4;
signed char primDigitDivWithNegativeAccessorDepth = 4;
signed char primDigitMultiplyNegativeAccessorDepth = 2;
signed char primDigitMultiplyWithNegativeAccessorDepth = 2;
signed char primDigitSubtractAccessorDepth = 2;
signed char primDigitSubtractWithAccessorDepth = 2;
signed char primMontgomeryTimesModuloAccessorDepth = 1;
signed char primNormalizeAccessorDepth = 1;
signed char primNormalizeNegativeAccessorDepth = 1;
signed char primNormalizePositiveAccessorDepth = 1;
signed char _primDigitBitShiftAccessorDepth = 3;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
