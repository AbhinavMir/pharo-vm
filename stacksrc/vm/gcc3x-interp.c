/* This file has been post-processed for GNU C */


/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
   from
	StackInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sqGnu.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 * Note: on windows 64 via mingw-w64, the 2nd argument NULL to _setjmp prevents stack unwinding
 */
#undef sigsetjmp
#undef siglongjmp
#if _MSC_VER
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN64 && __GNUC__
# define sigsetjmp(jb,ssmf) _setjmp(jb,NULL)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

#define odd(v) ((int)(v)&1)
#define even(v) (!odd(v))

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFU
#define AllButMarkBit 0x7FFFFFFF
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFU
#define AllButTypeMask 0xFFFFFFFCU
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BytecodeSetHasExtensions 0
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 0
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMessageCompactIndex 0
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne 0xFFFFFFFFU
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DoAssertionChecks 0
#define DoExpensiveAssertionChecks 0
#define Done 4
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define FullClosureFirstCopiedValueIndex 4
#define GCCheckPrimCall 64
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GCTopMarker 3
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define ImmutabilityBit 0x20000000
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCU
#define LongSizeNumBits 30
#define LongStoreBytecode 129
#define LowcodeVM 0
#define MarkBit 0x80000000U
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MULTIPLEBYTECODESETS 0
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheSize 4096
#if !defined(PharoVM) /* Allow this to be overridden on the compiler command line */
# define PharoVM 0
#endif
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimNoErr 0
#define PrimNumberExternalCall 117
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSlots 22
#define SPURVM 0
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFU
#define XIndex 0
#define YIndex 1

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
static int NoDbgRegParms noInlineSigned32BitValueGutsOf(sqInt oop);
extern unsigned int positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCoarseLocalMicrosecondClock(void);
static void primitiveCoarseUTCMicrosecondClock(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
static sqInt NoDbgRegParms addressCouldBeObjWhileForwarding(sqInt address);
extern sqInt addressCouldBeObj(sqInt address);
static sqInt NoDbgRegParms adjustAllOopsBy(sqInt bytesToShift);
static sqInt NoDbgRegParms allInstancesOf(sqInt aBehavior);
static sqInt allObjectsUnmarked(void);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern sqInt characterValueOf(sqInt oop);
static sqInt checkHeapIntegrity(void);
extern sqInt checkOkayOop(usqInt oop);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
static void clearLeakMapAndMapAccessibleObjects(void);
extern sqInt clone(sqInt obj);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
extern sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms eeInstantiateMethodContextSlots(sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt oop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern void fullGC(void);
static sqInt NoDbgRegParms fwdTableInit(sqInt blkSize);
static sqInt NoDbgRegParms fwdTableSize(sqInt blkSize);
static usqInt imageSegmentVersion(void);
static sqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static sqInt NoDbgRegParms incCompMove(sqInt bytesFreed);
extern void incrementalGC(void);
static void NoDbgRegParms initializeMemoryFirstFree(sqInt firstFree);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
extern sqInt isYoungObject(sqInt obj);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckNewSpaceGC(void);
extern sqInt literalCountOfMethodHeader(sqInt methodHeader);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintReferencesTo(sqInt anOop);
static void NoDbgRegParms mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms markPhase(sqInt fullGCFlag);
static sqInt newSpaceBytes(void);
extern sqInt objectAfter(sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
static sqInt NoDbgRegParms oopHasAcceptableClass(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
extern void printActivationsOf(sqInt aMethodObj);
extern void printContextReferencesTo(sqInt anOop);
extern void printMemory(void);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printWronglySizedContexts(sqInt printContexts);
static void NoDbgRegParms restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static sqInt NoDbgRegParms safeObjectAfter(sqInt oop);
extern sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots);
static sqInt NoDbgRegParms sizeBitsOfSafe(sqInt oop);
static sqInt NoDbgRegParms sizeBitsOf(sqInt oop);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt minFree);
static sqInt NoDbgRegParms sufficientSpaceToAllocate(sqInt bytes);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
extern void unpinObject(sqInt objOop);
static void verifyCleanHeaders(void);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt allObjects(void);
static sqInt NoDbgRegParms allYoungand(sqInt array1, sqInt array2);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms badContextSize(sqInt oop);
extern sqInt becomewith(sqInt array1, sqInt array2);
extern void beRootIfOld(sqInt oop);
static void NoDbgRegParms beRootWhileForwarding(sqInt oop);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned int byteSwapped32IfBigEndian(unsigned int w);
extern unsigned long long byteSwapped64IfBigEndian(unsigned long long w);
extern sqInt byteSwapped(sqInt w);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern sqInt characterTable(void);
extern sqInt checkedLongAt(sqInt byteAddress);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classHeader(sqInt oop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classUnsafeAlien(void);
static void clearRootsTable(void);
extern sqInt compactClassAt(sqInt ccIndex);
extern sqInt compactClassIndexOfClass(sqInt classObj);
extern sqInt compactClassIndexOfHeader(sqInt header);
extern sqInt compactClassIndexOf(sqInt oop);
static sqInt NoDbgRegParms compactIndexOfClass(sqInt aClassOop);
static sqInt NoDbgRegParms containOnlyOops(sqInt array);
static sqInt NoDbgRegParms containOnlyOopsand(sqInt array1, sqInt array2);
static sqInt NoDbgRegParms copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
extern sqInt displayObject(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqLong NoDbgRegParms fetchLong64ofObject(sqInt longIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static void NoDbgRegParms finalizeReference(usqInt oop);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt oop);
extern void * firstIndexableField(sqInt oop);
static sqInt firstStringyFakeFormat(void);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms followForwarded(sqInt objOop);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOfHeader(sqInt header);
static sqInt NoDbgRegParms fwdBlockValid(sqInt addr);
#if PharoVM
static float getHeapGrowthToSizeGCRatio(void);
#endif /* PharoVM */
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms hasForwardingBlock(sqInt objOop);
static sqInt hasSixtyFourBitImmediates(void);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt objectPointer);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
static sqInt NoDbgRegParms isCompiledMethodHeader(sqInt objHeader);
extern sqInt isCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
extern sqInt isImmediate(sqInt anOop);
extern sqInt isIndexable(sqInt oop);
extern sqInt isInMemory(sqInt address);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt oop);
extern sqInt isNonImmediate(sqInt anOop);
extern sqInt isNonIntegerObject(sqInt objectPointer);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop);
extern sqInt isOopCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt anOop);
extern sqInt isOopMutable(sqInt anOop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
static sqInt NoDbgRegParms isWeakNonImm(sqInt oop);
extern sqInt isWeak(sqInt oop);
static sqInt NoDbgRegParms isWordsOrBytesNonImm(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt oop);
static sqInt NoDbgRegParms lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
extern sqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
static sqInt NoDbgRegParms lowestFreeAfter(sqInt chunk);
extern sqInt markAndTrace(sqInt oop);
extern sqInt maybeSplObj(sqInt index);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
extern sqInt minSlotsForShortening(void);
extern sqInt nilObject(void);
extern sqInt noShiftCompactClassIndexOfHeader(sqInt header);
extern sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
extern sqInt numSlotsOf(sqInt obj);
extern sqInt objectBefore(sqInt address);
extern sqInt objectExactlyBefore(sqInt oop);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms oopFromChunk(sqInt chunk);
static sqInt NoDbgRegParms oopHasOkayClass(sqInt signedOop);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
extern sqInt primitiveErrorTable(void);
extern void printInstancesOf(sqInt aClassOop);
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms remapObj(sqInt obj);
extern sqInt remap(sqInt oop);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static sqInt NoDbgRegParms removeYoungRoot(sqInt obj);
extern sqInt shouldRemapObj(sqInt oop);
extern sqInt shouldRemapOop(sqInt oop);
static sqInt sixtyFourBitIndexableFormat(void);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
EXPORT(sqInt) statNumGCs(void);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
extern void tenuringIncrementalGC(void);
extern sqInt topRemappableOop(void);
extern sqInt trueObject(void);
static void NoDbgRegParms updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
extern sqInt vmEndianness(void);
extern sqInt activeProcess(void);
extern void addIdleUsecs(sqInt idleUsecs);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static sqInt NoDbgRegParms checkStackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms checkStackPointerIndexForFrame(char *theFP);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copiedValueCountOfFullClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
extern sqInt disownVM(sqInt flags);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
extern void dumpPrimTraceLog(void);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt meth);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
extern double floatArg(sqInt index);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static sqInt NoDbgRegParms frameContext(char *theFP);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameMethod(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(void);
static sqInt getDesiredCogCodeSize(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static void NeverInline handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern usqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern sqInt integerArg(sqInt index);
static sqInt NeverInline interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isStillMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
static void NoDbgRegParms makeContextSnapshotSafe(sqInt ctxt);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void NeverInline mapStackPages(void);
static sqInt NoDbgRegParms markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceInterpreterOops(sqInt fullGCFlag);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms NeverInline noInlineSigned32BitIntegerGutsFor(sqInt integerValue);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt ownVM(sqInt threadIndexAndFlags);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
static sqInt NoDbgRegParms positiveMachineIntegerFor(usqIntptr_t value);
static void NoDbgRegParms postGCAction(sqInt gcModeArg);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printHexnp(sqInt n);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern sqInt printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(sqInt aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static sqInt NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
static void NoDbgRegParms transferTo(sqInt newProc);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static sqInt NoDbgRegParms updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static usqLong NoDbgRegParms wordSwapped(sqInt w);
static sqInt NeverInline writeImageFileIO(void);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static double NoDbgRegParms NeverInline noInlineLoadFloatOrIntFrom(sqInt floatOrInt);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveTerminateTo(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss usqInt method;
_iss usqInt freeStart;
_iss char * framePointer;
_iss sqInt argumentCount;
_iss sqInt nilObj;
_iss usqInt newMethod;
_iss usqInt youngStart;
_iss sqInt messageSelector;
_iss usqInt instructionPointer;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss StackPage * pages;
_iss sqInt remapBufferCount;
_iss char * stackMemory;
_iss usqInt reserveStart;
_iss sqInt rootTableCount;
_iss char * stackLimit;
_iss sqInt bytesPerPage;
_iss usqInt memoryLimit;
_iss usqInt endOfMemory;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt scavengeThreshold;
_iss sqInt tempOop;
_iss sqInt numStackPages;
_iss sqInt jmpDepth;
_iss sqInt needGCFlag;
_iss usqInt fwdTableNext;
_iss sqLong nextProfileTick;
_iss sqInt profileProcess;
_iss sqInt profileMethod;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt tempOop2;
_iss sqInt statGrowMemory;
_iss sqInt weakRootCount;
_iss sqInt classNameIndex;
_iss sqInt profileSemaphore;
_iss sqInt lkupClass;
_iss sqInt preemptionYields;
_iss sqInt tempOop3;
_iss usqLong nextWakeupUsecs;
_iss sqInt statMarkCount;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss usqInt memory;
_iss sqInt metaclassNumSlots;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt lowSpaceThreshold;
_iss sqInt rootTableOverflowed;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt statTenures;
_iss sqInt thisClassIndex;
_iss usqInt fwdTableLast;
_iss usqLong gcStartUsecs;
_iss sqInt newFinalization;
_iss sqInt pendingFinalizationSignals;
_iss sqInt statCompMoveCount;
_iss sqInt statFullGCs;
_iss usqLong statIOProcessEvents;
_iss sqInt statIncrGCs;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt edenBytes;
_iss sqInt forceTenureFlag;
_iss sqInt imageHeaderFlags;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt signalLowSpace;
_iss usqLong statFullGCUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statNumMaps;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt totalObjectCount;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqLong nextPollUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIdleUsecs;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statPendingFinalizationSignals;
_iss usqLong statProcessSwitch;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt savedWindowSize;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt fullGCLock;
_iss sqInt gcSemaphoreIndex;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss usqInt byteCount;
_iss sqInt interruptCheckCounter;
_iss sqInt lastHash;
_iss sqInt lowcodeCalloutState;
_iss char * nativeFramePointer;
_iss char * nativeSP;
_iss char * nativeStackPointer;
_iss sqInt nsMethodCache;
_iss sqInt numExtB;
_iss char * shadowCallStack;
_iss sqInt shadowCallStackPointer;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt debugCallbackPath;
sqInt checkAllocFiller;
void * displayBits;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
int displayWidth;
sqInt extraVMMemory;
int displayDepth;
sqInt checkForLeaks;
int displayHeight;
sqInt breakSelectorLength = MinSmallInteger;
sqInt inIOProcessEvents;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
sqInt breakLookupClassTag;
char * breakSelector;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
static int (*sHEAFn)() = 0;
static const sqInt headerTypeBytes[] = {
		8, 4, 0, 0
	};
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
sqInt checkedPluginName;
char expensiveAsserts = 0;
const char *interpreterVersion = "Croquet Closure Stack VM [StackInterpreterPrimitives VMMaker.oscog-eem.2250]";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define classFieldOffset() (0 - BaseHeaderSize)
#define compactClassFieldWidth() 5
#define freeStart() GIV(freeStart)
#define instFormatFieldLSB() 8
#define instFormatFieldWidth() 4
#define youngStart() GIV(youngStart)
#define compactClassFieldLSB() 12
#define firstByteFormat() 8
#define firstCompiledMethodFormat() 12
#define firstLongFormat() 6
#define indexablePointersFormat() 3
#define isForwarded(oop) false
#define memory() GIV(memory)
#define remapBufferCount() GIV(remapBufferCount)
#define shiftForWord() 2
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	register sqInt currentBytecode CB_REG;
    sqInt lkupClassTag;
	register char* localFP FP_REG;
	register char* localIP IP_REG;
    sqInt localReturnValue;
	register char* localSP SP_REG;
    sqInt stackPageBytes;
    usqIntptr_t stackPagesBytes;
    void *theStackMemory;
    JUMP_TABLE;

#if MULTIPLEBYTECODESETS
	if(!asserta((sizeof(jumpTable)/sizeof(jumpTable[0])) >= 512))
		error("bytecode jumpTable too small");
#endif

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	/* begin fetchByte */
	currentBytecode = byteAtPointer(++localIP);

	/* begin initExtensions */
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		CASE(0)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(1)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 4 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(2)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(3)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 12 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(4)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(5)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 20 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(6)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(7)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 28 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(8)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(9)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 36 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(10)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(11)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 44 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(12)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(13)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 52 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(14)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(15)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 60 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(16)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(17)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(18)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(19)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(20)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(21)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(22)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(23)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(24)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(25)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(26)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(27)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(28)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(29)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(30)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(31)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(32)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(33)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(34)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(35)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(36)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(37)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(38)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(39)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(40)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(41)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(42)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(43)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(44)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(45)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(46)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(47)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(48)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(49)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(50)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(51)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(52)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(53)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(54)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(55)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(56)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(57)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(58)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(59)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(60)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(61)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(62)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(63)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(64)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(65)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 1 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(66)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 2 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(67)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 3 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(68)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 4 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(69)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 5 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(70)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 6 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(71)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 7 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(72)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 8 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(73)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 9 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(74)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 10 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(75)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 11 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(76)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 12 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(77)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 13 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(78)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 14 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(79)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 15 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(80)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 16 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(81)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 17 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(82)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 18 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(83)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 19 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(84)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 20 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(85)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 21 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(86)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 22 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(87)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 23 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(88)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 24 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(89)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 25 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(90)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 26 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(91)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 27 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(92)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 28 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(93)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 29 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(94)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 30 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(95)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0x1F /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(96)
		CASE(97)
		CASE(98)
		CASE(99)
		CASE(100)
		CASE(101)
		CASE(102)
		CASE(103)
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				/* begin receiver */
				rcvr = longAt(localFP + FoxReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord())))), top);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(104)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(105)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(106)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(107)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(108)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(109)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(110)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(111)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(112)
			/* pushReceiverBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAt(localFP + FoxReceiver);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(113)
			/* pushConstantTrueBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(trueObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(114)
			/* pushConstantFalseBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(falseObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(115)
			/* pushConstantNilBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(nilObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(116)
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			BREAK;
		CASE(117)
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			BREAK;
		CASE(118)
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			BREAK;
		CASE(119)
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			BREAK;
		CASE(120)
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt primBits;
				sqInt primBits1;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFP2;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l373;
				}
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */
				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					closure = longAt((home + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */
				onSamePage = ((((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(home))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));
				theFP2 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP2 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l382;
					}
					if (!((byteAt((theFP2 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP2 + FoxMethod);
						if ((((primBits = (((assert(isCompiledMethod(theMethod1)),
longAt((theMethod1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
						(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == 198) {
							if (theFP2 == theFPAbove) {
								theSP = findSPOfon(theFP2, stackPageFor(theFP2));
							}
							else {
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;

							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP2)));
								ctxtOrNilOrZero = longAt(theFP2 + FoxThisContext);
								goto l382;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP2, theSP);
							goto l382;
						}
					}
					theFPAbove = theFP2;
					theFP2 = pointerForOop(longAt(theFP2 + FoxSavedFP));
				} while(theFP2 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & 1) == 0)
					 && (((((usqInt) (longAt(senderContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
					/* begin nilObject */
					ctxtOrNilOrZero = GIV(nilObj);
					goto l382;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home);
			l382:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
					if ((((primBits1 = (((assert(isCompiledMethod(theMethod)),
longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
					(primBits1 & 0x1FF) + ((((usqInt) primBits1) >> 19) & 512))) == 198) {
						unwindContextOrNilOrZero = home;
						goto l393;
					}
					unwindContextOrNilOrZero = 0;
					goto l393;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						/* begin nilObject */
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l393;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l393:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l374;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l374:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					/* return self */
					goto l373;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l385;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l385:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l373;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);

					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop1 & 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);

						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & 1) == 0)
						 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l392;
					}
					if (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l392;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop2 & 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);

						goto l392;
					}
					if (!(((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))) {
						frameToReturnTo = 0;
						goto l392;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l392:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l377;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l377:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l373;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
							/* begin stackPageFor: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer1 = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((assert(!(isBaseFrame(callerFP))),
(callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l373:	/* end case */;
			BREAK;
		CASE(121)
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				/* begin trueObject */
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			BREAK;
		CASE(122)
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				/* begin falseObject */
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			BREAK;
		CASE(123)
			/* returnNil */
			{
				VM_LABEL(returnNil);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			BREAK;
		CASE(124)
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			BREAK;
		CASE(125)
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				
				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1);

						/* begin stackPageFor: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l405;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l405;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l405:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
							/* begin internalCannotReturn: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l406;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l406:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							/* begin splObj: */
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l402;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* return self */
				l402:	/* end baseFrameReturn */;
					goto l398;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l398:	/* end case */;
			BREAK;
		CASE(126)
		CASE(127)
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (lengthOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l408;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l408:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(128)
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object2;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l32;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l32;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object2 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l32;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object11 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object11);

					goto l32;
				}
			}
		l32:	/* end case */;
			BREAK;
		CASE(129)
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l39;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				error("illegal store");
			l39:	/* end extendedStoreBytecodePop: */;
			}
			BREAK;
		CASE(130)
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;

				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l46;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				error("illegal store");
			l46:	/* end extendedStoreBytecodePop: */;
			}
			BREAK;
		CASE(131)
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(normalSend);
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt aValue;
					sqInt errorCode;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt numTemps;
					sqInt object;
					sqInt probe1;
					sqInt rcvr;
					sqInt succeeded;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					/* begin internalFindNewMethodOrdinary */
					hash1 = GIV(messageSelector) ^ lkupClassTag;

					/* first probe */
					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}

					/* second probe */
					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin classForClassTag: */
					GIV(lkupClass) = lkupClassTag;
					lookupMethodInClass(GIV(lkupClass));

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				l420:	;
				l423:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								aValue = longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
								longAtPointerput(localSP, aValue);
								goto l427;
							}
							if (localPrimIndex == 256) {
								goto l427;
							}
							if (localPrimIndex == 257) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l427;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l427;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l427;
							}
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 1) | 1));
							goto l427;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
						/* begin maybeRetryPrimitiveOnFailure */
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						/* begin successful */
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l427;
						}
					}
					/* begin internalActivateNewMethod */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
						: ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (methodHeader & V3PrimitiveBitsMask) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 0;
						if (GIV(primFailCode) != 0) {
							if ((byteAt(localIP + 1)) == (LongStoreBytecode)) {
								/* begin getErrorObjectFromPrimFailCode */
								if (GIV(primFailCode) > 0) {
									/* begin splObj: */
									table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
									if (GIV(primFailCode) <= (numSlotsOf(table))) {
										errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
										goto l421;
									}
								}
								errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
							l421:	/* end getErrorObjectFromPrimFailCode */;
								longAtPointerput(localSP, errorCode);
							}
							GIV(primFailCode) = 0;
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
											}
				l427:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
			}
			BREAK;
		CASE(132)
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar1;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object3;
				int onCurrentPage;
				sqInt opType;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage * thePage;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l55;
				}
				if (opType == 1) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l55;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushMaybeContextReceiverVariable: */
					obj = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						if (!(((longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(obj)) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						spouseFP = pointerForOop(senderOop - 1);

						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object3 = longAt(spouseFP + FoxCallerContext);
								goto l58;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP)));
								object3 = longAt(callerFP + FoxThisContext);
								goto l58;
							}
							object3 = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP))),
							(spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord));
							goto l58;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object3 = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l58;
						}
						if (byte3 == InstructionPointerIndex) {
							object3 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l58;
						}
						error("bad index");
						object3 = 0;
					l58:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object3);
					}
					else {
						/* begin internalPush: */
						object11 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
						longAtPointerput((localSP -= BytesPerOop), object11);
					}
					goto l55;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object);
					goto l55;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object1);

					goto l55;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar1, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar1, top);
					}
					longAtput((litVar1 + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), top);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l55;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj1 = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt) (longAt(obj1))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
				 && ((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1));
					assert(!((isObjImmutable(obj1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && (!(isWidowedContext(obj1))))) {
						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(obj1, GIV(youngStart))) {
							possibleRootStoreIntovalue(obj1, top);
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
						if (byte3 == StackPointerIndex) {
						}
						goto l70;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop1 & 1));
					theFP = pointerForOop(senderOop1 - 1);

					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l70;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1);
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
					if (byte3 == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l70:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
				}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
		l55:	/* end case */;
			BREAK;
		CASE(133)
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;
				sqInt offset;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				offset = ((assert((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(GIV(method))),
			/* begin fetchPointer:ofObject: */
			longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
				literal = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				if ((literal != GIV(nilObj))
				 && (((literal & 1) == 0)
				 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))) {

					/* filters out fullBlock last literal */
					assert((numSlotsOf(literal)) > ValueIndex);
					classPointer = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
				}
				else {
					/* begin nilObject */
					classPointer = GIV(nilObj);
				}
				superclass = longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				/* begin classTagForClass: */
				lkupClassTag = superclass;
				/* begin ensureReceiverUnforwarded */
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(134)
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			BREAK;
		CASE(135)
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(136)
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(137)
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l83;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l83:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			BREAK;
		CASE(138)
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, 2, size);

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			BREAK;
		CASE(139)
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			BREAK;
		CASE(140)
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				object = longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(141)
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			BREAK;
		CASE(142)
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(143)
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt newClosure;
				sqInt newClosure1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt valuePointer;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				/* begin fetchByte */
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l107;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l107:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			BREAK;
		CASE(144)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(145)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(146)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(147)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(148)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(149)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(150)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(151)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(152)
		CASE(153)
		CASE(154)
		CASE(155)
		CASE(156)
		CASE(157)
		CASE(158)
		CASE(159)
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l110;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l110:	/* end jumplfFalseBy: */;
			}
			BREAK;
		CASE(160)
		CASE(161)
		CASE(162)
		CASE(163)
		CASE(164)
		CASE(165)
		CASE(166)
		CASE(167)
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
									}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(168)
		CASE(169)
		CASE(170)
		CASE(171)
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l115;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l115:	/* end jumplfTrueBy: */;
			}
			BREAK;
		CASE(172)
		CASE(173)
		CASE(174)
		CASE(175)
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l119;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l119:	/* end jumplfFalseBy: */;
			}
			BREAK;
		CASE(176)
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l122;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l125;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l125;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l125;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l125:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l122;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l122:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l126;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l129;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l129;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l129;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l129:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l126;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l126:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l121:	/* end case */;
			BREAK;
		CASE(177)
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l132;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l135;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l135;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l135;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l135:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l132;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l132:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l136;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l139;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l139;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l139;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l139:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l136;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l136:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((1 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l131:	/* end case */;
			BREAK;
		CASE(178)
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l144;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l149;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l149;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l149;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l149:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l144;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l144:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l147;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l143;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l143;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l143;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l143:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l147;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l147:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((2 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l141:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l434;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l434;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);

						goto l434;
					}
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l434:	/* end case */;
			BREAK;
		CASE(179)
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l150;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l153;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l158;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l158;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l158;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l158:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l153;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l153:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l156;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l152;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l152;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l152;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l152:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l156;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l156:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l150;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((3 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l150:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l437;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l437;
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l437:	/* end case */;
			BREAK;
		CASE(180)
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l162;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l167;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l167;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l167;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l167:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l162;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l162:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l165;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l161;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l161;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l161;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l161:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l165;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l165:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((4 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l159:	/* end case */;
			BREAK;
		CASE(181)
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l171;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l176;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l176;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l176;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l176:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l171;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l171:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l174;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l170;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l170;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l170;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l170:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l174;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l174:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((5 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l168:	/* end case */;
			BREAK;
		CASE(182)
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l180;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l185;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l185;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l185;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l185:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l180;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l180:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l183;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l179;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l179;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l179;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l179:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l183;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l183:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((6 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l177:	/* end case */;
			BREAK;
		CASE(183)
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l189;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l194;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l194;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l194;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l194:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l189;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l189:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l192;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l188;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l188;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l188;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l188:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l192;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l192:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((7 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l186:	/* end case */;
			BREAK;
		CASE(184)
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt oop1;
				int overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 1) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l196;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l199;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l199;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l199;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l199:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l196;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l196:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l200;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l203;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l203;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l203;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l203:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l200;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l200:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((8 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l195:	/* end case */;
			BREAK;
		CASE(185)
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
							/* begin fetchNextBytecode */
							/* begin fetchByte */
							currentBytecode = byteAtPointer(++localIP);

							goto l205;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l206;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l209;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l209;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l209;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l209:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l206;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l206:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l210;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l213;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l213;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l213;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l213:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l210;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l210:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l205;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((9 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l205:	/* end case */;
			BREAK;
		CASE(186)
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt oop;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l215;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((10 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l215:	/* end case */;
			BREAK;
		CASE(187)
			/* bytecodePrimMakePoint */
			{
				sqInt arg;
				sqInt oop;
				sqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((((rcvr & 1))
				 || (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))
				 && (((arg & 1))
				 || (((((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))) {
					pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), pt);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l218;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((11 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l218:	/* end case */;
			BREAK;
		CASE(188)
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt shifted;
				char *sp;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l224;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 0x1F)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l224;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l224;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-0x1F))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l224;
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if ((((unsigned int) shifted)) <= (MaxSmallInteger)) {
						shifted = (((usqInt)shifted << 1) | 1);
						goto l229;
					}
					newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
					/* begin storeLong32:ofObject:withValue: */
					valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(shifted);
					long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

					shifted = newLargeInteger;
					goto l229;

				l229:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l224:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l223;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((12 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l223:	/* end case */;
			BREAK;
		CASE(189)
			/* bytecodePrimDiv */
			{
				sqInt oop;
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)quotient << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l231;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((13 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l231:	/* end case */;
			BREAK;
		CASE(190)
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l234;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l234;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((14 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l234:	/* end case */;
			BREAK;
		CASE(191)
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l238;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l238;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((15 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l238:	/* end case */;
			BREAK;
		CASE(192)
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt class;
				sqInt classFormat;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqInt hdr;
				sqInt hdr1;
				sqInt index;
				sqInt index1;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt oop1;
				sqInt oop11;
				sqInt oop13;
				sqInt oop2;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				usqInt result1;
				sqInt stSize;
				sqInt sz1;
				sqInt sz2;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & 1) == 0)
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
							lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
						}
						else {
							/* begin fetchPointer:ofObject: */
							lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
						}
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
						GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((16 * 2)) << (shiftForWord())))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l242;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							/* begin baseHeader: */
							hdr = longAt(rcvr);
							/* begin formatOfHeader: */
							fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l257;
							}
							/* begin lengthOf:baseHeader:format: */
							if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
								sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							else {
								sz1 = hdr & SizeMask;
							}
							sz1 -= hdr & Size4Bit;
							if (fmt <= 4) {
								totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
								goto l258;
							}
							totalLength = (fmt < (firstByteFormat())
								? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
						l258:	/* end lengthOf:baseHeader:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l250;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l250;
							}
							if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
								class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							}
							else {
								/* begin fetchPointer:ofObject: */
								oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
								class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
							}
							classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
						l250:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
						l257:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								/* begin baseHeader: */
								hdr1 = longAt(rcvr);
								/* begin formatOfHeader: */
								fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
								/* begin lengthOf:baseHeader:format: */
								if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
									sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								else {
									sz2 = hdr1 & SizeMask;
								}
								sz2 -= hdr1 & Size4Bit;
								if (fmt1 <= 4) {
									totalLength1 = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
									goto l266;
								}
								totalLength1 = (fmt1 < (firstByteFormat())
									? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
									: (sz2 - BaseHeaderSize) - (fmt1 & 3));
							l266:	/* end lengthOf:baseHeader:format: */;
								fixedFields1 = 0;

								/* special flag for strings */
								fmt1 += 16;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
							l252:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l242;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord())))));
								goto l249;
							}
							if (fmt2 < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								/* begin fetchLong32:ofObject: */
								result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
								/* begin positive32BitIntegerFor: */
								/* begin maybeInlinePositive32BitIntegerFor: */
								assert(!((hasSixtyFourBitImmediates())));
								if ((((unsigned int) result1)) <= (MaxSmallInteger)) {
									result = ((result1 << 1) | 1);
									goto l249;
								}
								newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
								/* begin storeLong32:ofObject:withValue: */
								valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(result1);
								long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

								result = newLargeInteger;
								goto l249;

							}
							if (fmt2 >= 16) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString and DoubleByteString */
								/* begin fetchByte:ofObject: */
								result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));

								if (CharacterTable == null) {
									if (((result1 >= 0) && (result1 <= 0xFF))) {
										/* begin fetchPointer:ofObject: */
										oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
										result = longAt((oop2 + BaseHeaderSize) + (result1 << (shiftForWord())));
									}
									else {
										result = GIV(nilObj);
									}
								}
								else {
									/* begin fetchPointer:ofObject: */
									oop13 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
									result = longAt((oop13 + BaseHeaderSize) + (result1 << (shiftForWord())));
								}
								goto l249;
							}
							else {
								if ((fmt2 < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 1) | 1);
									goto l249;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) >= 2
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l249:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l242;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((16 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l242:	/* end case */;
			BREAK;
		CASE(193)
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt ccIndex3;
				sqInt class;
				sqInt classFormat;
				sqInt classOop;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqInt hdr;
				sqInt hdr1;
				sqInt index;
				sqInt index1;
				sqInt isCharacter;
				sqInt oop;
				sqInt oop1;
				sqInt oop11;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt sz1;
				sqInt sz2;
				sqInt totalLength;
				sqInt totalLength1;
				 int valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				/* begin isOopMutable: */
				correctRcvr = (!((rcvr & 1)))
				 && (!(((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0));

#        else /* IMMUTABILITY */
				/* begin isNonImmediate: */
				correctRcvr = (rcvr & 1) == 0;

#        endif /* IMMUTABILITY */

				if (correctRcvr
				 && ((index & 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
							lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
						}
						else {
							/* begin fetchPointer:ofObject: */
							lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
						}
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
						GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((17 * 2)) << (shiftForWord())))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l272;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							/* begin baseHeader: */
							hdr = longAt(rcvr);
							/* begin formatOfHeader: */
							fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l301;
							}
							/* begin lengthOf:baseHeader:format: */
							if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
								sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							else {
								sz1 = hdr & SizeMask;
							}
							sz1 -= hdr & Size4Bit;
							if (fmt <= 4) {
								totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
								goto l289;
							}
							totalLength = (fmt < (firstByteFormat())
								? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
						l289:	/* end lengthOf:baseHeader:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l294;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l294;
							}
							if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
								class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							}
							else {
								/* begin fetchPointer:ofObject: */
								oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
								class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
							}
							classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
						l294:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
						l301:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								/* begin baseHeader: */
								hdr1 = longAt(rcvr);
								/* begin formatOfHeader: */
								fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
								/* begin lengthOf:baseHeader:format: */
								if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
									sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								else {
									sz2 = hdr1 & SizeMask;
								}
								sz2 -= hdr1 & Size4Bit;
								if (fmt1 <= 4) {
									totalLength1 = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
									goto l309;
								}
								totalLength1 = (fmt1 < (firstByteFormat())
									? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
									: (sz2 - BaseHeaderSize) - (fmt1 & 3));
							l309:	/* end lengthOf:baseHeader:format: */;
								fixedFields1 = 0;

								/* special flag for strings */
								fmt1 += 16;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
							l303:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l272;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								if (oopisLessThan(rcvr, GIV(youngStart))) {
									possibleRootStoreIntovalue(rcvr, value);
								}
								longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord())))), value);
								goto l285;
							}
							if (fmt2 < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									/* begin storeLong32:ofObject:withValue: */
									long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
									goto l285;
								}
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l285;
							}
							if (fmt2 >= 16) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* begin is:instanceOf:compactClassIndex: */
								classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord())))));
								if ((value & 1)) {
									isCharacter = 0;
									goto l291;
								}
								/* begin isClassOfNonImm:equalTo:compactClassIndex: */
								assert(!((value & 1)));
								/* begin compactClassIndexOf: */
								ccIndex3 = (((usqInt) (longAt(value))) >> (compactClassFieldLSB())) & 0x1F;
								if (ccIndex3 == 0) {
									isCharacter = ((longAt(value - BaseHeaderSize)) & AllButTypeMask) == classOop;
									goto l291;
								}
								isCharacter = classOop == (fetchPointerofObject(ccIndex3 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
							l291:	/* end is:instanceOf:compactClassIndex: */;
								if (!isCharacter) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l285;
								}
								valToPut = longAt((value + BaseHeaderSize) + (((int)((usqInt)(CharacterValueIndex) << (shiftForWord())))));
								valToPut = ((valToPut & 1)
									? (valToPut >> 1)
									: -1);

															}
							else {
								if ((fmt2 >= (firstCompiledMethodFormat()))
								 && (index1 < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadIndex;
									goto l285;
								}
								valToPut = ((value & 1)
									? (value >> 1)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l285;
							}
							/* begin storeByte:ofObject:withValue: */
							byteAtput((rcvr + BaseHeaderSize) + (index1 - 1), valToPut);
							goto l285;
						}
						/* begin primitiveFailFor: */
						reasonCode = (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) >= 2
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
						/* return self */
					l285:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l272;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((17 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l272:	/* end case */;
			BREAK;
		CASE(194)
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt fmt;
				sqInt fmt1;
				sqInt header;
				sqInt header1;
				sqInt isArray;
				sqInt isString;
				sqInt oop;
				sqInt rcvr;
				sqInt sz;
				sqInt sz1;
				sqInt sz2;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isString = 0;
					goto l317;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isString = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l317;
				}
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l317;

				isString = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l317:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz1 = header & SizeMask;
					}
					sz1 -= header & Size4Bit;
					if (fmt <= 4) {
						sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
						goto l319;
					}
					sz = (fmt < (firstByteFormat())
						? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
						: (sz1 - BaseHeaderSize) - (fmt & 3));
				l319:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l315;
				}
				/* begin is:instanceOf:compactClassIndex: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isArray = 0;
					goto l320;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isArray = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l320;
				}
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l320;

				isArray = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l320:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf: */
					header1 = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
					if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
						sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz2 = header1 & SizeMask;
					}
					sz2 -= header1 & Size4Bit;
					if (fmt1 <= 4) {
						sz = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
						goto l322;
					}
					sz = (fmt1 < (firstByteFormat())
						? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
						: (sz2 - BaseHeaderSize) - (fmt1 & 3));
				l322:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l315;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((18 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l315:	/* end case */;
			BREAK;
		CASE(195)
			/* bytecodePrimNext */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((19 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(196)
			/* bytecodePrimNextPut */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((20 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(197)
			/* bytecodePrimAtEnd */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((21 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(198)
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(199)
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt ccIndex;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				/* begin internalStackTopPut: */
				if ((rcvr & 1)) {
					/* begin fetchPointer:ofObject: */
					aValue = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						aValue = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						aValue = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(200)
			/* bytecodePrimNotIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(201)
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l335;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l335;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l335:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l334;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((25 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l334:	/* end case */;
			BREAK;
		CASE(202)
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l340;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l340;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l340:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l339;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((26 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l339:	/* end case */;
			BREAK;
		CASE(203)
			/* bytecodePrimDo */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((27 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(204)
			/* bytecodePrimNew */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((28 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(205)
			/* bytecodePrimNewWithArg */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((29 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			BREAK;
		CASE(206)
			/* bytecodePrimPointX */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l347;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((30 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l347:	/* end case */;
			BREAK;
		CASE(207)
			/* bytecodePrimPointY */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l354;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0x1F * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l354:	/* end case */;
			BREAK;
		CASE(208)
		CASE(209)
		CASE(210)
		CASE(211)
		CASE(212)
		CASE(213)
		CASE(214)
		CASE(215)
		CASE(216)
		CASE(217)
		CASE(218)
		CASE(219)
		CASE(220)
		CASE(221)
		CASE(222)
		CASE(223)
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 0;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(224)
		CASE(225)
		CASE(226)
		CASE(227)
		CASE(228)
		CASE(229)
		CASE(230)
		CASE(231)
		CASE(232)
		CASE(233)
		CASE(234)
		CASE(235)
		CASE(236)
		CASE(237)
		CASE(238)
		CASE(239)
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 1;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(240)
		CASE(241)
		CASE(242)
		CASE(243)
		CASE(244)
		CASE(245)
		CASE(246)
		CASE(247)
		CASE(248)
		CASE(249)
		CASE(250)
		CASE(251)
		CASE(252)
		CASE(253)
		CASE(254)
		CASE(255)
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 2;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		}
	}

	/* undo the pre-increment of IP before returning */
	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statNumMaps) == 0
		? 0.0
		: (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps));
}

	/* InterpreterPrimitives>>#canBeImmutable: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
canBeImmutable(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;
    sqInt processLists;
    sqInt scheduler;

	assert(isNonImmediate(oop));
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	if (isEphemeron(oop)) {
		return 0;
	}
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
		return 0;
	}
	if (((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	processLists = longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	if (oop == scheduler) {
		return 0;
	}
	if (oop == processLists) {
		return 0;
	}
	if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1U << (shiftForWord()))))) == (classIndexOf(oop))) {
		return 0;
	}
	if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord()))))))) == (classIndexOf(oop))) {
		return 0;
	}
	return 1;
}
#endif /* IMMUTABILITY */


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    char *cString;
    sqInt fmt;
    sqInt header;
    sqInt isString;
    sqInt len;
    sqInt sz;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
	if ((oop & 1)) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isString = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;

	isString = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l4;
	}
	len = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l4:	/* end lengthOf: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static sqInt NoDbgRegParms
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt ok;
    sqInt smallInt;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 1;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static sqInt NoDbgRegParms
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    int isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;
    sqLong value1;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return (((usqInt)smallVal << 1) | 1);
	}
	if (isNegative) {
		/* begin splObj: */
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	}
	else {
		/* begin splObj: */
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	}
	if (((highWord = magnitude >> 32)) == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
			if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
				sz += 1;
				if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
					sz += 1;
				}
			}
		}
	}

	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	if (sz > 4) {
		/* begin storeLong64:ofObject:withValue: */
		value1 = SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value1);
		long32Atput(((newLargeInteger + BaseHeaderSize) + (0U << 3)) + 4, ((unsigned sqLong)value1) >> 32);
	}
	else {
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude));
	}

	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static usqLong NoDbgRegParms
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#noInlineSigned32BitValueGutsOf: */
static int NoDbgRegParms
noInlineSigned32BitValueGutsOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    unsigned int magnitude;
    sqInt negative;
    sqInt ok;
    int value;

	assert(!((hasSixtyFourBitImmediates())));
	assert(!(((oop & 1))));
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	if ((numBytesOfBytes(oop)) > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	if ((negative
		? magnitude > 0x80000000U
		: magnitude >= 0x80000000U)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
unsigned int
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt sz;
    sqInt value;

	/* begin maybeInlinePositive32BitValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));


}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		if (((oop >> 1)) < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
usqIntptr_t
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {
		return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ ((((usqInt)integerResult)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((arg & 1))
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & 1))
	 || (!(objCouldBeClassObj(rcvr)))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt delta1;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		/* begin growObjectMemory: */
		delta1 = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), delta1);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((result & 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt delta1;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		/* begin growObjectMemory: */
		delta1 = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), delta1);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allObjects();
		if ((result & 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(atan(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's element's identity hash over the argument's elementy's
	identity hash.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHash */
static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt oop;
    sqInt oop1;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((characterCode & 1))
		 && (((characterCode = (characterCode >> 1)),
		((characterCode >= 0) && (characterCode <= 0xFF)))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		GIV(primFailCode) = reasonCode;
		return;
	}
	if (CharacterTable == null) {
		if (((characterCode >= 0) && (characterCode <= 0xFF))) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
			characterObject = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(characterCode) << (shiftForWord())))));
		}
		else {
			characterObject = GIV(nilObj);
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
		characterObject = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)(characterCode) << (shiftForWord())))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((rcvr & 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 1)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop11;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueWord1;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l14;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l14;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l13;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l13;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l13;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l13;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		result = newLargeInteger;
		goto l13;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l13:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l14:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex1;
    sqInt class1;
    sqInt classFormat1;
    sqInt fixedFields1;
    sqInt fmt1;
    sqInt hdr1;
    sqInt index;
    sqInt oop11;
    sqInt rcvr;
    sqInt reasonCode1;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp11;
    sqInt sp3;
    sqInt stSize1;
    sqInt sz1;
    sqInt totalLength1;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l29;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l29;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l29;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	hdr1 = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr1 & SizeMask;
	}
	sz1 -= hdr1 & Size4Bit;
	if (fmt1 <= 4) {
		totalLength1 = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l24;
	}
	totalLength1 = (fmt1 < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt1 & 3));
l24:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 > 4)
	 || (fmt1 == 2)) {
		fixedFields1 = 0;
		goto l15;
	}
	if (fmt1 < 2) {
		fixedFields1 = totalLength1;
		goto l15;
	}
	if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class1 = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class1 = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
	}
	classFormat1 = (longAt((class1 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields1 = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 0x3F)) - 1;
l15:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat()))
	 && (((((usqInt) hdr1) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l16;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp11 & 1))) {
			stSize1 = 0;
			goto l16;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 1);
	l16:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize1))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l28;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize1))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, value);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))), value);
			goto l27;
		}
		if (fmt1 >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l27;
			}
			signedValueToStore1 = (value >> 1);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l27;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
			goto l27;
		}
		unsignedValueToStore1 = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
		}
	l27:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
l28:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l29:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin success: */
		successBoolean = (((cursorObj & 1) == 0)
		 && (((((usqInt) (longAt(cursorObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(cursorObj)) >= 5);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0U << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4U << (shiftForWord())));
		/* begin success: */
		successBoolean1 = (((offsetObj & 1) == 0)
		 && (((((usqInt) (longAt(offsetObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(offsetObj)) >= 2);
		if (!successBoolean1) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			/* begin success: */
			successBoolean2 = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean4 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == (extentX * extentY));
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
		else {
			/* begin success: */
			successBoolean6 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean8 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean12 = (((maskObj & 1) == 0)
		 && (((((usqInt) (longAt(maskObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(maskObj)) >= 5);
		if (!successBoolean12) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0U << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean10 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean10) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean11 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean11) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable,
	and if possible pin the display bitmap. Further, invoke ioBeDisplay
	to alow the VM to record the location, width heigth & depth of the bitmap. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsOop;
    void *bitsOrHandle;
    int changed;
    sqInt depthOop;
    sqInt heightOop;
    sqInt rcvr;
    sqInt widthOop;

	rcvr = longAt(GIV(stackPointer));
	if (!((((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && (((lengthOf(rcvr)) >= 4)
		 && (((bitsOop = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())))),
		((((bitsOop & 1) == 0)
			 && (isWordsOrBytesNonImm(bitsOop)))
			 || ((bitsOop & 1)))
			 && (((((widthOop = longAt((rcvr + BaseHeaderSize) + (1U << (shiftForWord()))))) & 1))
			 && (((((heightOop = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord()))))) & 1))
			 && ((((depthOop = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord()))))) & 1))))))))) {
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	/* begin splObj:put: */
	if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(specialObjectsOop), rcvr);
	}
	longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))), rcvr);
	/* begin ioBeDisplay:width:height:depth: */
	bitsOrHandle = ((bitsOop & 1) == 0
		? firstIndexableField(bitsOop)
		: bitsOop);
	changed = displayBits != bitsOrHandle;
	displayBits = bitsOrHandle;
	displayWidth = (widthOop >> 1);
	displayHeight = (heightOop >> 1);
	displayDepth = (depthOop >> 1);
	ioNoteDisplayChangedwidthheightdepth(bitsOrHandle, (widthOop >> 1), (heightOop >> 1), (depthOop >> 1));
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hashOrError;
    char *sp;

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	hashOrError = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> HashBitsOffset) & HashMaskUnshifted;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	bs = numBytesOfBytes(oop1);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop1)))));
		goto l3;
	}
	else {
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l3;
	}
l3:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop2 & 1)) {
		value1 = (oop2 >> 1);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop2 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok1 = ((longAt(oop2 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;

	ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	bs1 = numBytesOfBytes(oop2);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop2)))));
		goto l6;
	}
	else {
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l6;
	}
l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue & integerReceiverValue);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	bs = numBytesOfBytes(oop1);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop1)))));
		goto l3;
	}
	else {
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l3;
	}
l3:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop2 & 1)) {
		value1 = (oop2 >> 1);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop2 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok1 = ((longAt(oop2 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;

	ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	bs1 = numBytesOfBytes(oop2);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop2)))));
		goto l6;
	}
	else {
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l6;
	}
l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue | integerReceiverValue);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt newLargeInteger;
    sqInt shifted;
    char *sp;
    sqInt valueWord1;

	integerArgument = longAt(GIV(stackPointer));
	if (!((integerArgument & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = positive32BitValueOf(integerReceiver);

	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 1))) >= 0) {

			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 0x1F)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
			if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-0x1F))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
		}
		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) shifted)) <= (MaxSmallInteger)) {
			shifted = (((usqInt)shifted << 1) | 1);
			goto l4;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(shifted);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		shifted = newLargeInteger;
		goto l4;

	l4:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */

		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt integerArgument;
    usqInt integerArgumentValue;
    sqInt integerReceiver;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt value;
    sqInt value1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerArgument & 1))
	 && ((integerReceiver & 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerArgument ^ integerReceiver) + 1);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin positiveMachineIntegerValueOf: */
		if ((integerArgument & 1)) {
			value = (integerArgument >> 1);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerArgumentValue = ((usqIntptr_t) null);
				goto l3;
			}
			integerArgumentValue = ((usqIntptr_t) value);
			goto l3;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
		assert(!((integerArgument & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(integerArgument))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(integerArgument - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) 0);
			goto l3;
		}
		bs = numBytesOfBytes(integerArgument);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) 0);
			goto l3;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerArgument)))));
			goto l3;
		}
		else {
			integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerArgument + BaseHeaderSize) + (0U << 2))))))));
			goto l3;
		}
	l3:	/* end positiveMachineIntegerValueOf: */;
		/* begin positiveMachineIntegerValueOf: */
		if ((integerReceiver & 1)) {
			value1 = (integerReceiver >> 1);
			if (value1 < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerReceiverValue = ((usqIntptr_t) null);
				goto l6;
			}
			integerReceiverValue = ((usqIntptr_t) value1);
			goto l6;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
		assert(!((integerReceiver & 1)));
		/* begin compactClassIndexOf: */
		ccIndex1 = (((usqInt) (longAt(integerReceiver))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex1 == 0) {
			ok1 = ((longAt(integerReceiver - BaseHeaderSize)) & AllButTypeMask) == classOop1;
			goto l5;
		}
		ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
		goto l5;

		ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok1) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) 0);
			goto l6;
		}
		bs1 = numBytesOfBytes(integerReceiver);
		if (bs1 > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) 0);
			goto l6;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs1 > 4)) {
			integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerReceiver)))));
			goto l6;
		}
		else {
			integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerReceiver + BaseHeaderSize) + (0U << 2))))))));
			goto l6;
		}
	l6:	/* end positiveMachineIntegerValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			oop = positiveMachineIntegerFor(integerArgumentValue ^ integerReceiverValue);
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Answer bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    sqInt integerVal2;
    char *sp;
    char *sp2;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */
		/* begin pop:thenPushInteger: */
		integerVal = (oopisLessThan(GIV(freeStart), GIV(reserveStart))
			? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
			: 0);
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* Spur behavior; if argument is nil answer size of largest free chunk in oldSpace. */
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal2 = ((oopisLessThan(GIV(freeStart), GIV(reserveStart))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(aBool));
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal2 << 1) | 1));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) function);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt ccIndex;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l2;
	}
	arg = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop1;
l3:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	if (((ccIndex = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		argClass = (longAt(arg - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		argClass = longAt((oop2 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt instance;
    sqInt oop;
    sqInt oop1;
    char *sp;

	instance = longAt(GIV(stackPointer));
	/* begin pop:thenPush: */
	if ((instance & 1)) {
		/* begin splObj: */
		oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(instance))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			oop = (longAt(instance - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			oop = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;

}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & 1) == 0)
			 && (((((usqInt) (longAt(s))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			sz = numBytesOfBytes(s);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);

		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;
    sqInt valueWord1;
    sqInt valueWord11;


	/* bypass type inference which would deduce int */
	midx = 0;
	msecs = 0;
	uidx = 0;
	usecs = 0;
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)runInNOut << 1) | 1));
	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)usecs)))) <= (MaxSmallInteger)) {
		v1 = (((((usqInt)usecs)) << 1) | 1);
		goto l11;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)usecs)));
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	v1 = newLargeInteger;
	goto l11;

l11:	/* end positive32BitIntegerFor: */;
	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)msecs)))) <= (MaxSmallInteger)) {
		v2 = (((((usqInt)msecs)) << 1) | 1);
		goto l15;
	}
	newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord11 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)msecs)));
	long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord11);

	v2 = newLargeInteger1;
	goto l15;

l15:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v1);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (1U << (shiftForWord())), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (2U << (shiftForWord())), (((usqInt)uidx << 1) | 1));
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v2);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (3U << (shiftForWord())), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (4U << (shiftForWord())), (((usqInt)midx << 1) | 1));
	/* begin pop:thenPush: */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt sz;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Return the value of the microsecond clock in the local timezone, as
	updated by the heartbeat, as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseLocalMicrosecondClock */
static void
primitiveCoarseLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicroseconds());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the microsecond clock as updated by the heartbeat as
	an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseUTCMicrosecondClock */
static void
primitiveCoarseUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicroseconds());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(void)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt i;
    sqInt len1;
    sqInt len2;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & 1) == 0)
		 && (((((usqInt) (longAt(arg1))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && (((arg2 & 1) == 0)
		 && (((((usqInt) (longAt(arg2))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOf: */
	if ((arg1 & 1)) {
		len1 = 0;
		goto l1;
	}
	len1 = numBytesOf(arg1);
l1:	/* end byteSizeOf: */;
	/* begin byteSizeOf: */
	if ((arg2 & 1)) {
		len2 = 0;
		goto l2;
	}
	len2 = numBytesOf(arg2);
l2:	/* end byteSizeOf: */;
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable non-pointer
	object, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end1;
     int fillValue1;
    usqInt i1;
    sqInt rcvr1;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveConstantFillV3 */
	fillValue1 = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr1 & 1) == 0)
	 && (isWordsOrBytesNonImm(rcvr1));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (((rcvr1 & 1) == 0)
	 && (((((usqInt) (longAt(rcvr1))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
		/* begin success: */
		successBoolean = (fillValue1 >= 0)
		 && (fillValue1 <= 0xFF);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		fillValue1 = ((fillValue1 + (((int)((usqInt)(fillValue1) << 8)))) + (((int)((usqInt)(fillValue1) << 16)))) + (((int)((usqInt)(fillValue1) << 24)));
	}
	if (!GIV(primFailCode)) {
		end1 = rcvr1 + (sizeBitsOf(rcvr1));
		i1 = rcvr1 + BaseHeaderSize;
		while (i1 < end1) {
			long32Atput(i1, fillValue1);
			i1 += 4;
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}

}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), (((usqInt)numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt header;
    sqInt i;
    sqInt length;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt sz;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((arg & 1)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) != ((((ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(arg - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord()))))))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (isWordsOrBytesNonImm(rcvr)) {
		length = numBytesOf(rcvr);
		if (!((((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) == ((((usqInt) (longAt(arg))) >> (instFormatFieldLSB())) & 15))
			 && (length == (numBytesOf(arg))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOf(arg))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		for (i = 0; i < length; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, valuePointer);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((longAt(GIV(stackPointer))) & 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 1);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)quotient)) ^ ((((usqInt)quotient)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((sqInt)((((usqInt)(integerReceiver / integerArgument))) ^ ((((usqInt)(integerReceiver / integerArgument))) << 1)))) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)(integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}

			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */
			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt oop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(criticalSection, GIV(youngStart))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) == (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if ((assert(!(isForwarded(criticalSection))),
	(longAt((criticalSection + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection);
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(exp(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Exponent part of this float.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    int pwr;
    double rcvr;
    double result;

	pwr = 0;
	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */
		frexp(rcvr, (&pwr));
		longAtPointerput(GIV(stackPointer), (((usqInt)(pwr - 1) << 1) | 1));
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;
    sqInt valueWord1;
    sqInt valueWord11;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		/* begin positive32BitIntegerFor: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		integerValue = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l5;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		result = newLargeInteger;
		goto l5;

	l5:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin positive32BitIntegerFor: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		integerValue1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue1)) <= (MaxSmallInteger)) {
			result = ((integerValue1 << 1) | 1);
			goto l9;
		}
		newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord11 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue1);
		long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord11);

		result = newLargeInteger1;
		goto l9;

	l9:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
