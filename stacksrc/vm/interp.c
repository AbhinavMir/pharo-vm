/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
   from
	StackInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.2250 uuid: 0726505e-161b-4a23-843e-c5222917ff5e " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sq.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 * Note: on windows 64 via mingw-w64, the 2nd argument NULL to _setjmp prevents stack unwinding
 */
#undef sigsetjmp
#undef siglongjmp
#if _MSC_VER
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN64 && __GNUC__
# define sigsetjmp(jb,ssmf) _setjmp(jb,NULL)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

#define odd(v) ((int)(v)&1)
#define even(v) (!odd(v))

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFU
#define AllButMarkBit 0x7FFFFFFF
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFU
#define AllButTypeMask 0xFFFFFFFCU
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BytecodeSetHasExtensions 0
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 0
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMessageCompactIndex 0
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne 0xFFFFFFFFU
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DoAssertionChecks 0
#define DoExpensiveAssertionChecks 0
#define Done 4
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define FullClosureFirstCopiedValueIndex 4
#define GCCheckPrimCall 64
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GCTopMarker 3
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define ImmutabilityBit 0x20000000
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCU
#define LongSizeNumBits 30
#define LongStoreBytecode 129
#define LowcodeVM 0
#define MarkBit 0x80000000U
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MULTIPLEBYTECODESETS 0
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheSize 4096
#if !defined(PharoVM) /* Allow this to be overridden on the compiler command line */
# define PharoVM 0
#endif
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimNoErr 0
#define PrimNumberExternalCall 117
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSlots 22
#define SPURVM 0
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFU
#define XIndex 0
#define YIndex 1

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
static int NoDbgRegParms noInlineSigned32BitValueGutsOf(sqInt oop);
extern unsigned int positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCoarseLocalMicrosecondClock(void);
static void primitiveCoarseUTCMicrosecondClock(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
static sqInt NoDbgRegParms addressCouldBeObjWhileForwarding(sqInt address);
extern sqInt addressCouldBeObj(sqInt address);
static sqInt NoDbgRegParms adjustAllOopsBy(sqInt bytesToShift);
static sqInt NoDbgRegParms allInstancesOf(sqInt aBehavior);
static sqInt allObjectsUnmarked(void);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern sqInt characterValueOf(sqInt oop);
static sqInt checkHeapIntegrity(void);
extern sqInt checkOkayOop(usqInt oop);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
static void clearLeakMapAndMapAccessibleObjects(void);
extern sqInt clone(sqInt obj);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
extern sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms eeInstantiateMethodContextSlots(sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt oop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern void fullGC(void);
static sqInt NoDbgRegParms fwdTableInit(sqInt blkSize);
static sqInt NoDbgRegParms fwdTableSize(sqInt blkSize);
static usqInt imageSegmentVersion(void);
static sqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static sqInt NoDbgRegParms incCompMove(sqInt bytesFreed);
extern void incrementalGC(void);
static void NoDbgRegParms initializeMemoryFirstFree(sqInt firstFree);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
extern sqInt isYoungObject(sqInt obj);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckNewSpaceGC(void);
extern sqInt literalCountOfMethodHeader(sqInt methodHeader);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintReferencesTo(sqInt anOop);
static void NoDbgRegParms mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms markPhase(sqInt fullGCFlag);
static sqInt newSpaceBytes(void);
extern sqInt objectAfter(sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
static sqInt NoDbgRegParms oopHasAcceptableClass(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
extern void printActivationsOf(sqInt aMethodObj);
extern void printContextReferencesTo(sqInt anOop);
extern void printMemory(void);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printWronglySizedContexts(sqInt printContexts);
static void NoDbgRegParms restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static sqInt NoDbgRegParms safeObjectAfter(sqInt oop);
extern sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots);
static sqInt NoDbgRegParms sizeBitsOfSafe(sqInt oop);
static sqInt NoDbgRegParms sizeBitsOf(sqInt oop);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt minFree);
static sqInt NoDbgRegParms sufficientSpaceToAllocate(sqInt bytes);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
extern void unpinObject(sqInt objOop);
static void verifyCleanHeaders(void);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt allObjects(void);
static sqInt NoDbgRegParms allYoungand(sqInt array1, sqInt array2);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms badContextSize(sqInt oop);
extern sqInt becomewith(sqInt array1, sqInt array2);
extern void beRootIfOld(sqInt oop);
static void NoDbgRegParms beRootWhileForwarding(sqInt oop);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned int byteSwapped32IfBigEndian(unsigned int w);
extern unsigned long long byteSwapped64IfBigEndian(unsigned long long w);
extern sqInt byteSwapped(sqInt w);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern sqInt characterTable(void);
extern sqInt checkedLongAt(sqInt byteAddress);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classHeader(sqInt oop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classUnsafeAlien(void);
static void clearRootsTable(void);
extern sqInt compactClassAt(sqInt ccIndex);
extern sqInt compactClassIndexOfClass(sqInt classObj);
extern sqInt compactClassIndexOfHeader(sqInt header);
extern sqInt compactClassIndexOf(sqInt oop);
static sqInt NoDbgRegParms compactIndexOfClass(sqInt aClassOop);
static sqInt NoDbgRegParms containOnlyOops(sqInt array);
static sqInt NoDbgRegParms containOnlyOopsand(sqInt array1, sqInt array2);
static sqInt NoDbgRegParms copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
extern sqInt displayObject(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqLong NoDbgRegParms fetchLong64ofObject(sqInt longIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static void NoDbgRegParms finalizeReference(usqInt oop);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt oop);
extern void * firstIndexableField(sqInt oop);
static sqInt firstStringyFakeFormat(void);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms followForwarded(sqInt objOop);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOfHeader(sqInt header);
static sqInt NoDbgRegParms fwdBlockValid(sqInt addr);
#if PharoVM
static float getHeapGrowthToSizeGCRatio(void);
#endif /* PharoVM */
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms hasForwardingBlock(sqInt objOop);
static sqInt hasSixtyFourBitImmediates(void);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt objectPointer);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
static sqInt NoDbgRegParms isCompiledMethodHeader(sqInt objHeader);
extern sqInt isCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
extern sqInt isImmediate(sqInt anOop);
extern sqInt isIndexable(sqInt oop);
extern sqInt isInMemory(sqInt address);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt oop);
extern sqInt isNonImmediate(sqInt anOop);
extern sqInt isNonIntegerObject(sqInt objectPointer);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop);
extern sqInt isOopCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt anOop);
extern sqInt isOopMutable(sqInt anOop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
static sqInt NoDbgRegParms isWeakNonImm(sqInt oop);
extern sqInt isWeak(sqInt oop);
static sqInt NoDbgRegParms isWordsOrBytesNonImm(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt oop);
static sqInt NoDbgRegParms lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
extern sqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
static sqInt NoDbgRegParms lowestFreeAfter(sqInt chunk);
extern sqInt markAndTrace(sqInt oop);
extern sqInt maybeSplObj(sqInt index);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
extern sqInt minSlotsForShortening(void);
extern sqInt nilObject(void);
extern sqInt noShiftCompactClassIndexOfHeader(sqInt header);
extern sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
extern sqInt numSlotsOf(sqInt obj);
extern sqInt objectBefore(sqInt address);
extern sqInt objectExactlyBefore(sqInt oop);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms oopFromChunk(sqInt chunk);
static sqInt NoDbgRegParms oopHasOkayClass(sqInt signedOop);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
extern sqInt primitiveErrorTable(void);
extern void printInstancesOf(sqInt aClassOop);
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms remapObj(sqInt obj);
extern sqInt remap(sqInt oop);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static sqInt NoDbgRegParms removeYoungRoot(sqInt obj);
extern sqInt shouldRemapObj(sqInt oop);
extern sqInt shouldRemapOop(sqInt oop);
static sqInt sixtyFourBitIndexableFormat(void);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
EXPORT(sqInt) statNumGCs(void);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
extern void tenuringIncrementalGC(void);
extern sqInt topRemappableOop(void);
extern sqInt trueObject(void);
static void NoDbgRegParms updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
extern sqInt vmEndianness(void);
extern sqInt activeProcess(void);
extern void addIdleUsecs(sqInt idleUsecs);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static sqInt NoDbgRegParms checkStackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms checkStackPointerIndexForFrame(char *theFP);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copiedValueCountOfFullClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
extern sqInt disownVM(sqInt flags);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
extern void dumpPrimTraceLog(void);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt meth);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
extern double floatArg(sqInt index);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static sqInt NoDbgRegParms frameContext(char *theFP);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameMethod(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(void);
static sqInt getDesiredCogCodeSize(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static void NeverInline handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern usqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern sqInt integerArg(sqInt index);
static sqInt NeverInline interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isStillMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
static void NoDbgRegParms makeContextSnapshotSafe(sqInt ctxt);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void NeverInline mapStackPages(void);
static sqInt NoDbgRegParms markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceInterpreterOops(sqInt fullGCFlag);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms NeverInline noInlineSigned32BitIntegerGutsFor(sqInt integerValue);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt ownVM(sqInt threadIndexAndFlags);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
static sqInt NoDbgRegParms positiveMachineIntegerFor(usqIntptr_t value);
static void NoDbgRegParms postGCAction(sqInt gcModeArg);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printHexnp(sqInt n);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern sqInt printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(sqInt aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static sqInt NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
static void NoDbgRegParms transferTo(sqInt newProc);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static sqInt NoDbgRegParms updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static usqLong NoDbgRegParms wordSwapped(sqInt w);
static sqInt NeverInline writeImageFileIO(void);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static double NoDbgRegParms NeverInline noInlineLoadFloatOrIntFrom(sqInt floatOrInt);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveTerminateTo(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss usqInt method;
_iss usqInt freeStart;
_iss char * framePointer;
_iss sqInt argumentCount;
_iss sqInt nilObj;
_iss usqInt newMethod;
_iss usqInt youngStart;
_iss sqInt messageSelector;
_iss usqInt instructionPointer;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss StackPage * pages;
_iss sqInt remapBufferCount;
_iss char * stackMemory;
_iss usqInt reserveStart;
_iss sqInt rootTableCount;
_iss char * stackLimit;
_iss sqInt bytesPerPage;
_iss usqInt memoryLimit;
_iss usqInt endOfMemory;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt scavengeThreshold;
_iss sqInt tempOop;
_iss sqInt numStackPages;
_iss sqInt jmpDepth;
_iss sqInt needGCFlag;
_iss usqInt fwdTableNext;
_iss sqLong nextProfileTick;
_iss sqInt profileProcess;
_iss sqInt profileMethod;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt tempOop2;
_iss sqInt statGrowMemory;
_iss sqInt weakRootCount;
_iss sqInt classNameIndex;
_iss sqInt profileSemaphore;
_iss sqInt lkupClass;
_iss sqInt preemptionYields;
_iss sqInt tempOop3;
_iss usqLong nextWakeupUsecs;
_iss sqInt statMarkCount;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss usqInt memory;
_iss sqInt metaclassNumSlots;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt lowSpaceThreshold;
_iss sqInt rootTableOverflowed;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt statTenures;
_iss sqInt thisClassIndex;
_iss usqInt fwdTableLast;
_iss usqLong gcStartUsecs;
_iss sqInt newFinalization;
_iss sqInt pendingFinalizationSignals;
_iss sqInt statCompMoveCount;
_iss sqInt statFullGCs;
_iss usqLong statIOProcessEvents;
_iss sqInt statIncrGCs;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt edenBytes;
_iss sqInt forceTenureFlag;
_iss sqInt imageHeaderFlags;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt signalLowSpace;
_iss usqLong statFullGCUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statNumMaps;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt totalObjectCount;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqLong nextPollUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIdleUsecs;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statPendingFinalizationSignals;
_iss usqLong statProcessSwitch;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt savedWindowSize;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt fullGCLock;
_iss sqInt gcSemaphoreIndex;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss usqInt byteCount;
_iss sqInt interruptCheckCounter;
_iss sqInt lastHash;
_iss sqInt lowcodeCalloutState;
_iss char * nativeFramePointer;
_iss char * nativeSP;
_iss char * nativeStackPointer;
_iss sqInt nsMethodCache;
_iss sqInt numExtB;
_iss char * shadowCallStack;
_iss sqInt shadowCallStackPointer;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt debugCallbackPath;
sqInt checkAllocFiller;
void * displayBits;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
int displayWidth;
sqInt extraVMMemory;
int displayDepth;
sqInt checkForLeaks;
int displayHeight;
sqInt breakSelectorLength = MinSmallInteger;
sqInt inIOProcessEvents;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
sqInt breakLookupClassTag;
char * breakSelector;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
static int (*sHEAFn)() = 0;
static const sqInt headerTypeBytes[] = {
		8, 4, 0, 0
	};
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
sqInt checkedPluginName;
char expensiveAsserts = 0;
const char *interpreterVersion = "Croquet Closure Stack VM [StackInterpreterPrimitives VMMaker.oscog-eem.2250]";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define classFieldOffset() (0 - BaseHeaderSize)
#define compactClassFieldWidth() 5
#define freeStart() GIV(freeStart)
#define instFormatFieldLSB() 8
#define instFormatFieldWidth() 4
#define youngStart() GIV(youngStart)
#define compactClassFieldLSB() 12
#define firstByteFormat() 8
#define firstCompiledMethodFormat() 12
#define firstLongFormat() 6
#define indexablePointersFormat() 3
#define isForwarded(oop) false
#define memory() GIV(memory)
#define remapBufferCount() GIV(remapBufferCount)
#define shiftForWord() 2
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt lkupClassTag;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    usqIntptr_t stackPagesBytes;
    void *theStackMemory;

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	/* begin fetchByte */
	currentBytecode = byteAtPointer(++localIP);

	/* begin initExtensions */
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 4 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 12 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 20 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 28 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 36 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 44 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 52 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 60 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 1 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 2 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 3 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 4 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 5 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 6 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 7 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 8 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 9 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 10 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 11 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 12 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 13 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 14 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 15 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 16 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 17 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 18 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 19 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 20 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 21 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 22 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 23 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 24 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 25 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 26 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 27 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 28 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 29 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 30 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0x1F /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				/* begin receiver */
				rcvr = longAt(localFP + FoxReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord())))), top);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
			/* pushReceiverBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAt(localFP + FoxReceiver);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(trueObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(falseObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(nilObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt primBits;
				sqInt primBits1;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFP2;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l373;
				}
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */
				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					closure = longAt((home + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */
				onSamePage = ((((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(home))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));
				theFP2 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP2 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l382;
					}
					if (!((byteAt((theFP2 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP2 + FoxMethod);
						if ((((primBits = (((assert(isCompiledMethod(theMethod1)),
longAt((theMethod1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
						(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == 198) {
							if (theFP2 == theFPAbove) {
								theSP = findSPOfon(theFP2, stackPageFor(theFP2));
							}
							else {
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;

							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP2)));
								ctxtOrNilOrZero = longAt(theFP2 + FoxThisContext);
								goto l382;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP2, theSP);
							goto l382;
						}
					}
					theFPAbove = theFP2;
					theFP2 = pointerForOop(longAt(theFP2 + FoxSavedFP));
				} while(theFP2 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & 1) == 0)
					 && (((((usqInt) (longAt(senderContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
					/* begin nilObject */
					ctxtOrNilOrZero = GIV(nilObj);
					goto l382;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home);
			l382:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
					if ((((primBits1 = (((assert(isCompiledMethod(theMethod)),
longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
					(primBits1 & 0x1FF) + ((((usqInt) primBits1) >> 19) & 512))) == 198) {
						unwindContextOrNilOrZero = home;
						goto l393;
					}
					unwindContextOrNilOrZero = 0;
					goto l393;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						/* begin nilObject */
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l393;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l393:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l374;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l374:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					/* return self */
					goto l373;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l385;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l385:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l373;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);

					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop1 & 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);

						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & 1) == 0)
						 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l392;
					}
					if (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l392;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop2 & 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);

						goto l392;
					}
					if (!(((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))) {
						frameToReturnTo = 0;
						goto l392;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l392:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l377;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l377:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l373;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
							/* begin stackPageFor: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer1 = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((assert(!(isBaseFrame(callerFP))),
(callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l373:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				/* begin trueObject */
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				/* begin falseObject */
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
			/* returnNil */
			{
				VM_LABEL(returnNil);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				
				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1);

						/* begin stackPageFor: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l405;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l405;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l405:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
							/* begin internalCannotReturn: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l406;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l406:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							/* begin splObj: */
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l402;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* return self */
				l402:	/* end baseFrameReturn */;
					goto l398;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l398:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (lengthOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l408;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l408:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object2;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l32;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l32;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object2 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l32;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object11 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object11);

					goto l32;
				}
			}
		l32:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l39;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				error("illegal store");
			l39:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;

				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l46;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				error("illegal store");
			l46:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(normalSend);
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt aValue;
					sqInt errorCode;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt numTemps;
					sqInt object;
					sqInt probe1;
					sqInt rcvr;
					sqInt succeeded;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					/* begin internalFindNewMethodOrdinary */
					hash1 = GIV(messageSelector) ^ lkupClassTag;

					/* first probe */
					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}

					/* second probe */
					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l420;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin classForClassTag: */
					GIV(lkupClass) = lkupClassTag;
					lookupMethodInClass(GIV(lkupClass));

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				l420:	;
				l423:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								aValue = longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
								longAtPointerput(localSP, aValue);
								goto l427;
							}
							if (localPrimIndex == 256) {
								goto l427;
							}
							if (localPrimIndex == 257) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l427;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l427;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l427;
							}
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 1) | 1));
							goto l427;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
						/* begin maybeRetryPrimitiveOnFailure */
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						/* begin successful */
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l427;
						}
					}
					/* begin internalActivateNewMethod */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
						: ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (methodHeader & V3PrimitiveBitsMask) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 0;
						if (GIV(primFailCode) != 0) {
							if ((byteAt(localIP + 1)) == (LongStoreBytecode)) {
								/* begin getErrorObjectFromPrimFailCode */
								if (GIV(primFailCode) > 0) {
									/* begin splObj: */
									table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
									if (GIV(primFailCode) <= (numSlotsOf(table))) {
										errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
										goto l421;
									}
								}
								errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
							l421:	/* end getErrorObjectFromPrimFailCode */;
								longAtPointerput(localSP, errorCode);
							}
							GIV(primFailCode) = 0;
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
											}
				l427:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar1;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object3;
				int onCurrentPage;
				sqInt opType;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage * thePage;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l55;
				}
				if (opType == 1) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l55;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushMaybeContextReceiverVariable: */
					obj = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						if (!(((longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(obj)) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						spouseFP = pointerForOop(senderOop - 1);

						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object3 = longAt(spouseFP + FoxCallerContext);
								goto l58;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP)));
								object3 = longAt(callerFP + FoxThisContext);
								goto l58;
							}
							object3 = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP))),
							(spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord));
							goto l58;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object3 = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l58;
						}
						if (byte3 == InstructionPointerIndex) {
							object3 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l58;
						}
						error("bad index");
						object3 = 0;
					l58:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object3);
					}
					else {
						/* begin internalPush: */
						object11 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
						longAtPointerput((localSP -= BytesPerOop), object11);
					}
					goto l55;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object);
					goto l55;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object1);

					goto l55;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar1, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar1, top);
					}
					longAtput((litVar1 + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), top);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l55;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj1 = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt) (longAt(obj1))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
				 && ((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1));
					assert(!((isObjImmutable(obj1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && (!(isWidowedContext(obj1))))) {
						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(obj1, GIV(youngStart))) {
							possibleRootStoreIntovalue(obj1, top);
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
						if (byte3 == StackPointerIndex) {
						}
						goto l70;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop1 & 1));
					theFP = pointerForOop(senderOop1 - 1);

					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l70;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1);
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
					if (byte3 == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l70:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
				}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
		l55:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;
				sqInt offset;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				offset = ((assert((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(GIV(method))),
			/* begin fetchPointer:ofObject: */
			longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
				literal = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				if ((literal != GIV(nilObj))
				 && (((literal & 1) == 0)
				 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))) {

					/* filters out fullBlock last literal */
					assert((numSlotsOf(literal)) > ValueIndex);
					classPointer = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
				}
				else {
					/* begin nilObject */
					classPointer = GIV(nilObj);
				}
				superclass = longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				/* begin classTagForClass: */
				lkupClassTag = superclass;
				/* begin ensureReceiverUnforwarded */
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l83;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l83:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, 2, size);

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 140:
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				object = longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 141:
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			break;
		case 142:
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt newClosure;
				sqInt newClosure1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt valuePointer;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				/* begin fetchByte */
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l107;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l107:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 145:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 146:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 147:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 148:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 149:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 150:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 151:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l110;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l110:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
									}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l115;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l115:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l119;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l119:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l122;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l125;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l125;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l125;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l125:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l122;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l122:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l126;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l129;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l129;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l129;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l129:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l126;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l126:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l121:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l132;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l135;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l135;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l135;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l135:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l132;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l132:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l136;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l139;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l139;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l139;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l139:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l136;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l136:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((1 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l131:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l144;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l149;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l149;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l149;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l149:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l144;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l144:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l147;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l143;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l143;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l143;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l143:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l147;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l147:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((2 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l141:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l434;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l434;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);

						goto l434;
					}
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l434:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l150;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l153;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l158;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l158;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l158;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l158:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l153;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l153:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l156;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l152;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l152;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l152;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l152:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l156;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l156:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l150;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((3 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l150:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l437;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l437;
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l437:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l162;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l167;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l167;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l167;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l167:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l162;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l162:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l165;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l161;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l161;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l161;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l161:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l165;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l165:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((4 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l159:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l171;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l176;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l176;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l176;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l176:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l171;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l171:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l174;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l170;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l170;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l170;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l170:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l174;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l174:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((5 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l168:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l180;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l185;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l185;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l185;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l185:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l180;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l180:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l183;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l179;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l179;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l179;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l179:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l183;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l183:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((6 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l177:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l189;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l194;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l194;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l194;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l194:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l189;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l189:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l192;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l188;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l188;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l188;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l188:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l192;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l192:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((7 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l186:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt oop1;
				int overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 1) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l196;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l199;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l199;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l199;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l199:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l196;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l196:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l200;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l203;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l203;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l203;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l203:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l200;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l200:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((8 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l195:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
							/* begin fetchNextBytecode */
							/* begin fetchByte */
							currentBytecode = byteAtPointer(++localIP);

							goto l205;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l206;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l209;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l209;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l209;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l209:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l206;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l206:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l210;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l213;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l213;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l213;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l213:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l210;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l210:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l205;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((9 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l205:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt oop;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l215;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((10 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l215:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt arg;
				sqInt oop;
				sqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((((rcvr & 1))
				 || (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))
				 && (((arg & 1))
				 || (((((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))) {
					pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), pt);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l218;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((11 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l218:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt shifted;
				char *sp;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCod